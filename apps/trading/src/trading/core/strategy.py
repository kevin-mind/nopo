"""Base strategy class and signal definitions."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any

import numpy as np
import pandas as pd

from trading.core.types import MarketData, Order, OrderSide, OrderType


class SignalType(Enum):
    """Type of trading signal."""

    LONG = "long"  # Buy/go long
    SHORT = "short"  # Sell/go short
    CLOSE = "close"  # Close position
    HOLD = "hold"  # No action


@dataclass
class Signal:
    """Trading signal generated by a strategy."""

    signal_type: SignalType
    symbol: str
    strength: float = 1.0  # 0-1, used for position sizing
    confidence: float = 1.0  # 0-1, model confidence
    target_price: float | None = None
    stop_loss: float | None = None
    metadata: dict[str, Any] = field(default_factory=dict)

    def to_order(self, quantity: float, limit_price: float | None = None) -> Order | None:
        """Convert signal to an order."""
        if self.signal_type == SignalType.HOLD:
            return None

        if self.signal_type == SignalType.LONG:
            side = OrderSide.BUY
        elif self.signal_type in (SignalType.SHORT, SignalType.CLOSE):
            side = OrderSide.SELL
        else:
            return None

        return Order(
            symbol=self.symbol,
            side=side,
            quantity=quantity,
            order_type=OrderType.LIMIT if limit_price else OrderType.MARKET,
            limit_price=limit_price,
            metadata=self.metadata,
        )


class Strategy(ABC):
    """
    Base class for trading strategies.

    Strategies should focus on steady, incremental gains with proper risk management.
    """

    name: str = "BaseStrategy"

    def __init__(self, params: dict[str, Any] | None = None):
        """Initialize strategy with optional parameters."""
        self.params = params or {}
        self._historical_signals: list[tuple[datetime, Signal]] = []

    @abstractmethod
    def generate_signal(
        self,
        data: MarketData | pd.DataFrame,
        timestamp: datetime,
    ) -> Signal:
        """
        Generate trading signal based on market data.

        Args:
            data: Current market data
            timestamp: Current timestamp

        Returns:
            Trading signal
        """
        ...

    def on_trade(self, timestamp: datetime, price: float, quantity: float) -> None:
        """Called when a trade is executed. Override for custom logic."""
        pass

    def on_bar(self, timestamp: datetime, data: MarketData) -> None:
        """Called on each new bar. Override for custom logic."""
        pass

    def record_signal(self, timestamp: datetime, signal: Signal) -> None:
        """Record a signal for analysis."""
        self._historical_signals.append((timestamp, signal))

    def get_signal_history(self) -> list[tuple[datetime, Signal]]:
        """Get historical signals."""
        return self._historical_signals

    @staticmethod
    def calculate_sma(prices: np.ndarray, period: int) -> np.ndarray:
        """Calculate Simple Moving Average."""
        if len(prices) < period:
            return np.full(len(prices), np.nan)
        return pd.Series(prices).rolling(window=period).mean().values

    @staticmethod
    def calculate_ema(prices: np.ndarray, period: int) -> np.ndarray:
        """Calculate Exponential Moving Average."""
        return pd.Series(prices).ewm(span=period, adjust=False).mean().values

    @staticmethod
    def calculate_rsi(prices: np.ndarray, period: int = 14) -> np.ndarray:
        """Calculate Relative Strength Index."""
        deltas = np.diff(prices, prepend=prices[0])
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)

        avg_gains = pd.Series(gains).rolling(window=period).mean().values
        avg_losses = pd.Series(losses).rolling(window=period).mean().values

        with np.errstate(divide="ignore", invalid="ignore"):
            rs = avg_gains / avg_losses
            rsi = 100 - (100 / (1 + rs))

        return np.nan_to_num(rsi, nan=50.0)

    @staticmethod
    def calculate_bollinger_bands(
        prices: np.ndarray, period: int = 20, std_dev: float = 2.0
    ) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Calculate Bollinger Bands (middle, upper, lower)."""
        sma = pd.Series(prices).rolling(window=period).mean()
        std = pd.Series(prices).rolling(window=period).std()

        middle = sma.values
        upper = (sma + std_dev * std).values
        lower = (sma - std_dev * std).values

        return middle, upper, lower
