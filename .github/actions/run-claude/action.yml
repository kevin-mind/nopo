name: Run Claude
description: Load prompt and run Claude Code

inputs:
  # Prompt inputs (one of prompt, prompt_file, or prompt_dir is required)
  prompt:
    description: Direct prompt string
    required: false
    default: ""
  prompt_file:
    description: Path to the prompt file (relative to repository root) - legacy
    required: false
    default: ""
  prompt_dir:
    description: "Prompt directory name (resolved to .github/prompts/{name}/) - new style with optional outputs.json schema"
    required: false
    default: ""
  prompt_replacements:
    description: "JSON object of template replacements for prompt (e.g., '{\"ISSUE_NUMBER\": \"123\"}')"
    required: false
    default: "{}"

  # Required tokens
  github_token:
    description: GitHub token for API calls and Claude action
    required: true
  claude_code_oauth_token:
    description: OAuth token for Claude Code
    required: true

  # Claude configuration
  model:
    description: Claude model to use
    required: false
    default: "claude-opus-4-5-20251101"
  max_turns:
    description: Maximum number of API round-trips
    required: false
    default: "50"
  settings:
    description: Path to settings file
    required: false
    default: ".claude/settings.json"
  mcp_config:
    description: Path to MCP configuration file (MCP tools are restricted per-agent via their tools field)
    required: false
    default: ".mcp.json"
  show_full_output:
    description: Whether to show full Claude output
    required: false
    default: "false"
  trigger_phrase:
    description: Trigger phrase for @-mentions (e.g., "@claude")
    required: false
    default: ""
  assignee_trigger:
    description: Assignee that triggers action (e.g., "nopo-bot")
    required: false
    default: ""
  allowed_bots:
    description: Comma-separated list of bot usernames allowed to trigger this action (e.g., "github-actions,dependabot")
    required: false
    default: ""

outputs:
  success:
    description: Whether Claude completed successfully
    value: ${{ steps.result.outputs.success }}
  structured_output:
    description: Structured JSON output if outputs.json schema was used
    value: ${{ steps.save_output.outputs.structured_output || steps.claude.outputs.structured_output }}

runs:
  using: "composite"
  steps:
    # Step 1: Load and process prompt
    - name: Load prompt
      id: prompt
      shell: bash
      env:
        PROMPT: ${{ inputs.prompt }}
        PROMPT_FILE: ${{ inputs.prompt_file }}
        PROMPT_DIR: ${{ inputs.prompt_dir }}
        PROMPT_REPLACEMENTS: ${{ inputs.prompt_replacements }}
      run: |
        prompt=""
        output_schema=""

        # Use direct prompt if provided
        if [[ -n "$PROMPT" ]]; then
          prompt="$PROMPT"
        # Use prompt directory (new style: .github/prompts/{name}/)
        elif [[ -n "$PROMPT_DIR" ]]; then
          prompt_path=".github/prompts/$PROMPT_DIR/prompt.txt"
          schema_path=".github/prompts/$PROMPT_DIR/outputs.json"

          if [[ ! -f "$prompt_path" ]]; then
            echo "Error: Prompt file not found: $prompt_path"
            exit 1
          fi
          prompt=$(cat "$prompt_path")

          # Check for outputs.json schema
          if [[ -f "$schema_path" ]]; then
            echo "Found output schema: $schema_path"
            output_schema=$(cat "$schema_path" | jq -c .)
          fi
        # Use prompt file (legacy style)
        elif [[ -n "$PROMPT_FILE" ]]; then
          if [[ ! -f "$PROMPT_FILE" ]]; then
            echo "Error: Prompt file not found: $PROMPT_FILE"
            exit 1
          fi
          prompt=$(cat "$PROMPT_FILE")
        else
          echo "Error: One of prompt, prompt_file, or prompt_dir must be provided"
          exit 1
        fi

        # Apply template replacements from JSON
        if [[ "$PROMPT_REPLACEMENTS" != "{}" ]]; then
          while IFS='=' read -r key value; do
            # Remove quotes from value if present
            value="${value%\"}"
            value="${value#\"}"
            # Replace {{KEY}} with value
            prompt="${prompt//\{\{$key\}\}/$value}"
          done < <(echo "$PROMPT_REPLACEMENTS" | jq -r 'to_entries[] | "\(.key)=\(.value)"')
        fi

        # Save prompt to environment file for multiline content
        # Using heredoc delimiter for $GITHUB_OUTPUT
        {
          echo "prompt<<EOF_PROMPT_CONTENT"
          echo "$prompt"
          echo "EOF_PROMPT_CONTENT"
        } >> "$GITHUB_OUTPUT"

        # Save schema if found
        if [[ -n "$output_schema" ]]; then
          echo "output_schema=$output_schema" >> "$GITHUB_OUTPUT"
        fi

    # Step 2: Run Claude Code
    - name: Build Claude args
      id: claude_args
      shell: bash
      env:
        OUTPUT_SCHEMA: ${{ steps.prompt.outputs.output_schema }}
      run: |
        args="--model ${{ inputs.model }} --max-turns ${{ inputs.max_turns }}"

        # Add MCP config if file exists
        if [[ -n "${{ inputs.mcp_config }}" && -f "${{ inputs.mcp_config }}" ]]; then
          args="$args --mcp-config ${{ inputs.mcp_config }}"
        fi

        echo "args=$args" >> "$GITHUB_OUTPUT"

        # Note: --json-schema causes SDK crashes, so we disable SDK structured outputs
        # Instead, we tell Claude to output JSON and parse it manually
        if [[ -n "$OUTPUT_SCHEMA" ]]; then
          echo "Found output schema - expecting JSON output from Claude"
          echo "expect_json=true" >> "$GITHUB_OUTPUT"
        fi

    - name: Run Claude
      id: claude
      uses: anthropics/claude-code-action@v1
      with:
        claude_code_oauth_token: ${{ inputs.claude_code_oauth_token }}
        github_token: ${{ inputs.github_token }}
        prompt: ${{ steps.prompt.outputs.prompt }}
        settings: ${{ inputs.settings }}
        claude_args: ${{ steps.claude_args.outputs.args }}
        show_full_output: ${{ inputs.show_full_output }}
        trigger_phrase: ${{ inputs.trigger_phrase }}
        assignee_trigger: ${{ inputs.assignee_trigger }}
        allowed_bots: ${{ inputs.allowed_bots }}
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}

    # Step 3: Verify and output structured JSON
    # Claude writes the file directly via the Write tool
    - name: Verify structured output
      id: save_output
      if: steps.claude_args.outputs.expect_json == 'true'
      shell: bash
      env:
        STRUCTURED_OUTPUT: ${{ steps.claude.outputs.structured_output }}
      run: |
        # Claude should have written the file directly
        if [[ -f "claude-structured-output.json" ]]; then
          echo "Found claude-structured-output.json written by Claude"
        elif [[ -n "$STRUCTURED_OUTPUT" ]]; then
          # Fallback: use SDK structured output if available
          echo "Using SDK structured output"
          echo "$STRUCTURED_OUTPUT" > claude-structured-output.json
        else
          echo "::error::claude-structured-output.json not found - Claude may not have written the file"
          echo "Check if Claude was prompted to write to claude-structured-output.json"
          exit 1
        fi

        echo "::group::Structured Output"
        cat claude-structured-output.json | jq . || { echo "::error::Output is not valid JSON"; exit 1; }
        echo "::endgroup::"

        # Set output from file
        {
          echo "structured_output<<EOF_STRUCTURED"
          cat claude-structured-output.json
          echo "EOF_STRUCTURED"
        } >> "$GITHUB_OUTPUT"

    # Step 4: Set result output
    - name: Set result
      id: result
      if: always()
      shell: bash
      run: |
        if [[ "${{ steps.claude.outcome }}" == "success" ]]; then
          echo "success=true" >> "$GITHUB_OUTPUT"
        else
          echo "success=false" >> "$GITHUB_OUTPUT"
        fi
