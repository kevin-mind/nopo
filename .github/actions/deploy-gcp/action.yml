name: Deploy to GCP
description: Deploy services to Google Cloud Platform using Terraform

inputs:
  project_id:
    description: The GCP project ID
    required: true
  region:
    description: The GCP region
    required: false
    default: "us-central1"
  environment:
    description: The deployment environment (stage, prod)
    required: true
  domain:
    description: The domain name
    required: true
  subdomain_prefix:
    description: The subdomain prefix (e.g., 'stage' or empty for apex)
    required: false
    default: ""
  service_images:
    description: JSON object mapping service names to their Docker image tags
    required: true
  terraform_state_bucket:
    description: The GCS bucket for Terraform state
    required: true
  working_directory:
    description: The Terraform working directory
    required: false
    default: "infrastructure/terraform/environments"

outputs:
  load_balancer_ip:
    description: The load balancer IP address
    value: ${{ steps.apply.outputs.load_balancer_ip }}
  public_url:
    description: The public URL
    value: ${{ steps.apply.outputs.public_url }}
  services:
    description: JSON object of deployed services
    value: ${{ steps.apply.outputs.services }}
  static_bucket_name:
    description: The name of the static assets bucket
    value: ${{ steps.apply.outputs.static_bucket_name }}

runs:
  using: "composite"
  steps:
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.7.0"
        terraform_wrapper: false

    - name: Build services configuration
      id: services_config
      shell: bash
      env:
        SERVICE_IMAGES: ${{ inputs.service_images }}
        ENVIRONMENT: ${{ inputs.environment }}
      run: |
        # Build the Terraform services variable from discovered services and their images
        # Input: {"backend":"registry/backend:tag","web":"registry/web:tag"}
        # Output: Terraform-compatible services map

        echo "Building services configuration..."
        echo "Service images: ${SERVICE_IMAGES}"

        # Read infrastructure.json from each service directory to get config
        services_tf="{}"

        for service in $(echo "${SERVICE_IMAGES}" | jq -r 'keys[]'); do
          image=$(echo "${SERVICE_IMAGES}" | jq -r --arg s "$service" '.[$s]')
          
          # Default configuration
          cpu="1"
          memory="512Mi"
          port="3000"
          min_instances="0"
          max_instances="10"
          has_database="false"
          run_migrations="false"
          
          # Check for service-specific config
          config_file="apps/${service}/infrastructure.json"
          if [[ -f "${config_file}" ]]; then
            echo "Loading config from ${config_file}"
            cpu=$(jq -r '.cpu // "1"' "${config_file}")
            memory=$(jq -r '.memory // "512Mi"' "${config_file}")
            port=$(jq -r '.port // 3000' "${config_file}")
            min_instances=$(jq -r '.min_instances // 0' "${config_file}")
            max_instances=$(jq -r '.max_instances // 10' "${config_file}")
            has_database=$(jq -r '.has_database // false' "${config_file}")
            run_migrations=$(jq -r '.run_migrations // false' "${config_file}")
          fi
          
          # Adjust min_instances for production
          if [[ "${ENVIRONMENT}" == "prod" && "${min_instances}" == "0" ]]; then
            min_instances="1"
          fi
          
          # Build service object
          service_obj=$(jq -n \
            --arg image "${image}" \
            --arg cpu "${cpu}" \
            --arg memory "${memory}" \
            --argjson port "${port}" \
            --argjson min "${min_instances}" \
            --argjson max "${max_instances}" \
            --argjson db "${has_database}" \
            --argjson migrate "${run_migrations}" \
            '{
              image: $image,
              cpu: $cpu,
              memory: $memory,
              port: $port,
              min_instances: $min,
              max_instances: $max,
              has_database: $db,
              run_migrations: $migrate
            }')
          
          services_tf=$(echo "${services_tf}" | jq --arg k "${service}" --argjson v "${service_obj}" '. + {($k): $v}')
        done

        echo "Services configuration:"
        echo "${services_tf}" | jq .
        
        # Save to file for Terraform
        echo "${services_tf}" > services.json
        
        # Output as compact JSON (single line) for GitHub Actions
        services_compact=$(echo "${services_tf}" | jq -c .)
        echo "services_json=${services_compact}" >> "$GITHUB_OUTPUT"

    - name: Terraform Init
      shell: bash
      working-directory: ${{ inputs.working_directory }}/${{ inputs.environment }}
      env:
        TF_STATE_BUCKET: ${{ inputs.terraform_state_bucket }}
        ENVIRONMENT: ${{ inputs.environment }}
      run: |
        terraform init -input=false \
          -backend-config="bucket=${TF_STATE_BUCKET}" \
          -backend-config="prefix=nopo/${ENVIRONMENT}"

    - name: Terraform Plan
      shell: bash
      working-directory: ${{ inputs.working_directory }}/${{ inputs.environment }}
      env:
        TF_VAR_project_id: ${{ inputs.project_id }}
        TF_VAR_region: ${{ inputs.region }}
        TF_VAR_domain: ${{ inputs.domain }}
        TF_VAR_subdomain_prefix: ${{ inputs.subdomain_prefix }}
      run: |
        # Pass services as JSON variable
        terraform plan -input=false -out=tfplan \
          -var='services=${{ steps.services_config.outputs.services_json }}'

    - name: Terraform Apply
      id: apply
      shell: bash
      working-directory: ${{ inputs.working_directory }}/${{ inputs.environment }}
      run: |
        terraform apply -input=false -auto-approve tfplan

        # Extract outputs
        load_balancer_ip=$(terraform output -raw load_balancer_ip 2>/dev/null || echo "")
        public_url=$(terraform output -raw public_url 2>/dev/null || echo "")
        services=$(terraform output -json services_summary 2>/dev/null || echo "{}")
        static_bucket_name=$(terraform output -raw static_bucket_name 2>/dev/null || echo "")

        echo "load_balancer_ip=${load_balancer_ip}" >> "$GITHUB_OUTPUT"
        echo "public_url=${public_url}" >> "$GITHUB_OUTPUT"
        echo "services=${services}" >> "$GITHUB_OUTPUT"
        echo "static_bucket_name=${static_bucket_name}" >> "$GITHUB_OUTPUT"

    - name: Build and upload static assets
      if: steps.apply.outputs.static_bucket_name != ''
      shell: bash
      env:
        STATIC_BUCKET: ${{ steps.apply.outputs.static_bucket_name }}
      run: |
        echo "Static bucket: ${STATIC_BUCKET}"
        echo "Building and uploading static assets..."
        
        # Iterate through each service directory
        for service_dir in apps/*/; do
          service=$(basename "${service_dir}")
          config_file="${service_dir}infrastructure.json"
          
          # Check if service has static_path configured
          if [[ -f "${config_file}" ]]; then
            static_path=$(jq -r '.static_path // empty' "${config_file}")
            
            if [[ -n "${static_path}" && "${static_path}" != "null" ]]; then
              echo ""
              echo "=== Processing ${service} ==="
              build_dir="${service_dir}${static_path}"
              
              # Build static assets
              echo "Building static assets for ${service}..."
              pnpm --filter "@more/${service}" build || {
                echo "Warning: Build failed for ${service}, skipping..."
                continue
              }
              
              # Upload to bucket
              if [[ -d "${build_dir}" ]]; then
                echo "Uploading ${build_dir} to gs://${STATIC_BUCKET}/${service}/"
                gcloud storage cp -r "${build_dir}/*" "gs://${STATIC_BUCKET}/${service}/" \
                  --cache-control="public, max-age=31536000, immutable" \
                  --quiet
                echo "âœ“ Static assets uploaded for ${service}"
              else
                echo "Warning: Build directory ${build_dir} not found for ${service}"
              fi
            fi
          fi
        done
        
        echo ""
        echo "Static asset upload complete!"

    - name: Cleanup plan file
      shell: bash
      working-directory: ${{ inputs.working_directory }}/${{ inputs.environment }}
      if: always()
      run: rm -f tfplan services.json
