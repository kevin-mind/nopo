name: Release
'on':
  push:
    branches:
      - main
  merge_group: {}
  workflow_dispatch:
    inputs:
      mock:
        description: 'Mock mode: pass, fail, or empty for real release'
        type: string
        required: false
      ref:
        description: 'Git ref to run release on (for mock mode with specific branch)'
        type: string
        required: false
concurrency:
  group: ${{ github.workflow }}-${{ (github.event_name == 'merge_group' || github.event_name == 'push' && github.event.sender.login != 'github-merge-queue[bot]') && 'push' || 'pr' }}
  cancel-in-progress: true
permissions: {}
defaults:
  run:
    shell: bash
env:
  CI: 'true'
jobs:
  # ============================================================================
  # MOCK MODE DETECTION - For configurable test runner
  # When triggered via workflow_dispatch with mock=pass or mock=fail,
  # skip real release jobs and immediately return the mocked result.
  # ============================================================================
  mock-detect:
    runs-on: ubuntu-latest
    outputs:
      mock_mode: ${{ steps.detect.outputs.mock_mode }}
      mock_result: ${{ steps.detect.outputs.mock_result }}
    steps:
      - name: Detect mock mode
        id: detect
        run: |
          if [[ "${{ inputs.mock }}" == "pass" || "${{ inputs.mock }}" == "fail" ]]; then
            echo "mock_mode=true" >> $GITHUB_OUTPUT
            echo "mock_result=${{ inputs.mock }}" >> $GITHUB_OUTPUT
            echo "::notice::Mock mode enabled - result will be: ${{ inputs.mock }}"
          else
            echo "mock_mode=false" >> $GITHUB_OUTPUT
            echo "mock_result=" >> $GITHUB_OUTPUT
          fi

  # ============================================================================
  # MOCK OUTCOME - Immediate pass/fail for test runner
  # ============================================================================
  mock-outcome:
    needs: [mock-detect]
    if: needs.mock-detect.outputs.mock_mode == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Mock result
        run: |
          if [[ "${{ needs.mock-detect.outputs.mock_result }}" == "fail" ]]; then
            echo "::error::Mock release failure (requested by test runner)"
            exit 1
          else
            echo "::notice::Mock release success (requested by test runner)"
          fi

  # ============================================================================
  # E2E MODE DETECTION - Verify workflow run and parse outcome
  # Security: Only honors e2e markers when the referenced workflow is actually running
  # For release: checks commit message from merge queue or push event
  # Also checks for .github/e2e-test-config.json file
  # ============================================================================
  e2e-detect:
    needs: [mock-detect]
    # Skip in mock mode - mock-outcome handles the result
    if: needs.mock-detect.outputs.mock_mode != 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
    outputs:
      e2e_mode: ${{ steps.detect.outputs.e2e_mode }}
      ci_outcome: ${{ steps.detect.outputs.ci_outcome }}
      release_outcome: ${{ steps.detect.outputs.release_outcome }}
      review_outcome: ${{ steps.detect.outputs.review_outcome }}
    steps:
      - name: Checkout for config file
        uses: actions/checkout@v4
        with:
          sparse-checkout: .github/e2e-test-config.json
          sparse-checkout-cone-mode: false

      - name: Get commit message
        id: commit
        env:
          GH_TOKEN: ${{ github.token }}
          EVENT_NAME: ${{ github.event_name }}
          MERGE_GROUP_HEAD_SHA: ${{ github.event.merge_group.head_sha }}
        run: |
          # Get commit message based on event type
          if [[ "$EVENT_NAME" == "merge_group" ]]; then
            # For merge queue, get commit from merge group head
            commit_sha="${MERGE_GROUP_HEAD_SHA:-${{ github.sha }}}"
          else
            # For push event, use the head commit
            commit_sha="${{ github.sha }}"
          fi

          commit_msg=$(gh api repos/${{ github.repository }}/commits/$commit_sha --jq '.commit.message' 2>/dev/null || echo "")
          echo "message<<EOF" >> $GITHUB_OUTPUT
          echo "$commit_msg" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Detect E2E mode
        id: detect
        env:
          GH_TOKEN: ${{ github.token }}
          COMMIT_MSG: ${{ steps.commit.outputs.message }}
          EVENT_NAME: ${{ github.event_name }}
          MERGE_GROUP_HEAD_REF: ${{ github.event.merge_group.head_ref }}
        run: |
          e2e_mode=false
          run_id=""
          ci_outcome="success"
          release_outcome="success"
          review_outcome="approved"

          # Method 1: Check for e2e config file
          if [[ -f ".github/e2e-test-config.json" ]]; then
            echo "Found .github/e2e-test-config.json"
            config=$(cat .github/e2e-test-config.json)
            run_id=$(echo "$config" | jq -r '.run_id // empty')

            if [[ -n "$run_id" ]]; then
              # For release (after merge), use the last outcome in each array
              # This is the "final" state after all iterations
              ci_outcome=$(echo "$config" | jq -r '.outcomes.ci[-1] // "success"')
              release_outcome=$(echo "$config" | jq -r '.outcomes.release[-1] // "success"')
              review_outcome=$(echo "$config" | jq -r '.outcomes.review[-1] // "approved"')

              echo "Config file (release): run_id=$run_id, ci=$ci_outcome, release=$release_outcome, review=$review_outcome"
            fi
          fi

          # Method 2: Check commit message for marker pattern (fallback)
          if [[ -z "$run_id" && "$COMMIT_MSG" =~ \[e2e:([0-9]+):ci=(success|failure):release=(success|failure):review=(approved|changes_requested|comment)\] ]]; then
            run_id="${BASH_REMATCH[1]}"
            ci_outcome="${BASH_REMATCH[2]}"
            release_outcome="${BASH_REMATCH[3]}"
            review_outcome="${BASH_REMATCH[4]}"
            echo "Found e2e marker in commit: run_id=$run_id, ci=$ci_outcome, release=$release_outcome, review=$review_outcome"
          fi

          # Method 3: For merge_group, check if linked issue has _e2e label
          # This handles the case where the merge queue creates a new commit
          if [[ -z "$run_id" && "$EVENT_NAME" == "merge_group" && -n "$MERGE_GROUP_HEAD_REF" ]]; then
            echo "Checking merge queue for _e2e label..."
            # Extract PR number from branch: gh-readonly-queue/main/pr-{N}-{sha}
            if [[ "$MERGE_GROUP_HEAD_REF" =~ pr-([0-9]+) ]]; then
              pr_number="${BASH_REMATCH[1]}"
              echo "Extracted PR #$pr_number from merge queue branch"

              # Get PR body and extract linked issue number from "Fixes #N"
              pr_body=$(gh api repos/${{ github.repository }}/pulls/$pr_number --jq '.body' 2>/dev/null || echo "")
              if [[ "$pr_body" =~ Fixes[[:space:]]+#([0-9]+) ]]; then
                linked_issue="${BASH_REMATCH[1]}"
                echo "Found linked issue #$linked_issue in PR body"

                # Check if linked issue has _e2e label
                has_e2e_label=$(gh api repos/${{ github.repository }}/issues/$linked_issue --jq '.labels[].name' 2>/dev/null | grep -q "^_e2e$" && echo "true" || echo "false")

                if [[ "$has_e2e_label" == "true" ]]; then
                  echo "::notice::E2E mode detected via _e2e label on linked issue #$linked_issue"
                  e2e_mode=true
                  # For label-based detection, use default success outcomes
                  # (the e2e test has already passed CI/review to get here)
                fi
              else
                echo "No 'Fixes #N' pattern found in PR body"
              fi
            fi
          fi

          # Verify the workflow is actually running (only for config/marker methods)
          if [[ -n "$run_id" ]]; then
            status=$(gh api repos/${{ github.repository }}/actions/runs/$run_id --jq '.status' 2>/dev/null || echo "not_found")

            if [[ "$status" == "in_progress" ]]; then
              echo "::notice::E2E mode verified - workflow $run_id is running"
              e2e_mode=true
            else
              echo "::warning::E2E marker found but workflow $run_id is not running (status: $status)"
            fi
          fi

          if [[ "$e2e_mode" != "true" ]]; then
            echo "No e2e marker found"
          fi

          echo "e2e_mode=$e2e_mode" >> $GITHUB_OUTPUT
          echo "ci_outcome=$ci_outcome" >> $GITHUB_OUTPUT
          echo "release_outcome=$release_outcome" >> $GITHUB_OUTPUT
          echo "review_outcome=$review_outcome" >> $GITHUB_OUTPUT

  # ============================================================================
  # ISSUE EXTRACTION - Find linked issue numbers for iteration logging
  # Handles batched merge queue PRs by extracting all PR numbers
  # ============================================================================
  extract-issue:
    needs: [mock-detect]
    # Skip in mock mode
    if: needs.mock-detect.outputs.mock_mode != 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
    outputs:
      # JSON arrays to support batched merge queue PRs
      issues_json: ${{ steps.extract.outputs.issues_json }}
      prs_json: ${{ steps.extract.outputs.prs_json }}
      has_issues: ${{ steps.extract.outputs.has_issues }}
    steps:
      - uses: actions/checkout@v4
      - name: Extract issue numbers
        id: extract
        env:
          GH_TOKEN: ${{ github.token }}
          EVENT_NAME: ${{ github.event_name }}
          # shellcheck: disable=SC2153 - MERGE_GROUP_HEAD_REF is intentionally uppercase
          MERGE_GROUP_HEAD_REF: ${{ github.event.merge_group.head_ref }}
          COMMIT_MSG: ${{ github.event.head_commit.message }}
        run: |
          issues=()
          prs=()

          if [[ "$EVENT_NAME" == "merge_group" ]]; then
            # Extract ALL PR numbers from merge queue branch
            # Format: gh-readonly-queue/main/pr-123-abc123 or batched: pr-123-abc123-pr-456-def456
            echo "Parsing merge queue head_ref: $MERGE_GROUP_HEAD_REF"

            # Use grep to find all pr-N patterns
            pr_numbers=$(echo "$MERGE_GROUP_HEAD_REF" | grep -oE 'pr-[0-9]+' | grep -oE '[0-9]+' || true)

            for pr_num in $pr_numbers; do
              echo "Processing PR #$pr_num"
              prs+=("$pr_num")

              # Get PR details to find linked issue
              pr_data=$(gh pr view "$pr_num" --json body,headRefName 2>/dev/null || echo "{}")
              if [[ "$pr_data" != "{}" ]]; then
                head_ref=$(echo "$pr_data" | jq -r '.headRefName // empty')
                body=$(echo "$pr_data" | jq -r '.body // empty')

                # Check if it's a Claude PR by branch name
                if [[ "$head_ref" =~ ^claude/issue/([0-9]+)$ ]]; then
                  issue_num="${BASH_REMATCH[1]}"
                  issues+=("$issue_num")
                  echo "  Found issue $issue_num from Claude branch"
                # Fall back to parsing PR body for "Fixes #N"
                elif [[ "$body" =~ Fixes[[:space:]]*#([0-9]+) ]]; then
                  issue_num="${BASH_REMATCH[1]}"
                  issues+=("$issue_num")
                  echo "  Found issue $issue_num from PR body"
                else
                  echo "  No linked issue found for PR #$pr_num"
                fi
              fi
            done

          elif [[ "$EVENT_NAME" == "push" ]]; then
            # For push events, check commit message for issue references
            if [[ "$COMMIT_MSG" =~ Fixes[[:space:]]*#([0-9]+) ]]; then
              issues+=("${BASH_REMATCH[1]}")
              echo "Found issue ${BASH_REMATCH[1]} from commit message"
            elif [[ "$COMMIT_MSG" =~ \#([0-9]+) ]]; then
              issues+=("${BASH_REMATCH[1]}")
              echo "Found issue ${BASH_REMATCH[1]} from commit reference"
            fi

            # Try to find the merged PR
            merged_pr=$(gh pr list --state merged --limit 1 --json number,headRefName -q '.[0]' 2>/dev/null || echo "{}")
            if [[ -n "$merged_pr" && "$merged_pr" != "{}" ]]; then
              pr_num=$(echo "$merged_pr" | jq -r '.number')
              head_ref=$(echo "$merged_pr" | jq -r '.headRefName')
              prs+=("$pr_num")

              if [[ "$head_ref" =~ ^claude/issue/([0-9]+)$ ]]; then
                # Prefer issue from branch name (more reliable)
                issues=("${BASH_REMATCH[1]}")
                echo "Found issue ${BASH_REMATCH[1]} from merged PR branch"
              fi
            fi
          fi

          # Convert arrays to JSON (compact format for GITHUB_OUTPUT)
          issues_json=$(printf '%s\n' "${issues[@]}" | jq -R . | jq -sc 'unique')
          prs_json=$(printf '%s\n' "${prs[@]}" | jq -R . | jq -sc 'unique')
          has_issues=$([[ ${#issues[@]} -gt 0 ]] && echo "true" || echo "false")

          echo "issues_json=$issues_json" >> "$GITHUB_OUTPUT"
          echo "prs_json=$prs_json" >> "$GITHUB_OUTPUT"
          echo "has_issues=$has_issues" >> "$GITHUB_OUTPUT"

          echo "Summary: issues=$issues_json, prs=$prs_json, has_issues=$has_issues"

  # Merge queue entry is logged by sm-trigger.yml when merge_group triggers it.

  # ============================================================================
  # LOG: MERGED TO MAIN (push event - covers both merge queue and direct merges)
  # ============================================================================
  log-merged:
    if: github.event_name == 'push' && needs.extract-issue.outputs.has_issues == 'true'
    needs: extract-issue
    runs-on: ubuntu-latest
    permissions:
      actions: write
    strategy:
      matrix:
        issue: ${{ fromJson(needs.extract-issue.outputs.issues_json) }}
      fail-fast: false
    steps:
      - name: Trigger state machine (pr-merged)
        env:
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
        run: |
          gh workflow run sm-trigger.yml \
            --repo "$GITHUB_REPOSITORY" \
            -f resource_number="${{ matrix.issue }}" \
            -f trigger_type=pr-merged

  context:
    needs: [mock-detect]
    # Skip in mock mode
    if: needs.mock-detect.outputs.mock_mode != 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      push: ${{ steps.push_deploy.outputs.push }}
      deploy: ${{ steps.push_deploy.outputs.deploy }}
    steps:
      - id: checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - id: setup_node
        uses: ./.github/actions/setup-node
      - id: context
        name: Context
        uses: ./.github/actions/context
      - id: push_deploy
        name: Push / Deploy
        env:
          event_name: ${{ github.event_name }}
          actor: ${{ github.event.sender.login }}
          merge_actor: github-merge-queue[bot]
        run: |-
          push=false
          deploy=false

          # Push images on merge queue. This only runs on the target repo
          # so no need to check if it is a fork.
          if [[ "$event_name" == "merge_group" ]]; then
            push=true
            deploy=true
          # Push images on push events that were not sent by the merge queue bot
          # as merge queue commits are deployed before the PR is merged.
          elif [[ "$event_name" == "push" && "$actor" != "$merge_actor" ]]; then
            push=true
            deploy=true
          fi

          echo "event_name=$event_name"
          echo "push=$push" >> $GITHUB_OUTPUT
          echo "deploy=$deploy" >> $GITHUB_OUTPUT
          cat "$GITHUB_OUTPUT"
  discover_buildable:
    needs: [mock-detect]
    # Skip in mock mode
    if: needs.mock-detect.outputs.mock_mode != 'true'
    permissions:
      contents: read
    uses: ./.github/workflows/_services.yml
    with:
      filter: buildable
      ref: ${{ github.sha }}
  discover_services:
    needs: [mock-detect]
    # Skip in mock mode â€” discover only buildable runtime services for deployment
    if: needs.mock-detect.outputs.mock_mode != 'true'
    permissions:
      contents: read
    uses: ./.github/workflows/_services.yml
    with:
      filter: service buildable
      ref: ${{ github.sha }}
  version:
    needs: [mock-detect, context]
    # Skip in mock mode
    if: ${{ needs.mock-detect.outputs.mock_mode != 'true' && github.event_name == 'push' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: read
      pull-requests: write
    steps:
      - id: checkout
        uses: actions/checkout@v4
      - id: setup_node
        uses: ./.github/actions/setup-node
      - id: setup_nopo
        uses: ./.github/actions/setup-nopo
      - id: build
        name: Build packages
        run: nopo compile packages root
      - id: publish_versions
        name: Create and publish versions
        uses: changesets/action@v1
        with:
          commit: 'chore: update versions'
          title: 'chore: update versions'
          publish: nopo publish root
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
  build:
    # Skip in mock mode or e2e mode
    if: ${{ needs.mock-detect.outputs.mock_mode != 'true' && needs.e2e-detect.outputs.e2e_mode != 'true' }}
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    uses: ./.github/workflows/_build.yml
    secrets: inherit
    with:
      push: ${{ needs.context.outputs.push == 'true' }}
      services: ${{ needs.discover_buildable.outputs.services }}
      # Multi-platform for production deployments
      platforms: linux/amd64,linux/arm64
      driver: docker-container
    needs:
      - mock-detect
      - e2e-detect
      - context
      - discover_buildable
  test:
    # Skip in mock mode or e2e mode
    if: ${{ needs.mock-detect.outputs.mock_mode != 'true' && needs.e2e-detect.outputs.e2e_mode != 'true' }}
    permissions:
      contents: read
      packages: read
    uses: ./.github/workflows/_test.yml
    secrets: inherit
    with:
      tag: ${{ needs.build.outputs.tag }}
      services: ${{ needs.discover_buildable.outputs.services_json }}
    needs:
      - mock-detect
      - e2e-detect
      - build
      - context
      - discover_buildable
  deploy_stage:
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    uses: ./.github/workflows/_deploy_gcp.yml
    secrets: inherit
    with:
      environment: stage
      version: ${{ needs.build.outputs.version }}
      digest: ${{ needs.build.outputs.digest }}
      services: ${{ needs.discover_services.outputs.services_json }}
      # E2E mode inputs - skips expensive operations and simulates outcome
      e2e_mode: ${{ needs.e2e-detect.outputs.e2e_mode == 'true' }}
      e2e_outcome: ${{ needs.e2e-detect.outputs.release_outcome }}
    needs:
      - e2e-detect
      - context
      - build
      - test
      - discover_services

  deploy_prod:
    permissions:
      contents: read
      packages: write
      attestations: write
      id-token: write
    uses: ./.github/workflows/_deploy_gcp.yml
    secrets: inherit
    with:
      environment: prod
      version: ${{ needs.build.outputs.version }}
      digest: ${{ needs.build.outputs.digest }}
      services: ${{ needs.discover_services.outputs.services_json }}
      # E2E mode inputs - skips expensive operations and simulates outcome
      e2e_mode: ${{ needs.e2e-detect.outputs.e2e_mode == 'true' }}
      e2e_outcome: ${{ needs.e2e-detect.outputs.release_outcome }}
    needs:
      - e2e-detect
      - context
      - build
      - deploy_stage
      - test
      - discover_services

  # ============================================================================
  # LOG: STAGE DEPLOY SUCCESS
  # ============================================================================
  log-stage-deployed:
    if: always() && needs.context.outputs.deploy == 'true' && needs.deploy_stage.result == 'success' && needs.extract-issue.outputs.has_issues == 'true'
    needs:
      - context
      - extract-issue
      - deploy_stage
    runs-on: ubuntu-latest
    permissions:
      actions: write
    strategy:
      matrix:
        issue: ${{ fromJson(needs.extract-issue.outputs.issues_json) }}
      fail-fast: false
    steps:
      - name: Trigger state machine (deployed-stage)
        env:
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
        run: |
          gh workflow run sm-trigger.yml \
            --repo "$GITHUB_REPOSITORY" \
            -f resource_number="${{ matrix.issue }}" \
            -f trigger_type=deployed-stage

  # ============================================================================
  # LOG: STAGE DEPLOY FAILED
  # ============================================================================
  log-stage-deploy-failed:
    if: always() && needs.context.outputs.deploy == 'true' && needs.deploy_stage.result == 'failure' && needs.extract-issue.outputs.has_issues == 'true'
    needs:
      - context
      - extract-issue
      - deploy_stage
    runs-on: ubuntu-latest
    permissions:
      actions: write
    strategy:
      matrix:
        issue: ${{ fromJson(needs.extract-issue.outputs.issues_json) }}
      fail-fast: false
    steps:
      - name: Trigger state machine (deployed-stage-failed)
        env:
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
        run: |
          gh workflow run sm-trigger.yml \
            --repo "$GITHUB_REPOSITORY" \
            -f resource_number="${{ matrix.issue }}" \
            -f trigger_type=deployed-stage-failed

  # ============================================================================
  # LOG: PROD DEPLOY SUCCESS
  # ============================================================================
  log-released:
    if: always() && needs.context.outputs.deploy == 'true' && needs.deploy_prod.result == 'success' && needs.extract-issue.outputs.has_issues == 'true'
    needs:
      - context
      - extract-issue
      - deploy_prod
    runs-on: ubuntu-latest
    permissions:
      actions: write
    strategy:
      matrix:
        issue: ${{ fromJson(needs.extract-issue.outputs.issues_json) }}
      fail-fast: false
    steps:
      - name: Trigger state machine (deployed-prod)
        env:
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
        run: |
          gh workflow run sm-trigger.yml \
            --repo "$GITHUB_REPOSITORY" \
            -f resource_number="${{ matrix.issue }}" \
            -f trigger_type=deployed-prod

  # ============================================================================
  # LOG: PROD DEPLOY FAILED
  # ============================================================================
  log-prod-deploy-failed:
    if: always() && needs.context.outputs.deploy == 'true' && needs.deploy_prod.result == 'failure' && needs.extract-issue.outputs.has_issues == 'true'
    needs:
      - context
      - extract-issue
      - deploy_prod
    runs-on: ubuntu-latest
    permissions:
      actions: write
    strategy:
      matrix:
        issue: ${{ fromJson(needs.extract-issue.outputs.issues_json) }}
      fail-fast: false
    steps:
      - name: Trigger state machine (deployed-prod-failed)
        env:
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
        run: |
          gh workflow run sm-trigger.yml \
            --repo "$GITHUB_REPOSITORY" \
            -f resource_number="${{ matrix.issue }}" \
            -f trigger_type=deployed-prod-failed

  # ============================================================================
  # LOG: REMOVED FROM QUEUE (merge_group failure)
  # ============================================================================
  log-queue-failure:
    if: >-
      always() &&
      github.event_name == 'merge_group' &&
      needs.extract-issue.outputs.has_issues == 'true' &&
      (needs.build.result != 'success' || needs.test.result != 'success' || needs.deploy_stage.result != 'success' || needs.deploy_prod.result != 'success')
    needs:
      - extract-issue
      - build
      - test
      - deploy_stage
      - deploy_prod
    runs-on: ubuntu-latest
    permissions:
      actions: write
    strategy:
      matrix:
        issue: ${{ fromJson(needs.extract-issue.outputs.issues_json) }}
      fail-fast: false
    steps:
      - name: Trigger state machine (merge-queue-failed)
        env:
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
        run: |
          gh workflow run sm-trigger.yml \
            --repo "$GITHUB_REPOSITORY" \
            -f resource_number="${{ matrix.issue }}" \
            -f trigger_type=merge-queue-failed

  checks:
    if: always()
    runs-on: ubuntu-latest
    steps:
      - id: checkout
        uses: actions/checkout@v4
      - id: check
        name: Check
        uses: ./.github/actions/check
        with:
          json: ${{ toJson(needs) }}
    needs:
      - mock-detect
      - mock-outcome
      - e2e-detect
      - build
      - test
      - deploy_stage
      - deploy_prod
