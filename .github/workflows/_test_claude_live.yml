name: Live E2E Test

on:
  workflow_dispatch:
    inputs:
      category:
        description: 'Improvement category for the scout'
        type: choice
        options:
          - random
          - documentation
          - tests
          - performance
          - readability
          - type-safety
        default: random
      skip_merge:
        description: 'Skip merging the PR (observe only)'
        type: boolean
        default: true

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write
  id-token: write

concurrency:
  group: live-e2e-test
  cancel-in-progress: false

env:
  GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}

jobs:
  live-test:
    runs-on: ubuntu-latest
    outputs:
      issue_number: ${{ steps.create-issue.outputs.issue_number }}
      result: ${{ steps.result.outputs.json }}
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup-node
      - uses: ./.github/actions/setup-nopo
      - run: nopo build --tags github-actions

      - name: Install Claude Code
        run: |
          set -e
          echo "Installing Claude Code..."
          curl -fsSL https://claude.ai/install.sh | bash
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"
          if [ -f "$HOME/.local/bin/claude" ]; then
            echo "Claude Code installed"
            "$HOME/.local/bin/claude" --version || echo "Warning: Could not get version"
          else
            echo "::error::Claude Code installation failed"
            exit 1
          fi

      - name: Select category
        id: category
        run: |
          INPUT="${{ inputs.category }}"
          if [ "$INPUT" = "random" ]; then
            CATEGORIES=("documentation" "tests" "performance" "readability" "type-safety")
            INDEX=$(( RANDOM % 5 ))
            CATEGORY="${CATEGORIES[$INDEX]}"
            echo "Randomly selected: $CATEGORY"
          else
            CATEGORY="$INPUT"
          fi
          echo "category=$CATEGORY" >> "$GITHUB_OUTPUT"

      - name: Build prompt templates
        run: pnpm --filter @more/prompts exec tsx scripts/render-templates.ts

      - name: Scout for improvement
        id: scout
        uses: ./packages/claude/actions/claude
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          CLAUDE_CODE_PATH: /home/runner/.local/bin/claude
        with:
          prompt_file: packages/prompts/prompts/live-issue-scout.txt
          prompt_vars: >-
            {"CATEGORY":"${{ steps.category.outputs.category }}"}
          allowed_tools: "Read,Glob,Grep"
          output_schema: >-
            {"type":"object","properties":{"title":{"type":"string"},"body":{"type":"string"}},"required":["title","body"]}

      - name: Parse scout output
        id: parse
        run: |
          set -e

          if [ "${{ steps.scout.outputs.success }}" != "true" ]; then
            echo "::error::Scout failed: ${{ steps.scout.outputs.error }}"
            exit 1
          fi

          STRUCTURED='${{ steps.scout.outputs.structured_output }}'
          if [ -z "$STRUCTURED" ]; then
            echo "::error::No structured output from scout"
            exit 1
          fi

          TITLE=$(echo "$STRUCTURED" | jq -r '.title')
          BODY=$(echo "$STRUCTURED" | jq -r '.body')

          if [ -z "$TITLE" ] || [ "$TITLE" = "null" ]; then
            echo "::error::Scout returned empty title"
            exit 1
          fi

          echo "title=$TITLE" >> "$GITHUB_OUTPUT"

          # Use a delimiter for multi-line body
          {
            echo "body<<SCOUT_EOF"
            echo "$BODY"
            echo "SCOUT_EOF"
          } >> "$GITHUB_OUTPUT"

          echo "### Scout Result" >> "$GITHUB_STEP_SUMMARY"
          echo "**Category:** ${{ steps.category.outputs.category }}" >> "$GITHUB_STEP_SUMMARY"
          echo "**Title:** $TITLE" >> "$GITHUB_STEP_SUMMARY"
          echo "**Body:** $BODY" >> "$GITHUB_STEP_SUMMARY"

      - name: Create issue
        id: create-issue
        run: |
          set -e
          ISSUE_URL=$(gh issue create \
            --title "${{ steps.parse.outputs.title }}" \
            --body "${{ steps.parse.outputs.body }}")

          ISSUE_NUMBER=$(echo "$ISSUE_URL" | grep -o '[0-9]*$')
          echo "issue_number=$ISSUE_NUMBER" >> "$GITHUB_OUTPUT"
          echo "issue_url=$ISSUE_URL" >> "$GITHUB_OUTPUT"
          echo "Created issue #$ISSUE_NUMBER: $ISSUE_URL"
          echo "**Issue:** [#$ISSUE_NUMBER]($ISSUE_URL)" >> "$GITHUB_STEP_SUMMARY"

      - name: Wait for triage
        id: wait-triage
        uses: ./packages/statemachine/actions/sm-test-runner
        with:
          action: wait-triage
          issue_number: ${{ steps.create-issue.outputs.issue_number }}
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          timeout: '600'
          poll_interval: '15'

      - name: Verify triage
        run: |
          if [ "${{ steps.wait-triage.outputs.success }}" != "true" ]; then
            echo "::error::Triage failed or timed out"
            echo "Errors: ${{ steps.wait-triage.outputs.errors }}"
            exit 1
          fi
          echo "Triage complete"
          echo "Labels: ${{ steps.wait-triage.outputs.labels }}"
          echo "Project fields: ${{ steps.wait-triage.outputs.project_fields }}"
          echo "Sub-issues: ${{ steps.wait-triage.outputs.sub_issue_count }}"

      - name: Assign nopo-bot
        run: |
          set -e
          ISSUE="${{ steps.create-issue.outputs.issue_number }}"
          echo "Assigning nopo-bot to issue #$ISSUE"
          gh api "repos/${{ github.repository }}/issues/$ISSUE/assignees" \
            -X POST -f 'assignees[]=nopo-bot'

      - name: Wait for phase (with merge)
        if: inputs.skip_merge == false
        id: wait-phase-merge
        uses: ./packages/statemachine/actions/sm-test-runner
        with:
          action: wait-phase
          issue_number: ${{ steps.create-issue.outputs.issue_number }}
          phase_number: '1'
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          reviewer_token: ${{ secrets.CLAUDE_REVIEWER_PAT }}
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          timeout: '1800'
          poll_interval: '30'

      - name: Wait for phase (observe only)
        if: inputs.skip_merge != false
        id: wait-phase-observe
        run: |
          set -e
          ISSUE="${{ steps.create-issue.outputs.issue_number }}"
          REPO="${{ github.repository }}"
          OWNER="${{ github.repository_owner }}"
          REPO_NAME="${{ github.event.repository.name }}"
          TIMEOUT=1800
          INTERVAL=30
          ELAPSED=0
          ATTEMPT=0

          # Previous state for change detection
          PREV_ISSUE_STATUS=""
          PREV_PR_STATE="none"
          PREV_CI=""
          PREV_REVIEW=""
          PREV_MERGED="false"
          PREV_CLOSED="false"

          milestone() {
            local label="$1" prev="$2" curr="$3"
            if [ "$prev" != "$curr" ] && [ -n "$curr" ] && [ "$curr" != "none" ]; then
              echo "  >> $label: $prev -> $curr"
            fi
          }

          echo "Observing issue #$ISSUE (no merge, timeout: ${TIMEOUT}s, poll: ${INTERVAL}s)"

          while [ $ELAPSED -lt $TIMEOUT ]; do
            ATTEMPT=$((ATTEMPT + 1))

            # Fetch issue state + project status
            GQL=$(gh api graphql -f query='
              query($owner: String!, $repo: String!, $number: Int!) {
                repository(owner: $owner, name: $repo) {
                  issue(number: $number) {
                    state
                    projectItems(first: 1) {
                      nodes {
                        fieldValueByName(name: "Status") {
                          ... on ProjectV2ItemFieldSingleSelectValue { name }
                        }
                      }
                    }
                  }
                }
              }' \
              -f owner="$OWNER" -f repo="$REPO_NAME" -F number="$ISSUE" \
              --jq '{
                state: .data.repository.issue.state,
                status: (.data.repository.issue.projectItems.nodes[0].fieldValueByName.name // "none")
              }') || true

            ISSUE_STATE=$(echo "$GQL" | jq -r '.state // "OPEN"')
            ISSUE_STATUS=$(echo "$GQL" | jq -r '.status // "none"')
            IS_CLOSED="false"
            [ "$ISSUE_STATE" = "CLOSED" ] && IS_CLOSED="true"

            # Find PR linked to issue
            PR_INFO=$(gh pr list --repo "$REPO" --search "Fixes #$ISSUE OR Closes #$ISSUE OR Resolves #$ISSUE" \
              --json number,state,isDraft --jq '.[0] // empty' 2>/dev/null || true)

            PR_NUM=""
            PR_STATE="none"
            IS_MERGED="false"
            if [ -n "$PR_INFO" ]; then
              PR_NUM=$(echo "$PR_INFO" | jq -r '.number')
              IS_DRAFT=$(echo "$PR_INFO" | jq -r '.isDraft')
              PR_GH_STATE=$(echo "$PR_INFO" | jq -r '.state')
              if [ "$PR_GH_STATE" = "MERGED" ]; then
                PR_STATE="merged"
                IS_MERGED="true"
              elif [ "$IS_DRAFT" = "true" ]; then
                PR_STATE="draft"
              else
                PR_STATE="open"
              fi
            fi

            # CI + review only when PR exists
            CI_STATUS="none"
            REVIEW_STATUS="none"
            if [ -n "$PR_NUM" ]; then
              CI_STATUS=$(gh pr checks "$PR_NUM" --repo "$REPO" --json state --jq '
                if length == 0 then "none"
                elif all(.state == "SUCCESS" or .state == "SKIPPED" or .state == "NEUTRAL") then "success"
                elif any(.state == "FAILURE") then "failure"
                else "pending"
                end' 2>/dev/null || echo "pending")

              REVIEW_STATUS=$(gh api "repos/$REPO/pulls/$PR_NUM/reviews" \
                --jq 'if [.[] | select(.state == "APPROVED")] | length > 0 then "approved"
                      elif [.[] | select(.state == "CHANGES_REQUESTED")] | length > 0 then "changes_requested"
                      else "pending" end' 2>/dev/null || echo "pending")
            fi

            # Log milestone changes
            CHANGED=false
            if [ "$ISSUE_STATUS" != "$PREV_ISSUE_STATUS" ]; then
              milestone "status" "$PREV_ISSUE_STATUS" "$ISSUE_STATUS"
              CHANGED=true
            fi
            if [ "$PR_STATE" != "$PREV_PR_STATE" ]; then
              if [ "$PR_STATE" != "none" ]; then
                milestone "pr" "$PREV_PR_STATE" "$PR_STATE(#$PR_NUM)"
              fi
              CHANGED=true
            fi
            if [ "$CI_STATUS" != "$PREV_CI" ]; then
              milestone "ci" "$PREV_CI" "$CI_STATUS"
              CHANGED=true
            fi
            if [ "$REVIEW_STATUS" != "$PREV_REVIEW" ]; then
              milestone "review" "$PREV_REVIEW" "$REVIEW_STATUS"
              CHANGED=true
            fi
            if [ "$IS_MERGED" != "$PREV_MERGED" ] && [ "$IS_MERGED" = "true" ]; then
              echo "  >> merged"
              CHANGED=true
            fi
            if [ "$IS_CLOSED" != "$PREV_CLOSED" ] && [ "$IS_CLOSED" = "true" ]; then
              echo "  >> issue closed"
              CHANGED=true
            fi

            # Periodic heartbeat even when nothing changed
            if [ "$CHANGED" = "false" ] && [ $((ATTEMPT % 5)) -eq 0 ]; then
              echo "[${ATTEMPT}] ${ELAPSED}s | status:$ISSUE_STATUS pr:$PR_STATE ci:$CI_STATUS review:$REVIEW_STATUS"
            fi

            # Save state
            PREV_ISSUE_STATUS="$ISSUE_STATUS"
            PREV_PR_STATE="$PR_STATE"
            PREV_CI="$CI_STATUS"
            PREV_REVIEW="$REVIEW_STATUS"
            PREV_MERGED="$IS_MERGED"
            PREV_CLOSED="$IS_CLOSED"

            # Success: issue reached Done (automation merged it on its own)
            if [ "$ISSUE_STATUS" = "Done" ]; then
              echo "Issue #$ISSUE reached Done"
              echo "observe_result=done" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            # Success: CI passed + review approved (observe goal without merge)
            if [ "$REVIEW_STATUS" = "approved" ] && [ "$CI_STATUS" = "success" ]; then
              echo "Review approved + CI passed for issue #$ISSUE"
              echo "observe_result=review_approved" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            # Circuit breaker
            if [ "$ISSUE_STATUS" = "Blocked" ] || [ "$ISSUE_STATUS" = "Error" ]; then
              echo "::error::Issue #$ISSUE reached terminal status: $ISSUE_STATUS"
              echo "observe_result=circuit_broken" >> "$GITHUB_OUTPUT"
              exit 1
            fi

            sleep $INTERVAL
            ELAPSED=$((ELAPSED + INTERVAL))
          done

          echo "::error::Timeout observing issue #$ISSUE (${TIMEOUT}s)"
          echo "observe_result=timeout" >> "$GITHUB_OUTPUT"
          exit 1

      - name: Verify phase result
        if: inputs.skip_merge == false
        run: |
          if [ "${{ steps.wait-phase-merge.outputs.success }}" != "true" ]; then
            echo "::error::Phase failed"
            echo "Errors: ${{ steps.wait-phase-merge.outputs.errors }}"
            exit 1
          fi
          echo "Phase complete - PR merged and issue closed"

      - name: Save result
        id: result
        if: always()
        run: |
          mkdir -p results
          RESULT=$(jq -n \
            --arg category "${{ steps.category.outputs.category }}" \
            --arg issue_number "${{ steps.create-issue.outputs.issue_number || '' }}" \
            --arg skip_merge "${{ inputs.skip_merge }}" \
            --arg scout_success "${{ steps.scout.outputs.success || 'false' }}" \
            --arg triage_success "${{ steps.wait-triage.outputs.success || 'false' }}" \
            --arg phase_result "${{ steps.wait-phase-merge.outputs.success || steps.wait-phase-observe.outputs.observe_result || 'not_reached' }}" \
            --arg job_status "${{ job.status }}" \
            '{
              category: $category,
              issue_number: $issue_number,
              skip_merge: ($skip_merge == "true"),
              stages: {
                scout: ($scout_success == "true"),
                triage: ($triage_success == "true"),
                phase: $phase_result
              },
              job_status: $job_status
            }')
          echo "$RESULT" > results/live-e2e.json
          echo "json=$RESULT" >> "$GITHUB_OUTPUT"

          echo "### Live E2E Result" >> "$GITHUB_STEP_SUMMARY"
          echo '```json' >> "$GITHUB_STEP_SUMMARY"
          echo "$RESULT" | jq . >> "$GITHUB_STEP_SUMMARY"
          echo '```' >> "$GITHUB_STEP_SUMMARY"

      - name: Upload result
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: live-e2e-result
          path: results/
          retention-days: 7

  cleanup:
    runs-on: ubuntu-latest
    needs: live-test
    if: failure() && needs.live-test.outputs.issue_number != ''
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup-node
      - uses: ./.github/actions/setup-nopo
      - run: nopo build --tags github-actions

      - name: Cleanup test resources
        uses: ./packages/statemachine/actions/sm-test-helper
        with:
          action: cleanup
          issue_number: ${{ needs.live-test.outputs.issue_number }}
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          cleanup_mode: close
