name: Claude
run-name: >-
  ${{
    github.event_name == 'workflow_dispatch' && format('Claude - {0} #{1}', inputs.job, inputs.resource_number) ||
    github.event_name == 'issues' && format('Claude - issue #{0}', github.event.issue.number) ||
    github.event_name == 'issue_comment' && format('Claude - comment on #{0}', github.event.issue.number) ||
    github.event_name == 'pull_request_review_comment' && format('Claude - review comment on PR #{0}', github.event.pull_request.number) ||
    github.event_name == 'push' && format('Claude - push to {0}', github.ref_name) ||
    github.event_name == 'workflow_run' && format('Claude - CI {0} for PR', github.event.workflow_run.conclusion) ||
    github.event_name == 'pull_request' && format('Claude - PR #{0}', github.event.pull_request.number) ||
    github.event_name == 'pull_request_review' && format('Claude - review on PR #{0}', github.event.pull_request.number) ||
    github.event_name == 'discussion' && format('Claude - discussion #{0}', github.event.discussion.number) ||
    github.event_name == 'discussion_comment' && format('Claude - discussion #{0}', github.event.discussion.number) ||
    'Claude'
  }}
# Issue-edit-based iteration loop:
# - `assigned` starts iteration
# - `edited` continues iteration (triggered by state updates from CI or Claude)
# - Loop ends when Claude determines work is complete and doesn't edit
#
# CI results flow through claude-ci-state.yml which updates issue state,
# triggering an `edited` event that continues the iteration.

'on':
  issues:
    types:
      - opened
      - edited
      - assigned
      - unlabeled
  issue_comment:
    types:
      - created
  pull_request_review_comment:
    types:
      - created
  push:
    branches-ignore:
      - main
      - 'gh-readonly-queue/**'
      - 'test/**'  # Test automation branches
  # Note: workflow_run for CI is handled by claude-ci-state.yml
  # which updates issue state, triggering `issues: edited`
  pull_request:
    types:
      - review_requested
  pull_request_review:
    types:
      - submitted
  discussion:
    types:
      - created
  discussion_comment:
    types:
      - created
  workflow_dispatch:
    inputs:
      job:
        description: Job to run
        required: true
        type: choice
        options:
          - issue-triage
          - issue-iterate
          - issue-orchestrate
          - issue-comment
          - pr-review
          - pr-response
          - pr-human-response
          - discussion-research
          - discussion-respond
          - discussion-summarize
          - discussion-plan
      resource_number:
        description: Issue/PR/Discussion number
        required: true
        type: string
      context_json:
        description: Context JSON for the job
        required: false
        type: string
        default: '{}'
      mock_mode:
        description: Mock mode for testing
        type: string
        default: 'false'
permissions:
  contents: write
  pull-requests: write
  issues: write
  discussions: write
  actions: write
  id-token: write
defaults:
  run:
    shell: bash
# ============================================================================
# CONCURRENCY STRATEGY
# ============================================================================
# Per-resource concurrency is applied at the job level (run-job, special jobs)
# because resource_number isn't known until after detect runs.
#
# Groups:
# - claude-work-claude/issue/{number}: SHARED with CI workflow for iterate AND triage
#   Ensures CI, iterate, and triage never run simultaneously (queue mode for iterate)
#   Triage uses cancel-in-progress to restart on issue edits
# - claude-resource-{type}-{number}: Other Claude jobs per resource (queue)
# - claude-review-{number}: Push cancels in-flight reviews (cancel)
#
# This allows:
# - Multiple issues to be processed in parallel
# - Serial processing within each issue/PR (prevents conflicts)
# - CI, triage, and iterate to run sequentially (no race conditions)
# - Smart cancellation for events that obsolete previous work
# ============================================================================

jobs:
  # ============================================================================
  # STEP 1: DETECT EVENT
  # ============================================================================
  detect:
    runs-on: ubuntu-latest
    outputs:
      job: ${{ steps.detect.outputs.job || inputs.job }}
      resource_type: ${{ steps.detect.outputs.resource_type || steps.derive.outputs.resource_type }}
      resource_number: ${{ steps.detect.outputs.resource_number || inputs.resource_number }}
      comment_id: ${{ steps.detect.outputs.comment_id }}
      context_json: ${{ steps.detect.outputs.context_json || inputs.context_json }}
      skip: ${{ steps.detect.outputs.skip }}
      skip_reason: ${{ steps.detect.outputs.skip_reason }}
    steps:
      - id: checkout
        uses: actions/checkout@v4
      - id: detect
        if: github.event_name != 'workflow_dispatch'
        uses: ./.github/actions-ts/claude-detect-event
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
      - id: derive
        if: github.event_name == 'workflow_dispatch'
        env:
          JOB: ${{ inputs.job }}
        run: |
          # Derive resource_type from job name for workflow_dispatch
          case "$JOB" in
            issue-*) echo "resource_type=issue" >> $GITHUB_OUTPUT ;;
            ci-*|pr-*) echo "resource_type=pr" >> $GITHUB_OUTPUT ;;
            discussion-*) echo "resource_type=discussion" >> $GITHUB_OUTPUT ;;
            *) echo "resource_type=issue" >> $GITHUB_OUTPUT ;;
          esac

  # ============================================================================
  # STEP 2: SIGNAL START
  # ============================================================================
  signal-start:
    needs: detect
    if: |
      needs.detect.outputs.skip != 'true' &&
      needs.detect.outputs.job != '' &&
      needs.detect.outputs.job != 'push-to-draft' &&
      needs.detect.outputs.job != 'discussion-complete'
    runs-on: ubuntu-latest
    # Concurrency: queue signals per resource (don't cancel, just wait)
    concurrency:
      group: claude-signal-${{ needs.detect.outputs.resource_type }}-${{ needs.detect.outputs.resource_number }}
      cancel-in-progress: false
    outputs:
      status_comment_id: ${{ steps.signal.outputs.status_comment_id }}
    steps:
      - id: checkout
        uses: actions/checkout@v4
      # Read iteration state for issue-iterate jobs to show progress
      - id: read_state
        name: Read iteration state
        if: needs.detect.outputs.job == 'issue-iterate'
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          issue_number: ${{ fromJson(needs.detect.outputs.context_json).issue_number }}
          action: read
      - id: signal
        uses: ./.github/actions-ts/claude-signal-start
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          resource_type: ${{ needs.detect.outputs.resource_type }}
          resource_number: ${{ needs.detect.outputs.resource_number }}
          comment_id: ${{ needs.detect.outputs.comment_id }}
          job: ${{ needs.detect.outputs.job }}
          iteration: ${{ steps.read_state.outputs.iteration }}
          consecutive_failures: ${{ steps.read_state.outputs.consecutive_failures }}
          max_retries: ${{ vars.MAX_CLAUDE_RETRIES || '5' }}

  # ============================================================================
  # STEP 3: RUN CLAUDE JOB
  # ============================================================================
  run-job:
    needs:
      - detect
      - signal-start
    if: |
      needs.detect.outputs.skip != 'true' &&
      needs.detect.outputs.job != '' &&
      needs.detect.outputs.job != 'push-to-draft' &&
      needs.detect.outputs.job != 'discussion-complete'
    # Concurrency: one Claude job per resource at a time
    # - Issue iterate, triage, orchestrate: share group with CI workflow (sequential execution)
    # - PR jobs (pr-review, pr-response, pr-human-response): share group so push cancels them
    # - Other issue jobs (comment): separate group per issue
    # - Discussion jobs: separate group per discussion
    # cancel-in-progress behavior:
    # - Issue iterate/orchestrate: QUEUE (shares with CI, never cancel)
    # - Triage: cancel (edited issue should re-triage)
    # - Other jobs: queue (don't cancel work in progress)
    concurrency:
      group: >-
        ${{
          (needs.detect.outputs.job == 'issue-iterate' || needs.detect.outputs.job == 'issue-triage' || needs.detect.outputs.job == 'issue-orchestrate')
          && format('claude-work-claude/issue/{0}', needs.detect.outputs.resource_number)
          || needs.detect.outputs.resource_type == 'pr'
          && format('claude-review-{0}', needs.detect.outputs.resource_number)
          || format('claude-resource-{0}-{1}', needs.detect.outputs.resource_type, needs.detect.outputs.resource_number)
        }}
      cancel-in-progress: ${{ needs.detect.outputs.job == 'issue-triage' }}
    uses: ./.github/workflows/_claude.yml
    with:
      job: ${{ needs.detect.outputs.job }}
      context_json: ${{ needs.detect.outputs.context_json }}
      mock_mode: ${{ inputs.mock_mode || false }}
    secrets: inherit

  # ============================================================================
  # STEP 4: HANDLE RESULT
  # ============================================================================
  handle-result:
    needs:
      - detect
      - signal-start
      - run-job
    if: |
      always() &&
      needs.detect.outputs.skip != 'true' &&
      needs.detect.outputs.job != '' &&
      needs.detect.outputs.job != 'push-to-draft' &&
      needs.detect.outputs.job != 'discussion-complete'
    runs-on: ubuntu-latest
    # No concurrency here - serialization is handled by job dependency on run-job
    # If run-job is cancelled, this still runs (always()) to report the cancellation
    steps:
      - id: checkout
        uses: actions/checkout@v4
      - id: result
        uses: ./.github/actions-ts/claude-handle-result
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          resource_type: ${{ needs.detect.outputs.resource_type }}
          resource_number: ${{ needs.detect.outputs.resource_number }}
          status_comment_id: ${{ needs.signal-start.outputs.status_comment_id }}
          comment_id: ${{ needs.detect.outputs.comment_id }}
          job: ${{ needs.detect.outputs.job }}
          job_result: ${{ needs.run-job.result }}
          run_url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          context_json: ${{ needs.detect.outputs.context_json }}

      # Record workflow failure for issue-iterate jobs and check if we should retry
      - id: record_failure
        name: Record workflow failure
        if: |
          needs.run-job.result == 'failure' &&
          needs.detect.outputs.job == 'issue-iterate'
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          issue_number: ${{ fromJson(needs.detect.outputs.context_json).issue_number }}
          action: record_failure
          failure_type: workflow
          iteration_message: "Workflow failed"
          run_link: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

      - id: check_retry
        name: Check if should retry
        if: |
          needs.run-job.result == 'failure' &&
          needs.detect.outputs.job == 'issue-iterate'
        env:
          FAILURES: ${{ steps.record_failure.outputs.consecutive_failures }}
          MAX_FAILURES: ${{ vars.MAX_CLAUDE_RETRIES || '5' }}
        run: |
          if [[ "$FAILURES" -lt "$MAX_FAILURES" ]]; then
            echo "should_retry=true" >> $GITHUB_OUTPUT
            echo "Workflow failure $FAILURES/$MAX_FAILURES - will retry"
          else
            echo "should_retry=false" >> $GITHUB_OUTPUT
            echo "Max retries ($MAX_FAILURES) reached - not retrying"
          fi

      - id: retry
        name: Re-trigger workflow
        if: steps.check_retry.outputs.should_retry == 'true'
        env:
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
          JOB: ${{ needs.detect.outputs.job }}
          RESOURCE_NUMBER: ${{ needs.detect.outputs.resource_number }}
          CONTEXT_JSON: ${{ needs.detect.outputs.context_json }}
        run: |
          echo "Re-triggering workflow for retry..."
          gh workflow run claude.yml \
            --repo "$GITHUB_REPOSITORY" \
            -f job="$JOB" \
            -f resource_number="$RESOURCE_NUMBER" \
            -f context_json="$CONTEXT_JSON"
          echo "Workflow re-triggered successfully"

  # ============================================================================
  # SPECIAL JOBS (No Claude call needed)
  # ============================================================================

  # Push to draft - just converts PR to draft
  push-to-draft:
    needs: detect
    if: needs.detect.outputs.job == 'push-to-draft'
    runs-on: ubuntu-latest
    concurrency:
      group: claude-review-${{ needs.detect.outputs.resource_number }}
      cancel-in-progress: true
    steps:
      - id: context
        name: Parse context
        env:
          CONTEXT_JSON: ${{ needs.detect.outputs.context_json }}
        run: |
          echo "pr_number=$(echo "$CONTEXT_JSON" | jq -r '.pr_number')" >> $GITHUB_OUTPUT
          echo "is_draft=$(echo "$CONTEXT_JSON" | jq -r '.is_draft')" >> $GITHUB_OUTPUT
      - id: convert
        name: gh pr ready --undo
        if: steps.context.outputs.is_draft == 'false'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.context.outputs.pr_number }}
        run: gh pr ready "$PR_NUMBER" --undo --repo "$GITHUB_REPOSITORY"
      - id: remove_reviewer
        name: Remove nopo-bot reviewer
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.context.outputs.pr_number }}
        run: |
          # Remove nopo-bot as reviewer to prevent stale reviews
          # The reviewer will be re-added on CI success
          gh api \
            --method DELETE \
            "/repos/$GITHUB_REPOSITORY/pulls/$PR_NUMBER/requested_reviewers" \
            -f 'reviewers[]=nopo-bot' 2>/dev/null || true

  # Discussion complete - just marks discussion as complete
  discussion-complete:
    needs: detect
    if: needs.detect.outputs.job == 'discussion-complete'
    runs-on: ubuntu-latest
    # Concurrency: queue per discussion (don't cancel commands)
    concurrency:
      group: claude-resource-discussion-${{ needs.detect.outputs.resource_number }}
      cancel-in-progress: false
    steps:
      - id: context
        name: Parse context
        env:
          CONTEXT_JSON: ${{ needs.detect.outputs.context_json }}
        run: |
          echo "discussion_number=$(echo "$CONTEXT_JSON" | jq -r '.discussion_number')" >> $GITHUB_OUTPUT
      - id: get_discussion_id
        name: gh api graphql (get discussion ID)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DISCUSSION_NUMBER: ${{ steps.context.outputs.discussion_number }}
        run: |
          repo_name="${GITHUB_REPOSITORY#*/}"
          owner="${GITHUB_REPOSITORY%/*}"

          result=$(gh api graphql -f query='
            query($owner: String!, $repo: String!, $number: Int!) {
              repository(owner: $owner, name: $repo) {
                discussion(number: $number) { id }
              }
            }
          ' -f owner="$owner" -f repo="$repo_name" -F number="$DISCUSSION_NUMBER")

          echo "discussion_id=$(echo "$result" | jq -r '.data.repository.discussion.id')" >> $GITHUB_OUTPUT
      - id: add_reaction
        name: gh api graphql (add rocket reaction)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMENT_ID: ${{ needs.detect.outputs.comment_id }}
        run: |
          gh api graphql -f query='
            mutation($subjectId: ID!) {
              addReaction(input: {
                subjectId: $subjectId
                content: ROCKET
              }) {
                reaction { id }
              }
            }
          ' -f subjectId="$COMMENT_ID"
      - id: post_completion
        name: gh api graphql (post completion comment)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DISCUSSION_ID: ${{ steps.get_discussion_id.outputs.discussion_id }}
        run: |
          gh api graphql -f query='
            mutation($discussionId: ID!, $body: String!) {
              addDiscussionComment(input: {
                discussionId: $discussionId
                body: $body
              }) {
                comment { id }
              }
            }
          ' -f discussionId="$DISCUSSION_ID" -f body="âœ… **This discussion thread has been marked as complete.**

          If you have additional questions, feel free to post a new comment!"
