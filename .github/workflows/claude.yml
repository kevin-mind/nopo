name: Claude
run-name: >-
  ${{
    github.event_name == 'workflow_dispatch' && format('Claude - {0} #{1}', inputs.action, inputs.resource_number) ||
    github.event_name == 'issues' && format('Claude - issue #{0}', github.event.issue.number) ||
    github.event_name == 'issue_comment' && format('Claude - comment on #{0}', github.event.issue.number) ||
    github.event_name == 'pull_request_review_comment' && format('Claude - review comment on PR #{0}', github.event.pull_request.number) ||
    github.event_name == 'push' && format('Claude - push to {0}', github.ref_name) ||
    github.event_name == 'pull_request' && format('Claude - PR #{0}', github.event.pull_request.number) ||
    github.event_name == 'pull_request_review' && format('Claude - review on PR #{0}', github.event.pull_request.number) ||
    github.event_name == 'workflow_run' && format('Claude - CI {0} on {1}', github.event.workflow_run.conclusion, github.event.workflow_run.head_branch) ||
    github.event_name == 'discussion' && format('Claude - discussion #{0}', github.event.discussion.number) ||
    github.event_name == 'discussion_comment' && format('Claude - discussion #{0}', github.event.discussion.number) ||
    'Claude'
  }}

# Issue-edit-based iteration loop:
# - `assigned` starts iteration
# - `edited` continues iteration (triggered by state updates from CI or Claude)
# - Loop ends when Claude determines work is complete and doesn't edit
#
# CI completion (workflow_run) triggers iteration directly - state machine
# handles recording failures/clearing failures and updating history.
#
# Discussion automation:
# - `discussion:created` triggers research
# - `discussion_comment:created` triggers respond (or commands like /summarize, /plan)

'on':
  issues:
    types:
      - opened
      - edited
      - assigned
      - unlabeled
  issue_comment:
    types:
      - created
  pull_request_review_comment:
    types:
      - created
  push:
    branches-ignore:
      - main
      - 'gh-readonly-queue/**'
      - 'test/**'  # Test automation branches
  workflow_run:
    workflows:
      - CI
      - Release
    types:
      - completed
  pull_request:
    types:
      - review_requested
  pull_request_review:
    types:
      - submitted
  discussion:
    types:
      - created
  discussion_comment:
    types:
      - created
  workflow_dispatch:
    inputs:
      action:
        description: Action to run (auto detects from resource state)
        required: false
        type: choice
        default: auto
        options:
          - auto
          - triage
          - orchestrate
          - review
          - discussion-research
          - discussion-respond
          - discussion-summarize
          - discussion-plan
      resource_number:
        description: Issue, PR, or Discussion number
        required: true
        type: string
      context_json:
        description: Context JSON for discussion jobs
        required: false
        type: string
        default: '{}'

permissions:
  contents: write
  pull-requests: write
  issues: write
  discussions: write
  actions: write
  id-token: write

defaults:
  run:
    shell: bash

# ============================================================================
# CONCURRENCY STRATEGY
# ============================================================================
# WORKFLOW-LEVEL: One Claude workflow at a time per resource (issue/PR/discussion)
# This ensures NO concurrent Claude work on the same resource, period.
#
# Groups derived from event context:
# - Issues/comments: github.event.issue.number
# - PRs/reviews: github.event.pull_request.number
# - Push/workflow_run: branch name (maps to issue via claude/issue/{N} pattern)
# - Discussions: github.event.discussion.number
# - workflow_dispatch: inputs.resource_number
#
# cancel-in-progress: false (queue mode) - ensures all edits are processed
# ============================================================================
concurrency:
  group: >-
    claude-${{
      github.event_name == 'issues' && format('issue-{0}', github.event.issue.number) ||
      github.event_name == 'issue_comment' && format('issue-{0}', github.event.issue.number) ||
      github.event_name == 'pull_request' && format('pr-{0}', github.event.pull_request.number) ||
      github.event_name == 'pull_request_review' && format('pr-{0}', github.event.pull_request.number) ||
      github.event_name == 'pull_request_review_comment' && format('pr-{0}', github.event.pull_request.number) ||
      github.event_name == 'push' && format('branch-{0}', github.ref_name) ||
      github.event_name == 'workflow_run' && format('branch-{0}', github.event.workflow_run.head_branch) ||
      github.event_name == 'discussion' && format('discussion-{0}', github.event.discussion.number) ||
      github.event_name == 'discussion_comment' && format('discussion-{0}', github.event.discussion.number) ||
      github.event_name == 'workflow_dispatch' && format('{0}-{1}', inputs.action, inputs.resource_number) ||
      github.run_id
    }}
  cancel-in-progress: false

jobs:
  # ============================================================================
  # STEP 1: DETECT EVENT
  # ============================================================================
  detect:
    runs-on: ubuntu-latest
    outputs:
      job: ${{ steps.detect.outputs.job || steps.derive.outputs.job }}
      resource_type: ${{ steps.detect.outputs.resource_type || steps.derive.outputs.resource_type }}
      resource_number: ${{ steps.detect.outputs.resource_number || inputs.resource_number }}
      # For sub-issues, parent_issue is the parent issue number; for parent issues, it's "0"
      # Use this for concurrency to group all work for a parent + its sub-issues together
      parent_issue: ${{ steps.detect.outputs.parent_issue || steps.derive.outputs.parent_issue || '0' }}
      comment_id: ${{ steps.detect.outputs.comment_id }}
      context_json: ${{ steps.detect.outputs.context_json || steps.derive.outputs.context_json }}
      skip: ${{ steps.detect.outputs.skip }}
      skip_reason: ${{ steps.detect.outputs.skip_reason }}
    steps:
      - id: checkout
        uses: actions/checkout@v4
      - id: detect
        if: github.event_name != 'workflow_dispatch'
        uses: ./.github/actions-ts/claude-detect-event
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
      - id: derive
        if: github.event_name == 'workflow_dispatch'
        env:
          ACTION: ${{ inputs.action }}
          RESOURCE_NUMBER: ${{ inputs.resource_number }}
          CONTEXT_JSON: ${{ inputs.context_json }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Map action input to job name
          # - auto: detect from resource state (not implemented here, state machine handles)
          # - triage/orchestrate/review: explicit job names
          # - discussion-*: discussion jobs
          case "$ACTION" in
            triage)
              echo "job=issue-triage" >> $GITHUB_OUTPUT
              echo "resource_type=issue" >> $GITHUB_OUTPUT
              ;;
            orchestrate)
              echo "job=issue-orchestrate" >> $GITHUB_OUTPUT
              echo "resource_type=issue" >> $GITHUB_OUTPUT
              ;;
            review)
              echo "job=pr-review" >> $GITHUB_OUTPUT
              echo "resource_type=pr" >> $GITHUB_OUTPUT

              # For review action, we need to extract the linked issue from the PR body
              echo "Fetching PR #$RESOURCE_NUMBER details..."
              pr_body=$(gh pr view "$RESOURCE_NUMBER" --json body --jq '.body')

              # Extract issue number from "Fixes #N" pattern
              linked_issue=$(echo "$pr_body" | grep -oE 'Fixes #[0-9]+' | head -1 | grep -oE '[0-9]+' || echo "")

              if [[ -z "$linked_issue" ]]; then
                echo "::error::Could not find linked issue (Fixes #N) in PR body"
                exit 1
              fi

              echo "Found linked issue #$linked_issue"

              # Check if linked issue is a sub-issue by looking for "Parent: #N" in its body
              linked_issue_body=$(gh issue view "$linked_issue" --json body --jq '.body')
              parent_from_sub=$(echo "$linked_issue_body" | grep -oE 'Parent: #[0-9]+' | head -1 | grep -oE '[0-9]+' || echo "")

              if [[ -n "$parent_from_sub" ]]; then
                echo "Linked issue #$linked_issue is a sub-issue of parent #$parent_from_sub"
                parent_issue="$parent_from_sub"
              else
                echo "Linked issue #$linked_issue is a parent issue"
                parent_issue="$linked_issue"
              fi

              echo "parent_issue=$parent_issue" >> $GITHUB_OUTPUT

              # Build context with the PARENT issue number (not sub-issue or PR number)
              # The state machine needs the parent to understand the phase structure
              # Use heredoc for multiline output to preserve JSON integrity
              {
                echo "context_json<<EOF"
                gh issue view "$parent_issue" --json title,body | jq -c \
                  --arg num "$parent_issue" \
                  --arg pr_num "$RESOURCE_NUMBER" \
                  '{issue_number: $num, pr_number: $pr_num, issue_title: .title, issue_body: .body}'
                echo "EOF"
              } >> $GITHUB_OUTPUT
              exit 0
              ;;
            discussion-research|discussion-respond|discussion-summarize|discussion-plan)
              echo "job=$ACTION" >> $GITHUB_OUTPUT
              echo "resource_type=discussion" >> $GITHUB_OUTPUT
              echo "context_json=$CONTEXT_JSON" >> $GITHUB_OUTPUT
              exit 0
              ;;
            auto|*)
              # For 'auto', default to issue-iterate and let state machine figure it out
              echo "job=issue-iterate" >> $GITHUB_OUTPUT
              echo "resource_type=issue" >> $GITHUB_OUTPUT
              ;;
          esac

          # Fetch issue/PR details for context
          echo "Fetching details for #$RESOURCE_NUMBER..."
          new_context=$(gh issue view "$RESOURCE_NUMBER" --json title,body | jq -c \
            --arg num "$RESOURCE_NUMBER" \
            '{issue_number: $num, issue_title: .title, issue_body: .body}')
          echo "context_json=$new_context" >> $GITHUB_OUTPUT

  # ============================================================================
  # STEP 2: RUN STATE MACHINE
  # ============================================================================
  # All issue and PR jobs are handled by the state machine
  # Status signaling (start/end comments) is now handled inside the runner
  # Discussion jobs are handled separately (they use prompts, not state machine)
  run-state-machine:
    needs: detect
    if: |
      needs.detect.outputs.skip != 'true' &&
      needs.detect.outputs.job != '' &&
      needs.detect.outputs.job != 'push-to-draft' &&
      needs.detect.outputs.resource_type != 'discussion'
    # Concurrency:
    # - Issue jobs: one Claude job per parent issue at a time (includes all sub-issues)
    # - PR jobs: share group so push cancels in-flight reviews
    # - CI follow-up (workflow_run): separate group to not compete with issue edits
    # Job-level concurrency uses "claude-job-" prefix to avoid deadlock with workflow-level "claude-" groups
    concurrency:
      group: >-
        ${{
          (needs.detect.outputs.job == 'pr-review' || needs.detect.outputs.job == 'pr-response' || needs.detect.outputs.job == 'pr-human-response')
          && format('claude-job-review-{0}', needs.detect.outputs.resource_number)
          || github.event_name == 'workflow_run'
          && format('claude-job-ci-{0}', github.event.workflow_run.head_branch)
          || format('claude-job-issue-{0}', needs.detect.outputs.parent_issue != '0' && needs.detect.outputs.parent_issue || needs.detect.outputs.resource_number)
        }}
      cancel-in-progress: false
    uses: ./.github/workflows/claude-runner.yml
    with:
      # Trigger type mapping:
      # - issue-triage -> 'issue_triage'
      # - issue-comment -> 'issue_comment'
      # - issue-orchestrate -> 'issue_orchestrate'
      # - pr-review -> 'pr_review'
      # - pr-response -> 'pr_response'
      # - pr-human-response -> 'pr_human_response'
      # - Others: use context trigger_type or fallback to 'issue_assigned'
      trigger: >-
        ${{
          needs.detect.outputs.job == 'issue-triage' && 'issue_triage' ||
          needs.detect.outputs.job == 'issue-comment' && 'issue_comment' ||
          needs.detect.outputs.job == 'issue-orchestrate' && 'issue_orchestrate' ||
          needs.detect.outputs.job == 'pr-review' && 'pr_review' ||
          needs.detect.outputs.job == 'pr-response' && 'pr_response' ||
          needs.detect.outputs.job == 'pr-human-response' && 'pr_human_response' ||
          fromJson(needs.detect.outputs.context_json).trigger_type || 'issue_assigned'
        }}
      issue_number: ${{ fromJson(needs.detect.outputs.context_json).issue_number }}
      # For history entries - always use parent issue (or self if no parent)
      parent_issue_number: ${{ needs.detect.outputs.parent_issue != '0' && needs.detect.outputs.parent_issue || fromJson(needs.detect.outputs.context_json).issue_number }}
      ci_result: ${{ fromJson(needs.detect.outputs.context_json).ci_result || '' }}
      ci_run_url: ${{ fromJson(needs.detect.outputs.context_json).ci_run_url || '' }}
      ci_commit_sha: ${{ fromJson(needs.detect.outputs.context_json).ci_commit_sha || '' }}
      review_decision: ${{ fromJson(needs.detect.outputs.context_json).review_decision || '' }}
      reviewer: ${{ fromJson(needs.detect.outputs.context_json).reviewer || '' }}
      # Comment context fields - only set for issue-comment jobs
      comment_context_type: ${{ fromJson(needs.detect.outputs.context_json).context_type || '' }}
      comment_context_description: ${{ fromJson(needs.detect.outputs.context_json).context_description || '' }}
      branch: ${{ fromJson(needs.detect.outputs.context_json).branch_name || '' }}
      # Pass context for status signaling
      job: ${{ needs.detect.outputs.job }}
      resource_type: ${{ needs.detect.outputs.resource_type }}
      resource_number: ${{ needs.detect.outputs.resource_number }}
      comment_id: ${{ needs.detect.outputs.comment_id }}
      dry_run: false
    secrets: inherit

  # NOTE: handle-failure job was removed as part of state machine consolidation
  # - CI failures are handled via workflow_run_completed trigger
  # - Workflow job failures should be investigated manually, not auto-retried
  # - Auto-retry of buggy action code creates infinite loops

  # ============================================================================
  # SPECIAL JOB: Push to Draft
  # ============================================================================
  # Converts a PR to draft when code is pushed (cancels in-flight reviews)
  # This has unique concurrency needs (cancel-in-progress: true) so it stays
  # as a separate job rather than going through the state machine.
  push-to-draft:
    needs: detect
    if: needs.detect.outputs.job == 'push-to-draft'
    runs-on: ubuntu-latest
    # Use "claude-job-" prefix to avoid deadlock with workflow-level concurrency
    concurrency:
      group: claude-job-review-${{ needs.detect.outputs.resource_number }}
      cancel-in-progress: true
    steps:
      - id: context
        name: Parse context
        env:
          CONTEXT_JSON: ${{ needs.detect.outputs.context_json }}
        run: |
          echo "pr_number=$(echo "$CONTEXT_JSON" | jq -r '.pr_number')" >> $GITHUB_OUTPUT
          echo "is_draft=$(echo "$CONTEXT_JSON" | jq -r '.is_draft')" >> $GITHUB_OUTPUT
      - id: convert
        name: gh pr ready --undo
        if: steps.context.outputs.is_draft == 'false'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.context.outputs.pr_number }}
        run: gh pr ready "$PR_NUMBER" --undo --repo "$GITHUB_REPOSITORY"
      - id: remove_reviewer
        name: Remove nopo-bot reviewer
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.context.outputs.pr_number }}
        run: |
          # Remove nopo-bot as reviewer to prevent stale reviews
          # The reviewer will be re-added on CI success
          gh api \
            --method DELETE \
            "/repos/$GITHUB_REPOSITORY/pulls/$PR_NUMBER/requested_reviewers" \
            -f 'reviewers[]=nopo-bot' 2>/dev/null || true

  # ============================================================================
  # DISCUSSION JOBS
  # ============================================================================
  # Discussion automation uses prompts (not state machine) because discussions
  # are knowledge discovery, not implementation workflows.

  # Signal start for discussion jobs
  discussion-signal-start:
    needs: detect
    if: |
      needs.detect.outputs.skip != 'true' &&
      needs.detect.outputs.resource_type == 'discussion' &&
      needs.detect.outputs.job != 'discussion-complete'
    runs-on: ubuntu-latest
    outputs:
      status_comment_id: ${{ steps.signal.outputs.status_comment_id }}
    steps:
      - id: get_discussion_id
        name: Get discussion ID
        env:
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
          DISCUSSION_NUMBER: ${{ needs.detect.outputs.resource_number }}
        run: |
          repo_name="${GITHUB_REPOSITORY#*/}"
          owner="${GITHUB_REPOSITORY%/*}"
          result=$(gh api graphql -f query='
            query($owner: String!, $repo: String!, $number: Int!) {
              repository(owner: $owner, name: $repo) {
                discussion(number: $number) { id }
              }
            }
          ' -f owner="$owner" -f repo="$repo_name" -F number="$DISCUSSION_NUMBER")
          echo "discussion_id=$(echo "$result" | jq -r '.data.repository.discussion.id')" >> $GITHUB_OUTPUT

      - id: add_eyes_reaction
        name: Add eyes reaction to trigger comment
        if: needs.detect.outputs.comment_id != ''
        env:
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
          COMMENT_ID: ${{ needs.detect.outputs.comment_id }}
        run: |
          gh api graphql -f query='
            mutation($subjectId: ID!) {
              addReaction(input: { subjectId: $subjectId, content: EYES }) {
                reaction { id }
              }
            }
          ' -f subjectId="$COMMENT_ID" || true

      - id: signal
        name: Create status comment
        env:
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
          DISCUSSION_ID: ${{ steps.get_discussion_id.outputs.discussion_id }}
          JOB: ${{ needs.detect.outputs.job }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          # Map job to description
          case "$JOB" in
            discussion-research) DESCRIPTION="researching this topic" ;;
            discussion-respond) DESCRIPTION="responding to your question" ;;
            discussion-summarize) DESCRIPTION="summarizing this discussion" ;;
            discussion-plan) DESCRIPTION="creating implementation plan" ;;
            *) DESCRIPTION="$JOB" ;;
          esac

          BODY="⏳ **nopo-bot** is ${DESCRIPTION}...

          [View workflow run](${RUN_URL})"

          result=$(gh api graphql -f query='
            mutation($discussionId: ID!, $body: String!) {
              addDiscussionComment(input: { discussionId: $discussionId, body: $body }) {
                comment { id }
              }
            }
          ' -f discussionId="$DISCUSSION_ID" -f body="$BODY")

          echo "status_comment_id=$(echo "$result" | jq -r '.data.addDiscussionComment.comment.id')" >> $GITHUB_OUTPUT

  # Transform context for discussion jobs
  discussion-context:
    needs: detect
    if: |
      needs.detect.outputs.skip != 'true' &&
      needs.detect.outputs.resource_type == 'discussion' &&
      needs.detect.outputs.job != 'discussion-complete'
    runs-on: ubuntu-latest
    outputs:
      prompt_replacements: ${{ steps.format.outputs.json }}
    steps:
      - id: format
        name: Transform to uppercase keys
        env:
          CONTEXT_JSON: ${{ needs.detect.outputs.context_json }}
        run: |
          # Transform all keys to uppercase for prompt replacements
          json=$(echo "$CONTEXT_JSON" | jq -c 'with_entries(.key |= ascii_upcase)')
          echo "json=$json" >> $GITHUB_OUTPUT

  # Discussion research job
  discussion-research:
    needs:
      - detect
      - discussion-signal-start
      - discussion-context
    if: needs.detect.outputs.job == 'discussion-research'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ github.token }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/discussion-research.txt
          prompt_replacements: ${{ needs.discussion-context.outputs.prompt_replacements }}
          max_turns: '30'
          show_full_output: 'true'
      - uses: actions/upload-artifact@v4
        with:
          name: claude-discussion-output
          path: |
            /tmp/research-thread-*.md
            /tmp/discussion-updated-body.md
          retention-days: 1
          if-no-files-found: ignore

  # Discussion respond job
  discussion-respond:
    needs:
      - detect
      - discussion-signal-start
      - discussion-context
    if: needs.detect.outputs.job == 'discussion-respond'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ github.token }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/discussion-respond.txt
          prompt_replacements: ${{ needs.discussion-context.outputs.prompt_replacements }}
          max_turns: '100'
          show_full_output: 'true'
      - uses: actions/upload-artifact@v4
        with:
          name: claude-discussion-output
          path: |
            /tmp/discussion-response.md
            /tmp/discussion-updated-body.md
          retention-days: 1
          if-no-files-found: ignore

  # Discussion summarize job
  discussion-summarize:
    needs:
      - detect
      - discussion-signal-start
      - discussion-context
    if: needs.detect.outputs.job == 'discussion-summarize'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ github.token }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/discussion-summarize.txt
          prompt_replacements: ${{ needs.discussion-context.outputs.prompt_replacements }}
          max_turns: '50'
          show_full_output: 'true'
      - uses: actions/upload-artifact@v4
        with:
          name: claude-discussion-output
          path: /tmp/discussion-summary.md
          retention-days: 1
          if-no-files-found: ignore

  # Discussion plan job
  discussion-plan:
    needs:
      - detect
      - discussion-signal-start
      - discussion-context
    if: needs.detect.outputs.job == 'discussion-plan'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ github.token }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/discussion-plan.txt
          prompt_replacements: ${{ needs.discussion-context.outputs.prompt_replacements }}
          max_turns: '100'
          show_full_output: 'true'
      - uses: actions/upload-artifact@v4
        with:
          name: claude-discussion-output
          path: /tmp/discussion-plan-summary.md
          retention-days: 1
          if-no-files-found: ignore

  # Handle result for discussion jobs
  discussion-handle-result:
    needs:
      - detect
      - discussion-signal-start
      - discussion-research
      - discussion-respond
      - discussion-summarize
      - discussion-plan
    if: |
      always() &&
      needs.detect.outputs.skip != 'true' &&
      needs.detect.outputs.resource_type == 'discussion' &&
      needs.detect.outputs.job != 'discussion-complete'
    runs-on: ubuntu-latest
    steps:
      - id: job_result
        name: Determine job result
        run: |
          JOB="${{ needs.detect.outputs.job }}"
          case "$JOB" in
            discussion-research) echo "result=${{ needs.discussion-research.result }}" >> $GITHUB_OUTPUT ;;
            discussion-respond) echo "result=${{ needs.discussion-respond.result }}" >> $GITHUB_OUTPUT ;;
            discussion-summarize) echo "result=${{ needs.discussion-summarize.result }}" >> $GITHUB_OUTPUT ;;
            discussion-plan) echo "result=${{ needs.discussion-plan.result }}" >> $GITHUB_OUTPUT ;;
            *) echo "result=skipped" >> $GITHUB_OUTPUT ;;
          esac

      - id: update_status
        name: Update status comment
        env:
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
          STATUS_COMMENT_ID: ${{ needs.discussion-signal-start.outputs.status_comment_id }}
          JOB: ${{ needs.detect.outputs.job }}
          JOB_RESULT: ${{ steps.job_result.outputs.result }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          # Map job to description
          case "$JOB" in
            discussion-research) DESCRIPTION="researching topic" ;;
            discussion-respond) DESCRIPTION="responding to question" ;;
            discussion-summarize) DESCRIPTION="summarizing discussion" ;;
            discussion-plan) DESCRIPTION="creating plan" ;;
            *) DESCRIPTION="$JOB" ;;
          esac

          # Determine emoji and status
          if [[ "$JOB_RESULT" == "success" ]]; then
            EMOJI="✅"
            STATUS="completed successfully"
            REACTION="ROCKET"
          else
            EMOJI="❌"
            STATUS="failed"
            REACTION="THUMBS_DOWN"
          fi

          BODY="${EMOJI} **nopo-bot** ${DESCRIPTION} ${STATUS}.

          [View workflow run](${RUN_URL})"

          # Update the status comment
          gh api graphql -f query='
            mutation($commentId: ID!, $body: String!) {
              updateDiscussionComment(input: { commentId: $commentId, body: $body }) {
                comment { id }
              }
            }
          ' -f commentId="$STATUS_COMMENT_ID" -f body="$BODY" || true

          # Add reaction to status comment
          gh api graphql -f query="
            mutation(\$subjectId: ID!) {
              addReaction(input: { subjectId: \$subjectId, content: $REACTION }) {
                reaction { id }
              }
            }
          " -f subjectId="$STATUS_COMMENT_ID" || true

      - id: add_reaction_to_trigger
        name: Add reaction to trigger comment
        if: needs.detect.outputs.comment_id != ''
        env:
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
          COMMENT_ID: ${{ needs.detect.outputs.comment_id }}
          JOB_RESULT: ${{ steps.job_result.outputs.result }}
        run: |
          if [[ "$JOB_RESULT" == "success" ]]; then
            REACTION="ROCKET"
          else
            REACTION="THUMBS_DOWN"
          fi

          gh api graphql -f query="
            mutation(\$subjectId: ID!) {
              addReaction(input: { subjectId: \$subjectId, content: $REACTION }) {
                reaction { id }
              }
            }
          " -f subjectId="$COMMENT_ID" || true

  # Discussion complete job (special - marks discussion as resolved)
  discussion-complete:
    needs: detect
    if: needs.detect.outputs.job == 'discussion-complete'
    runs-on: ubuntu-latest
    steps:
      - id: context
        name: Parse context
        env:
          CONTEXT_JSON: ${{ needs.detect.outputs.context_json }}
        run: |
          echo "discussion_number=$(echo "$CONTEXT_JSON" | jq -r '.discussion_number')" >> $GITHUB_OUTPUT
      - id: get_discussion_id
        name: gh api graphql (get discussion ID)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DISCUSSION_NUMBER: ${{ steps.context.outputs.discussion_number }}
        run: |
          repo_name="${GITHUB_REPOSITORY#*/}"
          owner="${GITHUB_REPOSITORY%/*}"

          result=$(gh api graphql -f query='
            query($owner: String!, $repo: String!, $number: Int!) {
              repository(owner: $owner, name: $repo) {
                discussion(number: $number) { id }
              }
            }
          ' -f owner="$owner" -f repo="$repo_name" -F number="$DISCUSSION_NUMBER")

          echo "discussion_id=$(echo "$result" | jq -r '.data.repository.discussion.id')" >> $GITHUB_OUTPUT
      - id: add_reaction
        name: gh api graphql (add rocket reaction)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMENT_ID: ${{ needs.detect.outputs.comment_id }}
        run: |
          gh api graphql -f query='
            mutation($subjectId: ID!) {
              addReaction(input: {
                subjectId: $subjectId
                content: ROCKET
              }) {
                reaction { id }
              }
            }
          ' -f subjectId="$COMMENT_ID"
      - id: post_completion
        name: gh api graphql (post completion comment)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DISCUSSION_ID: ${{ steps.get_discussion_id.outputs.discussion_id }}
        run: |
          gh api graphql -f query='
            mutation($discussionId: ID!, $body: String!) {
              addDiscussionComment(input: {
                discussionId: $discussionId
                body: $body
              }) {
                comment { id }
              }
            }
          ' -f discussionId="$DISCUSSION_ID" -f body="This discussion thread has been marked as complete.

          If you have additional questions, feel free to post a new comment!"
