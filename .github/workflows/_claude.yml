name: Claude Business Logic
'on':
  workflow_call:
    inputs:
      job:
        description: Job to run
        required: true
        type: string
      context_json:
        description: JSON blob with all context needed by the job
        required: true
        type: string
  workflow_dispatch:
    inputs:
      job:
        description: Job to run
        required: true
        type: choice
        options:
          - issue-triage
          - issue-iterate
          - issue-orchestrate
          - issue-comment
          - pr-review
          - pr-response
          - pr-human-response
          - discussion-research
          - discussion-respond
          - discussion-summarize
          - discussion-plan
      context_json:
        description: JSON blob with context (see plan for structure)
        required: true
        type: string
permissions:
  contents: write
  pull-requests: write
  issues: write
  id-token: write
defaults:
  run:
    shell: bash

jobs:
  # ============================================================================
  # CONTEXT - Transform input to prompt replacements format
  # ============================================================================
  context:
    runs-on: ubuntu-latest
    outputs:
      prompt_replacements: ${{ steps.format.outputs.json }}
      branch_name: ${{ steps.extract.outputs.branch_name }}
    steps:
      - id: extract
        name: Extract branch_name for checkout
        env:
          CONTEXT_JSON: ${{ inputs.context_json }}
        run: |
          # Use env var to avoid shell injection from special characters in issue body
          branch=$(echo "$CONTEXT_JSON" | jq -r '.branch_name // "main"')
          echo "branch_name=$branch" >> $GITHUB_OUTPUT

      - id: format
        name: Transform to uppercase keys
        env:
          CONTEXT_JSON: ${{ inputs.context_json }}
        run: |
          # Transform all keys to uppercase for prompt replacements
          # Use -c for compact single-line output (required for GITHUB_OUTPUT)
          # Use env var to avoid shell injection from special characters in issue body
          json=$(echo "$CONTEXT_JSON" | jq -c 'with_entries(.key |= ascii_upcase)')
          echo "json=$json" >> $GITHUB_OUTPUT

  # ============================================================================
  # ISSUE JOBS
  # ============================================================================
  issue-triage:
    needs: context
    if: inputs.job == 'issue-triage'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/triage.txt
          prompt_replacements: ${{ needs.context.outputs.prompt_replacements }}
          max_turns: '50'
      - name: Apply triage labels
        if: always()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
        run: |
          if [[ ! -f triage-output.json ]]; then
            echo "No triage-output.json found - skipping label application"
            exit 0
          fi

          echo "Applying labels from triage-output.json:"
          cat triage-output.json

          # Extract values from JSON
          type=$(jq -r '.type // empty' triage-output.json)
          priority=$(jq -r '.priority // empty' triage-output.json)
          topics=$(jq -r '.topics[]? // empty' triage-output.json)

          labels=""

          # Add type label
          if [[ -n "$type" && "$type" != "null" ]]; then
            labels="$type"
            echo "Adding type label: $type"
          fi

          # Add priority label (only if not null)
          if [[ -n "$priority" && "$priority" != "null" ]]; then
            labels="${labels:+$labels,}priority:$priority"
            echo "Adding priority label: priority:$priority"
          fi

          # Add topic labels
          for topic in $topics; do
            if [[ -n "$topic" ]]; then
              labels="${labels:+$labels,}topic:$topic"
              echo "Adding topic label: topic:$topic"
            fi
          done

          # Always add triaged label
          labels="${labels:+$labels,}triaged"
          echo "Adding triaged label"

          # Apply all labels at once
          if [[ -n "$labels" ]]; then
            echo "Applying labels: $labels"
            gh issue edit "$ISSUE_NUMBER" --add-label "$labels" || true
          fi
      - uses: actions/upload-artifact@v4
        with:
          name: claude-triage-output
          path: triage-output.json
          retention-days: 1
          if-no-files-found: ignore

  # Unified iteration job - handles both initial implementation and CI fix iterations
  issue-iterate:
    needs: context
    if: inputs.job == 'issue-iterate'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.context.outputs.branch_name }}
          fetch-depth: 0

      # Read current project state (Status, Iteration, Failures)
      - id: read_state
        name: Read project state
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).issue_number }}
          action: read
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}

      # Get current phase from sub-issues
      - id: get_phase
        name: Get current phase from sub-issues
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).issue_number }}
          action: get_current_phase
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          parent_issue: ${{ fromJson(inputs.context_json).parent_issue || fromJson(inputs.context_json).issue_number }}

      # ===== STEPWISE MODE: _test label detection =====
      # When _test label is present, output decision information without executing
      # This allows verification of state machine logic without side effects
      - id: stepwise_check
        name: Check for stepwise test mode
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
        run: |
          labels=$(gh issue view "$ISSUE_NUMBER" --repo "$GITHUB_REPOSITORY" --json labels -q '.labels[].name' 2>/dev/null || echo "")
          if echo "$labels" | grep -q "^_test$"; then
            echo "stepwise=true" >> $GITHUB_OUTPUT
            echo "::notice::STEPWISE MODE - _test label detected. Will output decision without executing."
          else
            echo "stepwise=false" >> $GITHUB_OUTPUT
          fi

      - name: Output stepwise decision
        if: steps.stepwise_check.outputs.stepwise == 'true'
        env:
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
          ISSUE_TITLE: ${{ fromJson(inputs.context_json).issue_title }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
          TRIGGER_TYPE: ${{ fromJson(inputs.context_json).trigger_type }}
          CI_RESULT: ${{ fromJson(inputs.context_json).ci_result }}
          PROJECT_STATUS: ${{ steps.read_state.outputs.status }}
          PROJECT_ITERATION: ${{ steps.read_state.outputs.iteration }}
          PROJECT_FAILURES: ${{ steps.read_state.outputs.failures }}
          HAS_STATE: ${{ steps.read_state.outputs.has_state }}
          CURRENT_PHASE: ${{ steps.get_phase.outputs.current_phase }}
          TOTAL_PHASES: ${{ steps.get_phase.outputs.total_phases }}
          CURRENT_PHASE_STATUS: ${{ steps.get_phase.outputs.current_phase_status }}
          ALL_PHASES_DONE: ${{ steps.get_phase.outputs.all_phases_done }}
        run: |
          # Determine what action would be taken
          action="iterate"
          reason=""

          # Check for terminal states
          if [[ "$PROJECT_STATUS" == "Done" || "$PROJECT_STATUS" == "Blocked" || "$PROJECT_STATUS" == "Error" ]]; then
            if [[ "$TRIGGER_TYPE" != "assigned" ]]; then
              action="skip"
              reason="Terminal state: $PROJECT_STATUS"
            else
              action="resume"
              reason="Re-assignment will clear failures and resume"
            fi
          elif [[ "$CURRENT_PHASE_STATUS" == "Review" && "$TRIGGER_TYPE" != "assigned" ]]; then
            action="skip"
            reason="In Review - waiting for review/merge"
          elif [[ "$CI_RESULT" == "success" && "$ALL_PHASES_DONE" == "true" ]]; then
            action="complete"
            reason="All phases done - would mark PR ready and request review"
          elif [[ "$CI_RESULT" == "failure" ]]; then
            action="fix_ci"
            reason="CI failed - would iterate to fix"
          fi

          # Build JSON decision object
          decision=$(jq -n \
            --arg action "$action" \
            --arg reason "$reason" \
            --arg issue_number "$ISSUE_NUMBER" \
            --arg issue_title "$ISSUE_TITLE" \
            --arg branch_name "$BRANCH_NAME" \
            --arg trigger_type "$TRIGGER_TYPE" \
            --arg ci_result "$CI_RESULT" \
            --arg project_status "$PROJECT_STATUS" \
            --arg project_iteration "$PROJECT_ITERATION" \
            --arg project_failures "$PROJECT_FAILURES" \
            --arg has_state "$HAS_STATE" \
            --arg current_phase "$CURRENT_PHASE" \
            --arg total_phases "$TOTAL_PHASES" \
            --arg current_phase_status "$CURRENT_PHASE_STATUS" \
            --arg all_phases_done "$ALL_PHASES_DONE" \
            '{
              decision: {
                action: $action,
                reason: $reason
              },
              context: {
                issue_number: $issue_number,
                issue_title: $issue_title,
                branch_name: $branch_name,
                trigger_type: $trigger_type,
                ci_result: $ci_result
              },
              project_state: {
                status: $project_status,
                iteration: $project_iteration,
                failures: $project_failures,
                has_state: $has_state
              },
              phase_state: {
                current_phase: $current_phase,
                total_phases: $total_phases,
                current_phase_status: $current_phase_status,
                all_phases_done: $all_phases_done
              }
            }')

          # Output to step summary
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # ðŸ§ª Stepwise Test Mode

          This issue has the \`_test\` label. The state machine decision is shown below **without execution**.

          ## Decision

          | Property | Value |
          |----------|-------|
          | **Action** | \`$action\` |
          | **Reason** | $reason |

          ## Context

          | Property | Value |
          |----------|-------|
          | **Issue** | #$ISSUE_NUMBER - $ISSUE_TITLE |
          | **Branch** | \`$BRANCH_NAME\` |
          | **Trigger** | $TRIGGER_TYPE |
          | **CI Result** | $CI_RESULT |

          ## Project State

          | Field | Value |
          |-------|-------|
          | **Status** | $PROJECT_STATUS |
          | **Iteration** | $PROJECT_ITERATION |
          | **Failures** | $PROJECT_FAILURES |
          | **Has State** | $HAS_STATE |

          ## Phase State

          | Field | Value |
          |-------|-------|
          | **Current Phase** | $CURRENT_PHASE of $TOTAL_PHASES |
          | **Phase Status** | $CURRENT_PHASE_STATUS |
          | **All Phases Done** | $ALL_PHASES_DONE |

          ## Full Decision JSON

          \`\`\`json
          $decision
          \`\`\`

          ---

          **To execute normally:** Remove the \`_test\` label and re-trigger the workflow.

          EOF

          echo "Stepwise mode - decision output complete. Exiting without execution."

      # ===== EARLY EXIT: Terminal state =====
      # If Project Status is Done, Blocked, or Error, exit immediately.
      # Exception: If trigger is 'assigned' (re-assignment), allow workflow to continue
      # so the clear_failures step can reset and resume work.
      # Also skip if in stepwise mode (already handled above)
      - id: early_exit_terminal
        name: Check for terminal state
        if: |
          steps.stepwise_check.outputs.stepwise != 'true' &&
          (steps.read_state.outputs.status == 'Done' ||
           steps.read_state.outputs.status == 'Blocked' ||
           steps.read_state.outputs.status == 'Error') &&
          fromJson(inputs.context_json).trigger_type != 'assigned'
        env:
          STATUS: ${{ steps.read_state.outputs.status }}
        run: |
          echo "::notice::Issue is in terminal state ($STATUS). Exiting without changes."
          echo "early_exit=true" >> $GITHUB_OUTPUT

      - name: Write terminal summary
        if: steps.early_exit_terminal.outputs.early_exit == 'true'
        env:
          STATUS: ${{ steps.read_state.outputs.status }}
          ITERATION: ${{ steps.read_state.outputs.iteration }}
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Terminal State: $STATUS

          Issue #$ISSUE_NUMBER is in terminal state ($STATUS) after $ITERATION iterations.

          No further action needed. To resume:
          - If Blocked: fix issues and re-assign nopo-bot
          - If Error: investigate logs and re-assign nopo-bot
          - If Done: work is complete

          ---
          EOF

      # ===== EARLY EXIT: Sub-issue in Review =====
      # If current sub-issue is in Review status, wait for review/merge
      # Also skip if in stepwise mode
      - id: early_exit_review
        name: Check if in review
        if: |
          steps.stepwise_check.outputs.stepwise != 'true' &&
          steps.early_exit_terminal.outputs.early_exit != 'true' &&
          steps.get_phase.outputs.current_phase_status == 'Review' &&
          fromJson(inputs.context_json).trigger_type != 'assigned'
        run: |
          echo "::notice::Current phase is in Review status. Waiting for review/merge."
          echo "early_exit=true" >> $GITHUB_OUTPUT

      - name: Write review summary
        if: steps.early_exit_review.outputs.early_exit == 'true'
        env:
          ITERATION: ${{ steps.read_state.outputs.iteration }}
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
          PHASE: ${{ steps.get_phase.outputs.current_phase }}
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # â³ In Review

          Issue #$ISSUE_NUMBER Phase $PHASE is in Review status.

          Waiting for review approval and merge before continuing to next phase.

          ---
          EOF

      # Initialize state if this is first iteration (issue not in project yet)
      - id: init_state
        name: Initialize project state
        if: |
          steps.stepwise_check.outputs.stepwise != 'true' &&
          steps.early_exit_terminal.outputs.early_exit != 'true' &&
          steps.early_exit_review.outputs.early_exit != 'true' &&
          steps.read_state.outputs.has_state != 'true'
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).issue_number }}
          action: update
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          status: Working
          iteration: '0'
          failures: '0'

      # Clear failures on re-assignment (human explicitly triggered restart)
      # This allows resuming work after circuit breaker
      - id: clear_failures
        name: Clear failures on re-assignment
        if: |
          steps.stepwise_check.outputs.stepwise != 'true' &&
          steps.early_exit_terminal.outputs.early_exit != 'true' &&
          steps.early_exit_review.outputs.early_exit != 'true' &&
          steps.read_state.outputs.has_state == 'true' &&
          fromJson(inputs.context_json).trigger_type == 'assigned'
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).issue_number }}
          action: clear_failures
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}

      # Update status to Working on re-assignment (recover from Blocked)
      - name: Set status to Working on re-assignment
        if: |
          steps.stepwise_check.outputs.stepwise != 'true' &&
          steps.early_exit_terminal.outputs.early_exit != 'true' &&
          steps.early_exit_review.outputs.early_exit != 'true' &&
          steps.read_state.outputs.has_state == 'true' &&
          fromJson(inputs.context_json).trigger_type == 'assigned' &&
          (steps.read_state.outputs.status == 'Blocked' || steps.read_state.outputs.status == 'Ready')
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).issue_number }}
          action: update
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          status: Working

      # Log re-assignment to parent iteration history
      - name: Log re-assignment
        if: |
          steps.stepwise_check.outputs.stepwise != 'true' &&
          steps.early_exit_terminal.outputs.early_exit != 'true' &&
          steps.early_exit_review.outputs.early_exit != 'true' &&
          fromJson(inputs.context_json).trigger_type == 'assigned'
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).parent_issue || fromJson(inputs.context_json).issue_number }}
          action: append_history
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          phase: ${{ steps.get_phase.outputs.current_phase || '1' }}
          message: "Reset by re-assignment - resuming iteration"
          run_link: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

      # Get effective state
      - id: state
        name: Determine effective state
        if: |
          steps.early_exit_terminal.outputs.early_exit != 'true' &&
          steps.early_exit_review.outputs.early_exit != 'true'
        env:
          READ_ITERATION: ${{ steps.read_state.outputs.iteration || '0' }}
          READ_FAILURES: ${{ steps.clear_failures.outputs.failures || steps.read_state.outputs.failures || '0' }}
          READ_STATUS: ${{ steps.read_state.outputs.status || 'Working' }}
          TRIGGER_TYPE: ${{ fromJson(inputs.context_json).trigger_type || 'assigned' }}
          # CI result from workflow trigger context (not stored)
          TRIGGER_CI_RESULT: ${{ fromJson(inputs.context_json).ci_result || '' }}
        run: |
          # CI result comes from trigger context (workflow_run trigger)
          echo "ci_result=$TRIGGER_CI_RESULT" >> $GITHUB_OUTPUT
          echo "iteration=$READ_ITERATION" >> $GITHUB_OUTPUT
          echo "consecutive_failures=$READ_FAILURES" >> $GITHUB_OUTPUT
          echo "status=$READ_STATUS" >> $GITHUB_OUTPUT

      # Record CI failure (increment Failures in Project field)
      - id: record_ci_failure
        name: Record CI failure
        if: |
          steps.stepwise_check.outputs.stepwise != 'true' &&
          steps.early_exit_terminal.outputs.early_exit != 'true' &&
          steps.early_exit_review.outputs.early_exit != 'true' &&
          steps.state.outputs.ci_result == 'failure'
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).parent_issue || fromJson(inputs.context_json).issue_number }}
          action: record_failure
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}

      # Re-read state after recording failure to get updated failures
      - id: state_after_failure
        name: Get updated failure count
        if: steps.record_ci_failure.outcome == 'success'
        run: |
          echo "consecutive_failures=${{ steps.record_ci_failure.outputs.failures }}" >> $GITHUB_OUTPUT

      # Exponential backoff with jitter for retries
      - name: Wait for backoff (retry delay)
        if: |
          steps.stepwise_check.outputs.stepwise != 'true' &&
          steps.early_exit_terminal.outputs.early_exit != 'true' &&
          steps.early_exit_review.outputs.early_exit != 'true' &&
          (steps.state.outputs.consecutive_failures != '0' || steps.record_ci_failure.outcome == 'success')
        env:
          # Use updated failure count if CI failure was just recorded
          FAILURES: ${{ steps.state_after_failure.outputs.consecutive_failures || steps.state.outputs.consecutive_failures }}
          BASE_DELAY: '60'  # 60 seconds base delay
        run: |
          # Calculate exponential backoff: base * 2^(failures - 1)
          # With Â±20% jitter to prevent thundering herd
          failures=${FAILURES:-0}
          if [[ "$failures" -gt 0 ]]; then
            exponent=$((failures - 1))
            delay=$((BASE_DELAY * (1 << exponent)))
            # Cap at 15 minutes
            if [[ "$delay" -gt 900 ]]; then
              delay=900
            fi
            # Add jitter: Â±20%
            jitter_range=$((delay / 5))
            jitter=$(( (RANDOM % (jitter_range * 2 + 1)) - jitter_range ))
            final_delay=$((delay + jitter))
            if [[ "$final_delay" -lt 10 ]]; then
              final_delay=10
            fi
            echo "Retry attempt $failures: waiting ${final_delay}s (base: ${delay}s, jitter: ${jitter}s)"
            sleep "$final_delay"
          fi

      # Check for breakpoints and phase completion
      # Phase info comes from get_phase step (derived from sub-issues)
      - id: breakpoint
        name: Check breakpoints
        if: |
          steps.stepwise_check.outputs.stepwise != 'true' &&
          steps.early_exit_terminal.outputs.early_exit != 'true' &&
          steps.early_exit_review.outputs.early_exit != 'true'
        env:
          ITERATION: ${{ steps.state.outputs.iteration }}
          CI_RESULT: ${{ steps.state.outputs.ci_result }}
          # Use updated failure count if CI failure was just recorded
          FAILURES: ${{ steps.state_after_failure.outputs.consecutive_failures || steps.state.outputs.consecutive_failures }}
          MAX_ITERATIONS: '100'
          # Use GitHub variable for max retries, default to 5
          MAX_FAILURES: ${{ vars.MAX_CLAUDE_RETRIES || '5' }}
          # Phase completion info (from get_phase step - derived from sub-issues)
          ALL_PHASES_DONE: ${{ steps.get_phase.outputs.all_phases_done || 'false' }}
          CURRENT_PHASE: ${{ steps.get_phase.outputs.current_phase || '1' }}
          TOTAL_PHASES: ${{ steps.get_phase.outputs.total_phases || '1' }}
        run: |
          should_stop="false"
          stop_reason=""
          is_phase_complete="false"
          is_breakpoint="false"

          # Check phase completion FIRST (success case) before circuit breakers
          # Phase is complete when CI passes and all todos in current phase are done
          # Note: current_phase_status from get_phase shows if phase is ready for review
          if [[ "$CI_RESULT" == "success" && "$ALL_PHASES_DONE" == "true" ]]; then
            # All phases complete
            is_phase_complete="true"
            should_stop="true"
            stop_reason="All phases complete (Phase $CURRENT_PHASE/$TOTAL_PHASES) - ready for final review"
          elif [[ "$ITERATION" -ge "$MAX_ITERATIONS" ]]; then
            should_stop="true"
            is_breakpoint="true"
            stop_reason="Max iterations ($MAX_ITERATIONS) reached"
          elif [[ "$FAILURES" -ge "$MAX_FAILURES" ]]; then
            should_stop="true"
            is_breakpoint="true"
            stop_reason="Circuit breaker: $FAILURES consecutive failures (max: $MAX_FAILURES)"
          fi

          echo "should_stop=$should_stop" >> $GITHUB_OUTPUT
          echo "stop_reason=$stop_reason" >> $GITHUB_OUTPUT
          echo "is_phase_complete=$is_phase_complete" >> $GITHUB_OUTPUT
          echo "is_breakpoint=$is_breakpoint" >> $GITHUB_OUTPUT

      # Log circuit breaker event to parent iteration history
      - name: Log circuit breaker event
        if: |
          steps.breakpoint.outputs.is_breakpoint == 'true'
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).parent_issue || fromJson(inputs.context_json).issue_number }}
          action: append_history
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          phase: ${{ steps.get_phase.outputs.current_phase || '1' }}
          message: "âš ï¸ ${{ steps.breakpoint.outputs.stop_reason }}"
          run_link: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

      # Set Project Status to Blocked on breakpoint
      - name: Set status to Blocked
        if: |
          steps.breakpoint.outputs.is_breakpoint == 'true'
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).parent_issue || fromJson(inputs.context_json).issue_number }}
          action: set_blocked
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          reason: ${{ steps.breakpoint.outputs.stop_reason }}

      # Unassign nopo-bot on breakpoint (circuit breaker or max iterations)
      # This ends the edit-based loop cleanly (no nopo-bot = no iteration on edit)
      # NOTE: We use unassign instead of add-label because add-label triggers 'edited'
      - name: Unassign nopo-bot on breakpoint
        if: |
          steps.breakpoint.outputs.is_breakpoint == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
          REASON: ${{ steps.breakpoint.outputs.stop_reason }}
        run: |
          # Unassign nopo-bot - this ends the loop cleanly
          gh issue edit "$ISSUE_NUMBER" --remove-assignee "nopo-bot" --repo "$GITHUB_REPOSITORY" || true

          # Post comment explaining the stop (comments don't trigger 'edited')
          gh issue comment "$ISSUE_NUMBER" --body "âš ï¸ **Iteration stopped**: $REASON

          To resume iteration:
          1. Review the issue and workflow logs
          2. Fix any blocking issues
          3. Re-assign \`nopo-bot\` to restart

          The failure counter will be reset on re-assignment." --repo "$GITHUB_REPOSITORY"

      # Write summary for breakpoint (circuit breaker, max iterations, etc)
      - name: Write breakpoint summary
        if: steps.breakpoint.outputs.is_breakpoint == 'true'
        env:
          ITERATION: ${{ steps.state.outputs.iteration || '0' }}
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
          ISSUE_TITLE: ${{ fromJson(inputs.context_json).issue_title }}
          FAILURES: ${{ steps.state_after_failure.outputs.consecutive_failures || steps.state.outputs.consecutive_failures || '0' }}
          STOP_REASON: ${{ steps.breakpoint.outputs.stop_reason }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # âš ï¸ Iteration Stopped

          | Property | Value |
          |----------|-------|
          | **Issue** | [#$ISSUE_NUMBER](${{ github.server_url }}/${{ github.repository }}/issues/$ISSUE_NUMBER) - $ISSUE_TITLE |
          | **Branch** | \`$BRANCH_NAME\` |
          | **Total Iterations** | $ITERATION |
          | **Consecutive Failures** | $FAILURES |

          ## Stop Reason

          $STOP_REASON

          ## How to Resume

          \`nopo-bot\` has been unassigned from the issue.

          1. Review the issue and workflow logs for errors
          2. Fix any blocking issues manually if needed
          3. **Re-assign \`nopo-bot\`** to restart iteration
             - This resets the failure count and resumes from the current iteration

          ---

          EOF

      # ===== CI SUCCESS HANDLING =====
      # When CI passes, mark PR ready and request review
      # Note: PR number comes from state (for edited trigger) or context_json (for workflow_run trigger)

      - id: get_pr_number
        name: Get PR number from state or context
        if: steps.breakpoint.outputs.is_phase_complete == 'true'
        env:
          STATE_PR: ${{ steps.read_state.outputs.pr_number }}
          CONTEXT_PR: ${{ fromJson(inputs.context_json).pr_number }}
        run: |
          # Use state PR number first, fall back to context
          pr="${STATE_PR:-$CONTEXT_PR}"
          if [[ -z "$pr" ]]; then
            echo "::error::No PR number found in state or context"
            exit 1
          fi
          echo "pr_number=$pr" >> $GITHUB_OUTPUT

      - id: check_comments
        name: Check unresolved review comments
        if: steps.breakpoint.outputs.is_phase_complete == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.get_pr_number.outputs.pr_number }}
        run: |
          repo_name="${GITHUB_REPOSITORY#*/}"
          owner="${GITHUB_REPOSITORY%/*}"

          result=$(gh api graphql -f query='
            query($owner: String!, $repo: String!, $pr: Int!) {
              repository(owner: $owner, name: $repo) {
                pullRequest(number: $pr) {
                  reviewThreads(first: 100) {
                    nodes { isResolved }
                  }
                }
              }
            }
          ' -F owner="$owner" -F repo="$repo_name" -F pr="$PR_NUMBER")

          unresolved=$(echo "$result" | jq '[.data.repository.pullRequest.reviewThreads.nodes[] | select(.isResolved == false)] | length')
          echo "unresolved_count=$unresolved" >> $GITHUB_OUTPUT
          echo "has_unresolved=$([[ "$unresolved" -gt 0 ]] && echo "true" || echo "false")" >> $GITHUB_OUTPUT

      - name: Notify blocked by unresolved comments
        if: steps.breakpoint.outputs.is_phase_complete == 'true' && steps.check_comments.outputs.has_unresolved == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.get_pr_number.outputs.pr_number }}
          COUNT: ${{ steps.check_comments.outputs.unresolved_count }}
        run: |
          gh pr comment "$PR_NUMBER" --body "â¸ï¸ **CI passed but not moving to Review**

          There are **$COUNT unresolved comment thread(s)** on this PR.

          Please resolve all comments before the PR can move to Review status." --repo "$GITHUB_REPOSITORY"

      - name: Update project status to In review
        if: |
          steps.breakpoint.outputs.is_phase_complete == 'true' &&
          steps.check_comments.outputs.has_unresolved != 'true'
        env:
          GH_TOKEN: ${{ secrets.PROJECT_TOKEN || secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
          TARGET_STATUS: In review
        run: |
          repo_name="${GITHUB_REPOSITORY#*/}"
          owner="${GITHUB_REPOSITORY%/*}"

          result=$(gh api graphql -f query='query($owner: String!, $repo: String!, $issue: Int!) {
            repository(owner: $owner, name: $repo) {
              issue(number: $issue) {
                projectItems(first: 10) {
                  nodes {
                    id
                    project {
                      id
                      field(name: "Status") {
                        ... on ProjectV2SingleSelectField {
                          id
                          options { id name }
                        }
                      }
                    }
                  }
                }
              }
            }
          }' -F owner="$owner" -F repo="$repo_name" -F issue="$ISSUE_NUMBER" 2>/dev/null || echo "{}")

          item=$(echo "$result" | jq -r '.data.repository.issue.projectItems.nodes[0] // empty')
          [[ -z "$item" ]] && exit 0

          item_id=$(echo "$item" | jq -r '.id')
          project_id=$(echo "$item" | jq -r '.project.id')
          field_id=$(echo "$item" | jq -r '.project.field.id')
          option_id=$(echo "$item" | jq -r --arg status "$TARGET_STATUS" '.project.field.options[] | select(.name == $status) | .id')

          [[ -z "$option_id" ]] && exit 0

          gh api graphql -f query='mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
            updateProjectV2ItemFieldValue(input: {
              projectId: $projectId, itemId: $itemId, fieldId: $fieldId,
              value: { singleSelectOptionId: $optionId }
            }) { projectV2Item { id } }
          }' -F projectId="$project_id" -F itemId="$item_id" -F fieldId="$field_id" -F optionId="$option_id"

      - name: Mark PR ready
        if: |
          steps.breakpoint.outputs.is_phase_complete == 'true' &&
          steps.check_comments.outputs.has_unresolved != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.get_pr_number.outputs.pr_number }}
        run: gh pr ready "$PR_NUMBER" --repo "$GITHUB_REPOSITORY"

      - name: Add review-ready label
        if: |
          steps.breakpoint.outputs.is_phase_complete == 'true' &&
          steps.check_comments.outputs.has_unresolved != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.get_pr_number.outputs.pr_number }}
        run: gh pr edit "$PR_NUMBER" --add-label "review-ready" --repo "$GITHUB_REPOSITORY" || true

      - name: Request review
        if: |
          steps.breakpoint.outputs.is_phase_complete == 'true' &&
          steps.check_comments.outputs.has_unresolved != 'true'
        env:
          # Use NOPO_BOT_PAT to trigger the review_requested event
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
          PR_NUMBER: ${{ steps.get_pr_number.outputs.pr_number }}
        run: gh pr edit "$PR_NUMBER" --add-reviewer "nopo-bot" --repo "$GITHUB_REPOSITORY"

      # Log phase complete event to parent iteration history (when not all phases are done)
      - name: Log phase complete
        if: |
          steps.breakpoint.outputs.is_phase_complete == 'true' &&
          steps.check_comments.outputs.has_unresolved != 'true' &&
          steps.get_phase.outputs.all_phases_done != 'true'
        env:
          CURRENT_PHASE: ${{ steps.get_phase.outputs.current_phase || '1' }}
          TOTAL_PHASES: ${{ steps.get_phase.outputs.total_phases || '1' }}
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).parent_issue || fromJson(inputs.context_json).issue_number }}
          action: append_history
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          phase: ${{ env.CURRENT_PHASE }}
          message: "âœ… Phase ${{ env.CURRENT_PHASE }}/${{ env.TOTAL_PHASES }} complete - ready for review"
          run_link: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

      # Log all phases complete event to parent iteration history
      - name: Log all phases complete
        if: |
          steps.breakpoint.outputs.is_phase_complete == 'true' &&
          steps.check_comments.outputs.has_unresolved != 'true' &&
          steps.get_phase.outputs.all_phases_done == 'true'
        env:
          TOTAL_PHASES: ${{ steps.get_phase.outputs.total_phases || '1' }}
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).parent_issue || fromJson(inputs.context_json).issue_number }}
          action: append_history
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          phase: ${{ env.TOTAL_PHASES }}
          message: "ðŸŽ‰ All ${{ env.TOTAL_PHASES }} phases complete - ready for final review"
          run_link: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

      # Only set parent to Done when ALL phases are done (not just current phase)
      - name: Set parent to Done
        if: |
          steps.breakpoint.outputs.is_phase_complete == 'true' &&
          steps.check_comments.outputs.has_unresolved != 'true' &&
          steps.get_phase.outputs.all_phases_done == 'true'
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).parent_issue || fromJson(inputs.context_json).issue_number }}
          action: update
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          status: Done

      # Write summary for phase completion
      - name: Write success summary
        if: steps.breakpoint.outputs.is_phase_complete == 'true' && steps.check_comments.outputs.has_unresolved != 'true'
        env:
          ITERATION: ${{ steps.state.outputs.iteration || '0' }}
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
          ISSUE_TITLE: ${{ fromJson(inputs.context_json).issue_title }}
          PR_NUMBER: ${{ steps.get_pr_number.outputs.pr_number }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
          CURRENT_PHASE: ${{ steps.get_phase.outputs.current_phase || '1' }}
          TOTAL_PHASES: ${{ steps.get_phase.outputs.total_phases || '1' }}
          ALL_PHASES_DONE: ${{ steps.get_phase.outputs.all_phases_done || 'false' }}
        run: |
          if [[ "$ALL_PHASES_DONE" == "true" ]]; then
            phase_status="All phases complete ($CURRENT_PHASE/$TOTAL_PHASES)"
            next_step="PR is ready for final review and merge."
          else
            phase_status="Phase $CURRENT_PHASE of $TOTAL_PHASES complete"
            next_step="After merge, iteration will resume with Phase $((CURRENT_PHASE + 1))."
          fi

          cat >> $GITHUB_STEP_SUMMARY << EOF
          # âœ… Phase Complete

          | Property | Value |
          |----------|-------|
          | **Issue** | [#$ISSUE_NUMBER](${{ github.server_url }}/${{ github.repository }}/issues/$ISSUE_NUMBER) - $ISSUE_TITLE |
          | **PR** | [#$PR_NUMBER](${{ github.server_url }}/${{ github.repository }}/pull/$PR_NUMBER) |
          | **Branch** | \`$BRANCH_NAME\` |
          | **Total Iterations** | $ITERATION |
          | **Phase Status** | $phase_status |

          ## Status

          $phase_status! PR is now ready for review.

          $next_step

          - âœ… PR converted to ready state
          - âœ… Review requested from \`nopo-bot\`
          - âœ… Label \`review-ready\` added

          ---

          EOF

      # Update project status to In Progress (first iteration only, parent issues only)
      # Sub-issues should stay as "Working", not "In Progress"
      - name: Update project status to In Progress
        if: |
          steps.breakpoint.outputs.should_stop != 'true' &&
          steps.state.outputs.iteration == '0' &&
          fromJson(inputs.context_json).parent_issue == '0'
        env:
          GH_TOKEN: ${{ secrets.PROJECT_TOKEN || secrets.GITHUB_TOKEN }}
          CONTEXT_JSON: ${{ inputs.context_json }}
        run: |
          ISSUE_NUMBER=$(echo "$CONTEXT_JSON" | jq -r '.issue_number // empty')
          [[ -z "$ISSUE_NUMBER" ]] && exit 0

          repo_name="${GITHUB_REPOSITORY#*/}"
          owner="${GITHUB_REPOSITORY%/*}"

          result=$(gh api graphql -f query='query($owner: String!, $repo: String!, $issue: Int!) {
            repository(owner: $owner, name: $repo) {
              issue(number: $issue) {
                projectItems(first: 10) {
                  nodes {
                    id
                    project {
                      id
                      field(name: "Status") {
                        ... on ProjectV2SingleSelectField {
                          id
                          options { id name }
                        }
                      }
                    }
                  }
                }
              }
            }
          }' -F owner="$owner" -F repo="$repo_name" -F issue="$ISSUE_NUMBER" 2>/dev/null || echo "{}")

          item=$(echo "$result" | jq -r '.data.repository.issue.projectItems.nodes[0] // empty')
          [[ -z "$item" ]] && exit 0

          item_id=$(echo "$item" | jq -r '.id')
          project_id=$(echo "$item" | jq -r '.project.id')
          field_id=$(echo "$item" | jq -r '.project.field.id')
          option_id=$(echo "$item" | jq -r '.project.field.options[] | select(.name == "In progress") | .id')

          [[ -z "$option_id" ]] && exit 0

          gh api graphql -f query='mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
            updateProjectV2ItemFieldValue(input: {
              projectId: $projectId, itemId: $itemId, fieldId: $fieldId,
              value: { singleSelectOptionId: $optionId }
            }) { projectV2Item { id } }
          }' -F projectId="$project_id" -F itemId="$item_id" -F fieldId="$field_id" -F optionId="$option_id"

      - name: git config
        if: steps.breakpoint.outputs.should_stop != 'true'
        run: |
          git config --global user.name "Claude Bot"
          git config --global user.email "claude-bot@anthropic.com"

      - id: rebase
        name: Rebase onto main
        if: steps.breakpoint.outputs.should_stop != 'true'
        env:
          NOPO_BOT_PAT: ${{ secrets.NOPO_BOT_PAT }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          git fetch origin main

          # Check if rebase is needed
          if git merge-base --is-ancestor origin/main HEAD; then
            echo "Branch is already up to date with main - skipping rebase"
            echo "rebase_performed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Store current HEAD to detect if rebase changed anything
          head_before=$(git rev-parse HEAD)

          if ! git rebase origin/main; then
            git rebase --abort
            echo "::error::Rebase failed due to conflicts. Please resolve conflicts manually before re-running."
            exit 1
          fi

          head_after=$(git rev-parse HEAD)

          # Only push if rebase actually changed something
          if [[ "$head_before" == "$head_after" ]]; then
            echo "Rebase did not change HEAD - skipping push"
            echo "rebase_performed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Clear the GITHUB_TOKEN credential and use PAT instead
          git config --unset-all http.https://github.com/.extraheader || true
          git config http.https://github.com/.extraheader "AUTHORIZATION: basic $(echo -n "x-access-token:$NOPO_BOT_PAT" | base64)"

          if [[ $(git rev-list origin/main..HEAD --count) -gt 0 ]]; then
            git push origin "$BRANCH_NAME" --force-with-lease
            echo "Rebased and pushed changes - exiting to let CI run"
            echo "rebase_performed=true" >> $GITHUB_OUTPUT
          else
            echo "No commits beyond main - skipping push"
            echo "rebase_performed=false" >> $GITHUB_OUTPUT
          fi

      # ===== EARLY EXIT: Rebase was performed =====
      # If we rebased, exit and let CI run on the rebased code.
      # The CI result will trigger the next iteration via the edit-based loop.
      - name: Write rebase summary
        if: steps.rebase.outputs.rebase_performed == 'true'
        env:
          ITERATION: ${{ steps.state.outputs.iteration || '0' }}
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # ðŸ”„ Rebased onto main

          | Property | Value |
          |----------|-------|
          | **Issue** | [#$ISSUE_NUMBER](${{ github.server_url }}/${{ github.repository }}/issues/$ISSUE_NUMBER) |
          | **Branch** | \`$BRANCH_NAME\` |
          | **Iteration** | $ITERATION |

          ## Status

          Branch was behind main and has been rebased. Exiting to let CI run on the rebased code.

          The next iteration will start automatically when CI completes.

          ---

          EOF

      # Increment iteration counter in Project field before running Claude
      - id: increment
        name: Increment iteration
        if: steps.breakpoint.outputs.should_stop != 'true' && steps.rebase.outputs.rebase_performed != 'true'
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).parent_issue || fromJson(inputs.context_json).issue_number }}
          action: increment
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}

      # Log work started to parent iteration history
      - name: Log work started
        if: steps.breakpoint.outputs.should_stop != 'true' && steps.rebase.outputs.rebase_performed != 'true'
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).parent_issue || fromJson(inputs.context_json).issue_number }}
          action: append_history
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          phase: ${{ steps.get_phase.outputs.current_phase || '1' }}
          message: "â³ Running..."
          run_link: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

      # Write job summary to display iteration prominently in CI UI
      - name: Write iteration summary
        if: steps.breakpoint.outputs.should_stop != 'true' && steps.rebase.outputs.rebase_performed != 'true'
        env:
          ITERATION: ${{ steps.increment.outputs.iteration || steps.state.outputs.iteration || '1' }}
          CURRENT_PHASE: ${{ steps.get_phase.outputs.current_phase || '1' }}
          TOTAL_PHASES: ${{ steps.get_phase.outputs.total_phases || '1' }}
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
          ISSUE_TITLE: ${{ fromJson(inputs.context_json).issue_title }}
          FAILURES: ${{ steps.state_after_failure.outputs.consecutive_failures || steps.state.outputs.consecutive_failures || '0' }}
          TRIGGER_TYPE: ${{ fromJson(inputs.context_json).trigger_type }}
          CI_RESULT: ${{ steps.state.outputs.ci_result }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          # Build emoji based on trigger
          if [[ "$TRIGGER_TYPE" == "assigned" ]]; then
            trigger_emoji="ðŸš€"
            trigger_text="Initial implementation"
          elif [[ "$CI_RESULT" == "failure" ]]; then
            trigger_emoji="ðŸ”§"
            trigger_text="CI fix attempt"
          elif [[ "$CI_RESULT" == "success" ]]; then
            trigger_emoji="âœ…"
            trigger_text="CI passed - continuing"
          else
            trigger_emoji="ðŸ”„"
            trigger_text="Iteration"
          fi

          cat >> $GITHUB_STEP_SUMMARY << EOF
          # $trigger_emoji Iteration $ITERATION (Phase $CURRENT_PHASE of $TOTAL_PHASES)

          | Property | Value |
          |----------|-------|
          | **Issue** | [#$ISSUE_NUMBER](${{ github.server_url }}/${{ github.repository }}/issues/$ISSUE_NUMBER) - $ISSUE_TITLE |
          | **Branch** | \`$BRANCH_NAME\` |
          | **Phase** | $CURRENT_PHASE of $TOTAL_PHASES |
          | **Trigger** | $trigger_text |
          | **Consecutive Failures** | $FAILURES |

          ---

          EOF

      # Build prompt replacements with iteration state
      - id: augment
        name: Build prompt replacements
        if: steps.breakpoint.outputs.should_stop != 'true' && steps.rebase.outputs.rebase_performed != 'true'
        env:
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
          BASE_REPLACEMENTS: ${{ needs.context.outputs.prompt_replacements }}
          ITERATION: ${{ steps.increment.outputs.iteration || steps.state.outputs.iteration }}
          CI_RESULT: ${{ steps.state.outputs.ci_result }}
          # Use updated failure count if CI failure was just recorded
          FAILURES: ${{ steps.state_after_failure.outputs.consecutive_failures || steps.state.outputs.consecutive_failures }}
          # Phase information (derived from sub-issues)
          CURRENT_PHASE: ${{ steps.get_phase.outputs.current_phase || '1' }}
          TOTAL_PHASES: ${{ steps.get_phase.outputs.total_phases || '1' }}
        run: |
          # Check for existing branch work
          diff=$(git diff main.."$BRANCH_NAME" --stat 2>/dev/null || echo "")
          if [[ -n "$diff" ]]; then
            section=$(cat <<'SECTION'
          ## Existing Branch - Previous work detected

          This branch already has changes from a previous implementation attempt:
          ```
          $diff
          ```

          **CRITICAL**: Review what is already done. Do NOT re-implement completed work.
          Start from the CURRENT state of the code and continue toward the goal.
          If an edit fails because the text is not found, the change may already be applied.
          SECTION
          )
            section="${section//\$diff/$diff}"
          else
            section=""
          fi

          # Add all iteration context to replacements (including phase info)
          json=$(echo "$BASE_REPLACEMENTS" | jq -c \
            --arg section "$section" \
            --arg iteration "$ITERATION" \
            --arg ci_result "$CI_RESULT" \
            --arg failures "$FAILURES" \
            --arg current_phase "$CURRENT_PHASE" \
            --arg total_phases "$TOTAL_PHASES" \
            '. + {
              EXISTING_BRANCH_SECTION: $section,
              ITERATION: $iteration,
              LAST_CI_RESULT: $ci_result,
              CONSECUTIVE_FAILURES: $failures,
              CURRENT_PHASE: $current_phase,
              TOTAL_PHASES: $total_phases
            }')
          echo "json=$json" >> $GITHUB_OUTPUT

      - uses: ./.github/actions/run-claude
        if: steps.breakpoint.outputs.should_stop != 'true' && steps.rebase.outputs.rebase_performed != 'true'
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/iterate.txt
          prompt_replacements: ${{ steps.augment.outputs.json }}
          max_turns: '200'
          show_full_output: 'true'
          assignee_trigger: nopo-bot

      # Detect PR after Claude runs (Claude may have created one)
      - id: detect_pr
        name: Detect PR for branch
        if: success() && steps.breakpoint.outputs.should_stop != 'true' && steps.rebase.outputs.rebase_performed != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
          EXISTING_PR: ${{ steps.read_state.outputs.pr_number }}
        run: |
          # If we already have a PR number in state, use it
          if [[ -n "$EXISTING_PR" ]]; then
            echo "Using existing PR number from state: $EXISTING_PR"
            echo "pr_number=$EXISTING_PR" >> $GITHUB_OUTPUT
            exit 0
          fi
          # Otherwise, check if Claude created a PR
          pr_number=$(gh pr list --head "$BRANCH_NAME" --state open --json number --jq '.[0].number // empty')
          if [[ -n "$pr_number" ]]; then
            echo "Found PR #$pr_number for branch $BRANCH_NAME"
            echo "pr_number=$pr_number" >> $GITHUB_OUTPUT
          else
            echo "No PR found for branch $BRANCH_NAME"
            echo "pr_number=" >> $GITHUB_OUTPUT
          fi

      # Get commit SHA for iteration log
      - id: get_sha
        name: Get commit SHA
        if: success() && steps.breakpoint.outputs.should_stop != 'true' && steps.rebase.outputs.rebase_performed != 'true'
        run: echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

      # Log successful push to parent iteration history
      - name: Log work complete
        if: success() && steps.breakpoint.outputs.should_stop != 'true' && steps.rebase.outputs.rebase_performed != 'true'
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).parent_issue || fromJson(inputs.context_json).issue_number }}
          action: append_history
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          phase: ${{ steps.get_phase.outputs.current_phase || '1' }}
          message: "âœ… Pushed changes"
          commit_sha: ${{ steps.get_sha.outputs.sha }}
          run_link: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

      - name: Re-push with PAT to trigger CI
        if: success() && steps.breakpoint.outputs.should_stop != 'true' && steps.rebase.outputs.rebase_performed != 'true'
        env:
          NOPO_BOT_PAT: ${{ secrets.NOPO_BOT_PAT }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          # Amend + push with PAT to trigger CI workflows
          # Clear the GITHUB_TOKEN credential and use PAT instead
          git config --unset-all http.https://github.com/.extraheader || true
          git config http.https://github.com/.extraheader "AUTHORIZATION: basic $(echo -n "x-access-token:$NOPO_BOT_PAT" | base64)"
          if [[ $(git rev-list origin/main..HEAD --count) -gt 0 ]]; then
            git commit --amend --no-edit
            git push origin "$BRANCH_NAME" --force-with-lease
          else
            echo "No commits beyond main - skipping push"
          fi

      - name: Save uncommitted work on failure
        if: failure() && steps.breakpoint.outputs.should_stop != 'true' && steps.rebase.outputs.rebase_performed != 'true'
        env:
          NOPO_BOT_PAT: ${{ secrets.NOPO_BOT_PAT }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          # Check for any uncommitted changes (staged or unstaged)
          if [[ -n "$(git status --porcelain)" ]]; then
            echo "Found uncommitted changes - saving work..."
            git add -A
            git commit -m "WIP: Save uncommitted work from failed run

            This commit preserves work that was not pushed before the job failed.
            Review and clean up before continuing.

            Workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            # Use PAT to push so it triggers CI workflows
            git config --unset-all http.https://github.com/.extraheader || true
            git config http.https://github.com/.extraheader "AUTHORIZATION: basic $(echo -n "x-access-token:$NOPO_BOT_PAT" | base64)"
            git push origin "$BRANCH_NAME"
            echo "::warning::Uncommitted work was saved to branch $BRANCH_NAME"
          else
            echo "No uncommitted changes to save"
          fi

  issue-comment:
    needs: context
    if: inputs.job == 'issue-comment'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.context.outputs.branch_name }}
          fetch-depth: 0
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/comment.txt
          prompt_replacements: ${{ needs.context.outputs.prompt_replacements }}
          max_turns: '100'
          trigger_phrase: '@claude'
      - name: Re-push with PAT to trigger CI
        if: success()
        env:
          NOPO_BOT_PAT: ${{ secrets.NOPO_BOT_PAT }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          # Amend + push with PAT to trigger CI workflows
          # Only if branch has commits beyond main (don't amend main's commits)
          # Clear the GITHUB_TOKEN credential and use PAT instead
          git config --unset-all http.https://github.com/.extraheader || true
          git config http.https://github.com/.extraheader "AUTHORIZATION: basic $(echo -n "x-access-token:$NOPO_BOT_PAT" | base64)"
          if [[ $(git rev-list origin/main..HEAD --count) -gt 0 ]]; then
            git commit --amend --no-edit
            git push origin "$BRANCH_NAME" --force-with-lease
          fi

  # Orchestrate sub-issues for main issues with phases
  issue-orchestrate:
    needs: context
    if: inputs.job == 'issue-orchestrate'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Read parent issue project state
      - id: read_state
        name: Read parent issue state
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).issue_number }}
          action: read
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}

      # Get current phase from sub-issues
      - id: get_phase
        name: Get current phase from sub-issues
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).issue_number }}
          action: get_current_phase
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          parent_issue: ${{ fromJson(inputs.context_json).issue_number }}

      # Check if already complete (all phases done or parent status is Done)
      - id: check_complete
        name: Check if orchestration complete
        if: |
                    (steps.read_state.outputs.status == 'Done' || steps.get_phase.outputs.all_phases_done == 'true')
        run: |
          echo "::notice::All sub-issues complete. Main issue orchestration done."
          echo "early_exit=true" >> $GITHUB_OUTPUT

      - name: Write complete summary
        if: steps.check_complete.outputs.early_exit == 'true'
        env:
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # All Phases Complete

          Issue #$ISSUE_NUMBER orchestration is complete. All sub-issues have been merged.

          ---
          EOF

      # Initialize parent state if not in project or if status is Backlog
      # (Backlog means not yet started, so we need to initialize)
      - id: init_state
        name: Initialize parent issue state
        if: |
          steps.check_complete.outputs.early_exit != 'true' &&
          (steps.read_state.outputs.has_state != 'true' || steps.read_state.outputs.status == 'Backlog')
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).issue_number }}
          action: init_parent
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          sub_issues: ${{ fromJson(inputs.context_json).sub_issues }}

      # Advance to next phase if current phase is Done
      # Only call advance_phase when current_phase_status == 'Done' (meaning
      # get_current_phase found a sub-issue that just completed)
      - id: advance
        name: Advance to next phase
        if: |
          steps.check_complete.outputs.early_exit != 'true' &&
          steps.get_phase.outputs.current_phase_status == 'Done'
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).issue_number }}
          action: advance_phase
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          completed_sub_issue: ${{ steps.get_phase.outputs.current_sub_issue }}

      # Assign nopo-bot to current or next sub-issue
      # If advance ran, assign to next_sub_issue; otherwise assign to current_sub_issue
      - name: Assign sub-issue
        if: |
          steps.check_complete.outputs.early_exit != 'true' &&
          (
            (steps.advance.outputs.next_sub_issue != '' && steps.advance.outputs.next_sub_issue != '0') ||
            (steps.get_phase.outputs.current_sub_issue != '' && steps.get_phase.outputs.current_sub_issue != '0')
          )
        env:
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
          # Use next_sub_issue if advance ran, otherwise use current_sub_issue
          NEXT_SUB_ISSUE: ${{ steps.advance.outputs.next_sub_issue }}
          CURRENT_SUB_ISSUE: ${{ steps.get_phase.outputs.current_sub_issue }}
        run: |
          # Prefer next_sub_issue (from advance), fall back to current_sub_issue
          if [[ -n "$NEXT_SUB_ISSUE" && "$NEXT_SUB_ISSUE" != "0" ]]; then
            SUB_ISSUE="$NEXT_SUB_ISSUE"
          else
            SUB_ISSUE="$CURRENT_SUB_ISSUE"
          fi
          echo "Assigning nopo-bot to sub-issue #$SUB_ISSUE"
          gh issue edit "$SUB_ISSUE" --add-assignee nopo-bot --repo "$GITHUB_REPOSITORY"

      # Log phase advancement to parent iteration history (only if advance ran)
      - name: Log phase advancement
        if: |
          steps.check_complete.outputs.early_exit != 'true' &&
          steps.get_phase.outputs.current_phase_status == 'Done' &&
          steps.advance.outputs.next_sub_issue != '' &&
          steps.advance.outputs.next_sub_issue != '0'
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).issue_number }}
          action: append_history
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          phase: ${{ steps.advance.outputs.next_phase }}
          message: "Phase ${{ steps.advance.outputs.next_phase }} started"
          run_link: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

      # Write summary
      - name: Write orchestration summary
        if: steps.check_complete.outputs.early_exit != 'true'
        env:
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
          ISSUE_TITLE: ${{ fromJson(inputs.context_json).issue_title }}
          NEXT_SUB_ISSUE: ${{ steps.advance.outputs.next_sub_issue }}
          CURRENT_SUB_ISSUE: ${{ steps.get_phase.outputs.current_sub_issue }}
          ITERATION: ${{ steps.read_state.outputs.iteration || '1' }}
        run: |
          # Prefer next_sub_issue (from advance), fall back to current_sub_issue
          if [[ -n "$NEXT_SUB_ISSUE" && "$NEXT_SUB_ISSUE" != "0" ]]; then
            status_msg="Advanced to sub-issue #$NEXT_SUB_ISSUE"
          elif [[ -n "$CURRENT_SUB_ISSUE" && "$CURRENT_SUB_ISSUE" != "0" ]]; then
            status_msg="Continuing with sub-issue #$CURRENT_SUB_ISSUE"
          else
            status_msg="No pending sub-issues to assign"
          fi

          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Orchestration Iteration $ITERATION

          | Property | Value |
          |----------|-------|
          | **Main Issue** | [#$ISSUE_NUMBER](${{ github.server_url }}/${{ github.repository }}/issues/$ISSUE_NUMBER) - $ISSUE_TITLE |
          | **Status** | $status_msg |

          ---
          EOF

  # ============================================================================
  # PR REVIEW JOBS
  # ============================================================================
  pr-review:
    needs: context
    if: inputs.job == 'pr-review'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.context.outputs.branch_name }}
          fetch-depth: 0
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/review.txt
          prompt_replacements: ${{ needs.context.outputs.prompt_replacements }}
          max_turns: '50'
      - name: Submit review with PAT
        if: always()
        env:
          # Use NOPO_BOT_PAT so review comes from a different account than PR author
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
          PR_NUMBER: ${{ fromJson(inputs.context_json).pr_number }}
        run: |
          if [[ ! -f review-output.json ]]; then
            echo "No review-output.json found - Claude may have submitted review directly or failed"
            exit 0
          fi

          echo "Review output:"
          cat review-output.json

          decision=$(jq -r '.decision // empty' review-output.json)
          body=$(jq -r '.body // empty' review-output.json)

          if [[ -z "$decision" ]]; then
            echo "::error::No decision found in review-output.json"
            exit 1
          fi

          case "$decision" in
            approve)
              echo "Submitting APPROVE review..."
              gh pr review "$PR_NUMBER" --approve --body "$body" --repo "$GITHUB_REPOSITORY"
              ;;
            request_changes)
              echo "Submitting REQUEST_CHANGES review..."
              gh pr review "$PR_NUMBER" --request-changes --body "$body" --repo "$GITHUB_REPOSITORY"
              ;;
            comment)
              echo "Submitting COMMENT review..."
              gh pr review "$PR_NUMBER" --comment --body "$body" --repo "$GITHUB_REPOSITORY"
              ;;
            *)
              echo "::error::Invalid decision: $decision (expected: approve, request_changes, comment)"
              exit 1
              ;;
          esac

          echo "Review submitted successfully"
          echo "decision=$decision" >> "$GITHUB_OUTPUT"
        id: submit_review

      # Log review event to parent iteration history
      - name: Log review submitted
        if: always() && steps.submit_review.outputs.decision != ''
        uses: ./.github/actions-ts/claude-parse-state
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          issue_number: ${{ fromJson(inputs.context_json).parent_issue || fromJson(inputs.context_json).issue_number }}
          action: append_history
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          phase: ${{ fromJson(inputs.context_json).phase_number || '1' }}
          message: "ðŸ“ Review: ${{ steps.submit_review.outputs.decision }}"
          run_link: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

      - uses: actions/upload-artifact@v4
        with:
          name: claude-review-output
          path: review-output.json
          retention-days: 1
          if-no-files-found: ignore

  pr-response:
    needs: context
    if: inputs.job == 'pr-response'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.context.outputs.branch_name }}
          fetch-depth: 0
      - name: git config
        run: |
          git config --global user.name "Claude Bot"
          git config --global user.email "claude-bot@anthropic.com"
      - id: augment
        name: Add REPOSITORY and HEAD_REF
        env:
          BASE_REPLACEMENTS: ${{ needs.context.outputs.prompt_replacements }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          json=$(echo "$BASE_REPLACEMENTS" | jq -c \
            --arg repo "${{ github.repository }}" \
            --arg branch "$BRANCH_NAME" \
            '. + {REPOSITORY: $repo, HEAD_REF: $branch}')
          echo "json=$json" >> $GITHUB_OUTPUT
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/review-response.txt
          prompt_replacements: ${{ steps.augment.outputs.json }}
          max_turns: '50'
      - name: Re-push with PAT to trigger CI
        if: success()
        env:
          NOPO_BOT_PAT: ${{ secrets.NOPO_BOT_PAT }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          # Amend + push with PAT to trigger CI workflows
          # Only if branch has commits beyond main (don't amend main's commits)
          # Clear the GITHUB_TOKEN credential and use PAT instead
          git config --unset-all http.https://github.com/.extraheader || true
          git config http.https://github.com/.extraheader "AUTHORIZATION: basic $(echo -n "x-access-token:$NOPO_BOT_PAT" | base64)"
          if [[ $(git rev-list origin/main..HEAD --count) -gt 0 ]]; then
            git commit --amend --no-edit
            git push origin "$BRANCH_NAME" --force-with-lease
          fi

  pr-human-response:
    needs: context
    if: inputs.job == 'pr-human-response'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.context.outputs.branch_name }}
          fetch-depth: 0
      - name: git config
        run: |
          git config --global user.name "Claude Bot"
          git config --global user.email "claude-bot@anthropic.com"
      - id: augment
        name: Add REPOSITORY and HEAD_REF
        env:
          BASE_REPLACEMENTS: ${{ needs.context.outputs.prompt_replacements }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          json=$(echo "$BASE_REPLACEMENTS" | jq -c \
            --arg repo "${{ github.repository }}" \
            --arg branch "$BRANCH_NAME" \
            '. + {REPOSITORY: $repo, HEAD_REF: $branch}')
          echo "json=$json" >> $GITHUB_OUTPUT
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/human-review-response.txt
          prompt_replacements: ${{ steps.augment.outputs.json }}
          max_turns: '50'
      - name: Re-push with PAT to trigger CI
        if: success()
        env:
          NOPO_BOT_PAT: ${{ secrets.NOPO_BOT_PAT }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          # Amend + push with PAT to trigger CI workflows
          # Only if branch has commits beyond main (don't amend main's commits)
          # Clear the GITHUB_TOKEN credential and use PAT instead
          git config --unset-all http.https://github.com/.extraheader || true
          git config http.https://github.com/.extraheader "AUTHORIZATION: basic $(echo -n "x-access-token:$NOPO_BOT_PAT" | base64)"
          if [[ $(git rev-list origin/main..HEAD --count) -gt 0 ]]; then
            git commit --amend --no-edit
            git push origin "$BRANCH_NAME" --force-with-lease
          fi

  # ============================================================================
  # DISCUSSION JOBS
  # ============================================================================
  discussion-research:
    needs: context
    if: inputs.job == 'discussion-research'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/discussion-research.txt
          prompt_replacements: ${{ needs.context.outputs.prompt_replacements }}
          max_turns: '30'
          show_full_output: 'true'
      - uses: actions/upload-artifact@v4
        with:
          name: claude-discussion-output
          path: |
            /tmp/research-thread-*.md
            /tmp/discussion-updated-body.md
          retention-days: 1
          if-no-files-found: ignore

  discussion-respond:
    needs: context
    if: inputs.job == 'discussion-respond'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/discussion-respond.txt
          prompt_replacements: ${{ needs.context.outputs.prompt_replacements }}
          max_turns: '100'
          show_full_output: 'true'
      - uses: actions/upload-artifact@v4
        with:
          name: claude-discussion-output
          path: |
            /tmp/discussion-response.md
            /tmp/discussion-updated-body.md
          retention-days: 1
          if-no-files-found: ignore

  discussion-summarize:
    needs: context
    if: inputs.job == 'discussion-summarize'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/discussion-summarize.txt
          prompt_replacements: ${{ needs.context.outputs.prompt_replacements }}
          max_turns: '50'
          show_full_output: 'true'
      - uses: actions/upload-artifact@v4
        with:
          name: claude-discussion-output
          path: /tmp/discussion-summary.md
          retention-days: 1
          if-no-files-found: ignore

  discussion-plan:
    needs: context
    if: inputs.job == 'discussion-plan'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/discussion-plan.txt
          prompt_replacements: ${{ needs.context.outputs.prompt_replacements }}
          max_turns: '100'
          show_full_output: 'true'
      - uses: actions/upload-artifact@v4
        with:
          name: claude-discussion-output
          path: /tmp/discussion-plan-summary.md
          retention-days: 1
          if-no-files-found: ignore
