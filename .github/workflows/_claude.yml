name: Claude Business Logic
'on':
  workflow_call:
    inputs:
      job:
        description: Job to run
        required: true
        type: string
      context_json:
        description: JSON blob with all context needed by the job
        required: true
        type: string
      mock_mode:
        description: Mock mode for testing
        type: boolean
        default: false
  workflow_dispatch:
    inputs:
      job:
        description: Job to run
        required: true
        type: choice
        options:
          - issue-triage
          - issue-implement
          - issue-comment
          - ci-fix
          - ci-suggest
          - pr-review
          - pr-response
          - pr-human-response
          - discussion-research
          - discussion-respond
          - discussion-summarize
          - discussion-plan
      context_json:
        description: JSON blob with context (see plan for structure)
        required: true
        type: string
      mock_mode:
        description: Mock mode for testing
        type: boolean
        default: false
permissions:
  contents: write
  pull-requests: write
  issues: write
  id-token: write
defaults:
  run:
    shell: bash

jobs:
  # ============================================================================
  # CONTEXT - Transform input to prompt replacements format
  # ============================================================================
  context:
    runs-on: ubuntu-latest
    outputs:
      prompt_replacements: ${{ steps.format.outputs.json }}
      branch_name: ${{ steps.extract.outputs.branch_name }}
    steps:
      - id: extract
        name: Extract branch_name for checkout
        env:
          CONTEXT_JSON: ${{ inputs.context_json }}
        run: |
          # Use env var to avoid shell injection from special characters in issue body
          branch=$(echo "$CONTEXT_JSON" | jq -r '.branch_name // "main"')
          echo "branch_name=$branch" >> $GITHUB_OUTPUT

      - id: format
        name: Transform to uppercase keys
        env:
          CONTEXT_JSON: ${{ inputs.context_json }}
        run: |
          # Transform all keys to uppercase for prompt replacements
          # Use -c for compact single-line output (required for GITHUB_OUTPUT)
          # Use env var to avoid shell injection from special characters in issue body
          json=$(echo "$CONTEXT_JSON" | jq -c 'with_entries(.key |= ascii_upcase)')
          echo "json=$json" >> $GITHUB_OUTPUT

  # ============================================================================
  # ISSUE JOBS
  # ============================================================================
  issue-triage:
    needs: context
    if: inputs.job == 'issue-triage'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/triage.txt
          prompt_replacements: ${{ needs.context.outputs.prompt_replacements }}
          max_turns: '50'
          mock_mode: ${{ inputs.mock_mode }}
      - name: Apply triage labels
        if: always() && inputs.mock_mode != true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
        run: |
          if [[ ! -f triage-output.json ]]; then
            echo "No triage-output.json found - skipping label application"
            exit 0
          fi

          echo "Applying labels from triage-output.json:"
          cat triage-output.json

          # Extract values from JSON
          type=$(jq -r '.type // empty' triage-output.json)
          priority=$(jq -r '.priority // empty' triage-output.json)
          topics=$(jq -r '.topics[]? // empty' triage-output.json)

          labels=""

          # Add type label
          if [[ -n "$type" && "$type" != "null" ]]; then
            labels="$type"
            echo "Adding type label: $type"
          fi

          # Add priority label (only if not null)
          if [[ -n "$priority" && "$priority" != "null" ]]; then
            labels="${labels:+$labels,}priority:$priority"
            echo "Adding priority label: priority:$priority"
          fi

          # Add topic labels
          for topic in $topics; do
            if [[ -n "$topic" ]]; then
              labels="${labels:+$labels,}topic:$topic"
              echo "Adding topic label: topic:$topic"
            fi
          done

          # Always add triaged label
          labels="${labels:+$labels,}triaged"
          echo "Adding triaged label"

          # Apply all labels at once
          if [[ -n "$labels" ]]; then
            echo "Applying labels: $labels"
            gh issue edit "$ISSUE_NUMBER" --add-label "$labels" || true
          fi
      - uses: actions/upload-artifact@v4
        with:
          name: claude-triage-output
          path: triage-output.json
          retention-days: 1
          if-no-files-found: ignore

  issue-implement:
    needs: context
    if: inputs.job == 'issue-implement'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        if: inputs.mock_mode != true
        with:
          ref: ${{ needs.context.outputs.branch_name }}
          fetch-depth: 0
      - uses: actions/checkout@v4
        if: inputs.mock_mode == true
      - name: Update project status to In Progress
        if: inputs.mock_mode != true
        env:
          GH_TOKEN: ${{ secrets.PROJECT_TOKEN || secrets.GITHUB_TOKEN }}
          CONTEXT_JSON: ${{ inputs.context_json }}
        run: |
          ISSUE_NUMBER=$(echo "$CONTEXT_JSON" | jq -r '.issue_number // empty')
          [[ -z "$ISSUE_NUMBER" ]] && exit 0

          repo_name="${GITHUB_REPOSITORY#*/}"
          owner="${GITHUB_REPOSITORY%/*}"

          result=$(gh api graphql -f query='query($owner: String!, $repo: String!, $issue: Int!) {
            repository(owner: $owner, name: $repo) {
              issue(number: $issue) {
                projectItems(first: 10) {
                  nodes {
                    id
                    project {
                      id
                      field(name: "Status") {
                        ... on ProjectV2SingleSelectField {
                          id
                          options { id name }
                        }
                      }
                    }
                  }
                }
              }
            }
          }' -F owner="$owner" -F repo="$repo_name" -F issue="$ISSUE_NUMBER" 2>/dev/null || echo "{}")

          item=$(echo "$result" | jq -r '.data.repository.issue.projectItems.nodes[0] // empty')
          [[ -z "$item" ]] && exit 0

          item_id=$(echo "$item" | jq -r '.id')
          project_id=$(echo "$item" | jq -r '.project.id')
          field_id=$(echo "$item" | jq -r '.project.field.id')
          option_id=$(echo "$item" | jq -r '.project.field.options[] | select(.name == "In Progress") | .id')

          [[ -z "$option_id" ]] && exit 0

          gh api graphql -f query='mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
            updateProjectV2ItemFieldValue(input: {
              projectId: $projectId, itemId: $itemId, fieldId: $fieldId,
              value: { singleSelectOptionId: $optionId }
            }) { projectV2Item { id } }
          }' -F projectId="$project_id" -F itemId="$item_id" -F fieldId="$field_id" -F optionId="$option_id"
      - name: git config
        if: inputs.mock_mode != true
        run: |
          git config --global user.name "Claude Bot"
          git config --global user.email "claude-bot@anthropic.com"
      - name: Rebase onto main
        if: inputs.mock_mode != true
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          git fetch origin main
          if ! git rebase origin/main; then
            git rebase --abort
            echo "::error::Rebase failed due to conflicts. Please resolve conflicts manually before re-running."
            exit 1
          fi
          # Amend + push with PAT to trigger CI workflows
          # Only if branch has commits beyond main (don't amend main's commits)
          # Clear the GITHUB_TOKEN credential and use PAT instead
          git config --unset-all http.https://github.com/.extraheader || true
          git config http.https://github.com/.extraheader "AUTHORIZATION: basic $(echo -n "x-access-token:$PAT_TOKEN" | base64)"
          if [[ $(git rev-list origin/main..HEAD --count) -gt 0 ]]; then
            git commit --amend --no-edit
            git push origin "$BRANCH_NAME" --force-with-lease
          else
            echo "No commits beyond main - skipping push"
          fi
      - id: augment
        name: Check for existing branch work
        env:
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
          BASE_REPLACEMENTS: ${{ needs.context.outputs.prompt_replacements }}
        run: |
          # Check if branch has commits beyond main
          diff=$(git diff main.."$BRANCH_NAME" --stat 2>/dev/null || echo "")
          if [[ -n "$diff" ]]; then
            section=$(cat <<'SECTION'
          ## ⚠️ EXISTING BRANCH - Previous work detected

          This branch already has changes from a previous implementation attempt:
          ```
          $diff
          ```

          **CRITICAL**: Review what is already done. Do NOT re-implement completed work.
          Start from the CURRENT state of the code and continue toward the goal.
          If an edit fails because the text is not found, the change may already be applied.
          SECTION
          )
            section="${section//\$diff/$diff}"
          else
            section=""
          fi
          # Add EXISTING_BRANCH_SECTION to replacements
          json=$(echo "$BASE_REPLACEMENTS" | jq -c --arg section "$section" '. + {EXISTING_BRANCH_SECTION: $section}')
          echo "json=$json" >> $GITHUB_OUTPUT
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/implement.txt
          prompt_replacements: ${{ steps.augment.outputs.json }}
          max_turns: '200'
          show_full_output: 'true'
          assignee_trigger: nopo-bot
          mock_mode: ${{ inputs.mock_mode }}
      - name: Re-push with PAT to trigger CI
        if: success() && inputs.mock_mode != true
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          # Amend + push with PAT to trigger CI workflows
          # Only if branch has commits beyond main (don't amend main's commits)
          # Clear the GITHUB_TOKEN credential and use PAT instead
          git config --unset-all http.https://github.com/.extraheader || true
          git config http.https://github.com/.extraheader "AUTHORIZATION: basic $(echo -n "x-access-token:$PAT_TOKEN" | base64)"
          if [[ $(git rev-list origin/main..HEAD --count) -gt 0 ]]; then
            git commit --amend --no-edit
            git push origin "$BRANCH_NAME" --force-with-lease
          else
            echo "No commits beyond main - skipping push"
          fi
      - name: Save uncommitted work on failure
        if: failure() && inputs.mock_mode != true
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          # Check for any uncommitted changes (staged or unstaged)
          if [[ -n "$(git status --porcelain)" ]]; then
            echo "Found uncommitted changes - saving work..."
            git add -A
            git commit -m "WIP: Save uncommitted work from failed run

            This commit preserves work that was not pushed before the job failed.
            Review and clean up before continuing.

            Workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            # Use PAT to push so it triggers CI workflows
            # Clear the GITHUB_TOKEN credential and use PAT instead
            git config --unset-all http.https://github.com/.extraheader || true
            git config http.https://github.com/.extraheader "AUTHORIZATION: basic $(echo -n "x-access-token:$PAT_TOKEN" | base64)"
            git push origin "$BRANCH_NAME"
            echo "::warning::Uncommitted work was saved to branch $BRANCH_NAME"
          else
            echo "No uncommitted changes to save"
          fi

  issue-comment:
    needs: context
    if: inputs.job == 'issue-comment'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        if: inputs.mock_mode != true
        with:
          ref: ${{ needs.context.outputs.branch_name }}
          fetch-depth: 0
      - uses: actions/checkout@v4
        if: inputs.mock_mode == true
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/comment.txt
          prompt_replacements: ${{ needs.context.outputs.prompt_replacements }}
          max_turns: '100'
          trigger_phrase: '@claude'
          mock_mode: ${{ inputs.mock_mode }}
      - name: Re-push with PAT to trigger CI
        if: success() && inputs.mock_mode != true
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          # Amend + push with PAT to trigger CI workflows
          # Only if branch has commits beyond main (don't amend main's commits)
          # Clear the GITHUB_TOKEN credential and use PAT instead
          git config --unset-all http.https://github.com/.extraheader || true
          git config http.https://github.com/.extraheader "AUTHORIZATION: basic $(echo -n "x-access-token:$PAT_TOKEN" | base64)"
          if [[ $(git rev-list origin/main..HEAD --count) -gt 0 ]]; then
            git commit --amend --no-edit
            git push origin "$BRANCH_NAME" --force-with-lease
          fi

  # ============================================================================
  # CI JOBS
  # ============================================================================
  ci-fix:
    needs: context
    if: inputs.job == 'ci-fix'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        if: inputs.mock_mode != true
        with:
          ref: ${{ needs.context.outputs.branch_name }}
          fetch-depth: 0
      - uses: actions/checkout@v4
        if: inputs.mock_mode == true
      - name: git config
        if: inputs.mock_mode != true
        run: |
          git config --global user.name "Claude Bot"
          git config --global user.email "claude-bot@anthropic.com"
      - name: Rebase onto main
        if: inputs.mock_mode != true
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          git fetch origin main
          if ! git rebase origin/main; then
            git rebase --abort
            echo "::error::Rebase failed due to conflicts. Please resolve conflicts manually before re-running."
            exit 1
          fi
          # Amend + push with PAT to trigger CI workflows
          # Only if branch has commits beyond main (don't amend main's commits)
          # Clear the GITHUB_TOKEN credential and use PAT instead
          git config --unset-all http.https://github.com/.extraheader || true
          git config http.https://github.com/.extraheader "AUTHORIZATION: basic $(echo -n "x-access-token:$PAT_TOKEN" | base64)"
          if [[ $(git rev-list origin/main..HEAD --count) -gt 0 ]]; then
            git commit --amend --no-edit
            git push origin "$BRANCH_NAME" --force-with-lease
          else
            echo "No commits beyond main - skipping push"
          fi
      - id: augment
        name: Add HEAD_BRANCH alias
        env:
          BASE_REPLACEMENTS: ${{ needs.context.outputs.prompt_replacements }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          json=$(echo "$BASE_REPLACEMENTS" | jq -c --arg branch "$BRANCH_NAME" '. + {HEAD_BRANCH: $branch}')
          echo "json=$json" >> $GITHUB_OUTPUT
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/ci-fix.txt
          prompt_replacements: ${{ steps.augment.outputs.json }}
          max_turns: '200'
          mock_mode: ${{ inputs.mock_mode }}
      - name: Re-push with PAT to trigger CI
        if: success() && inputs.mock_mode != true
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          # Amend + push with PAT to trigger CI workflows
          # Only if branch has commits beyond main (don't amend main's commits)
          # Clear the GITHUB_TOKEN credential and use PAT instead
          git config --unset-all http.https://github.com/.extraheader || true
          git config http.https://github.com/.extraheader "AUTHORIZATION: basic $(echo -n "x-access-token:$PAT_TOKEN" | base64)"
          if [[ $(git rev-list origin/main..HEAD --count) -gt 0 ]]; then
            git commit --amend --no-edit
            git push origin "$BRANCH_NAME" --force-with-lease
          else
            echo "No commits beyond main - skipping push"
          fi

  ci-suggest:
    needs: context
    if: inputs.job == 'ci-suggest'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        if: inputs.mock_mode != true
        with:
          ref: ${{ needs.context.outputs.branch_name }}
          fetch-depth: 0
      - uses: actions/checkout@v4
        if: inputs.mock_mode == true
      - id: augment
        name: Add HEAD_BRANCH alias
        env:
          BASE_REPLACEMENTS: ${{ needs.context.outputs.prompt_replacements }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          json=$(echo "$BASE_REPLACEMENTS" | jq -c --arg branch "$BRANCH_NAME" '. + {HEAD_BRANCH: $branch}')
          echo "json=$json" >> $GITHUB_OUTPUT
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/ci-suggest.txt
          prompt_replacements: ${{ steps.augment.outputs.json }}
          max_turns: '200'
          mock_mode: ${{ inputs.mock_mode }}

  # ============================================================================
  # PR REVIEW JOBS
  # ============================================================================
  pr-review:
    needs: context
    if: inputs.job == 'pr-review'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        if: inputs.mock_mode != true
        with:
          ref: ${{ needs.context.outputs.branch_name }}
          fetch-depth: 0
      - uses: actions/checkout@v4
        if: inputs.mock_mode == true
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/review.txt
          prompt_replacements: ${{ needs.context.outputs.prompt_replacements }}
          max_turns: '50'
          mock_mode: ${{ inputs.mock_mode }}

  pr-response:
    needs: context
    if: inputs.job == 'pr-response'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        if: inputs.mock_mode != true
        with:
          ref: ${{ needs.context.outputs.branch_name }}
          fetch-depth: 0
      - uses: actions/checkout@v4
        if: inputs.mock_mode == true
      - name: git config
        if: inputs.mock_mode != true
        run: |
          git config --global user.name "Claude Bot"
          git config --global user.email "claude-bot@anthropic.com"
      - id: augment
        name: Add REPOSITORY and HEAD_REF
        env:
          BASE_REPLACEMENTS: ${{ needs.context.outputs.prompt_replacements }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          json=$(echo "$BASE_REPLACEMENTS" | jq -c \
            --arg repo "${{ github.repository }}" \
            --arg branch "$BRANCH_NAME" \
            '. + {REPOSITORY: $repo, HEAD_REF: $branch}')
          echo "json=$json" >> $GITHUB_OUTPUT
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/review-response.txt
          prompt_replacements: ${{ steps.augment.outputs.json }}
          max_turns: '50'
          mock_mode: ${{ inputs.mock_mode }}
      - name: Re-push with PAT to trigger CI
        if: success() && inputs.mock_mode != true
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          # Amend + push with PAT to trigger CI workflows
          # Only if branch has commits beyond main (don't amend main's commits)
          # Clear the GITHUB_TOKEN credential and use PAT instead
          git config --unset-all http.https://github.com/.extraheader || true
          git config http.https://github.com/.extraheader "AUTHORIZATION: basic $(echo -n "x-access-token:$PAT_TOKEN" | base64)"
          if [[ $(git rev-list origin/main..HEAD --count) -gt 0 ]]; then
            git commit --amend --no-edit
            git push origin "$BRANCH_NAME" --force-with-lease
          fi

  pr-human-response:
    needs: context
    if: inputs.job == 'pr-human-response'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        if: inputs.mock_mode != true
        with:
          ref: ${{ needs.context.outputs.branch_name }}
          fetch-depth: 0
      - uses: actions/checkout@v4
        if: inputs.mock_mode == true
      - name: git config
        if: inputs.mock_mode != true
        run: |
          git config --global user.name "Claude Bot"
          git config --global user.email "claude-bot@anthropic.com"
      - id: augment
        name: Add REPOSITORY and HEAD_REF
        env:
          BASE_REPLACEMENTS: ${{ needs.context.outputs.prompt_replacements }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          json=$(echo "$BASE_REPLACEMENTS" | jq -c \
            --arg repo "${{ github.repository }}" \
            --arg branch "$BRANCH_NAME" \
            '. + {REPOSITORY: $repo, HEAD_REF: $branch}')
          echo "json=$json" >> $GITHUB_OUTPUT
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/human-review-response.txt
          prompt_replacements: ${{ steps.augment.outputs.json }}
          max_turns: '50'
          mock_mode: ${{ inputs.mock_mode }}
      - name: Re-push with PAT to trigger CI
        if: success() && inputs.mock_mode != true
        env:
          PAT_TOKEN: ${{ secrets.PAT_TOKEN }}
          BRANCH_NAME: ${{ needs.context.outputs.branch_name }}
        run: |
          # Amend + push with PAT to trigger CI workflows
          # Only if branch has commits beyond main (don't amend main's commits)
          # Clear the GITHUB_TOKEN credential and use PAT instead
          git config --unset-all http.https://github.com/.extraheader || true
          git config http.https://github.com/.extraheader "AUTHORIZATION: basic $(echo -n "x-access-token:$PAT_TOKEN" | base64)"
          if [[ $(git rev-list origin/main..HEAD --count) -gt 0 ]]; then
            git commit --amend --no-edit
            git push origin "$BRANCH_NAME" --force-with-lease
          fi

  # ============================================================================
  # DISCUSSION JOBS
  # ============================================================================
  discussion-research:
    needs: context
    if: inputs.job == 'discussion-research'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/discussion-research.txt
          prompt_replacements: ${{ needs.context.outputs.prompt_replacements }}
          max_turns: '30'
          show_full_output: 'true'
          mock_mode: ${{ inputs.mock_mode }}
      - uses: actions/upload-artifact@v4
        with:
          name: claude-discussion-output
          path: |
            /tmp/research-thread-*.md
            /tmp/discussion-updated-body.md
          retention-days: 1
          if-no-files-found: ignore

  discussion-respond:
    needs: context
    if: inputs.job == 'discussion-respond'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/discussion-respond.txt
          prompt_replacements: ${{ needs.context.outputs.prompt_replacements }}
          max_turns: '100'
          show_full_output: 'true'
          mock_mode: ${{ inputs.mock_mode }}
      - uses: actions/upload-artifact@v4
        with:
          name: claude-discussion-output
          path: |
            /tmp/discussion-response.md
            /tmp/discussion-updated-body.md
          retention-days: 1
          if-no-files-found: ignore

  discussion-summarize:
    needs: context
    if: inputs.job == 'discussion-summarize'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/discussion-summarize.txt
          prompt_replacements: ${{ needs.context.outputs.prompt_replacements }}
          max_turns: '50'
          show_full_output: 'true'
          mock_mode: ${{ inputs.mock_mode }}
      - uses: actions/upload-artifact@v4
        with:
          name: claude-discussion-output
          path: /tmp/discussion-summary.md
          retention-days: 1
          if-no-files-found: ignore

  discussion-plan:
    needs: context
    if: inputs.job == 'discussion-plan'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/run-claude
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          prompt_file: .github/prompts/discussion-plan.txt
          prompt_replacements: ${{ needs.context.outputs.prompt_replacements }}
          max_turns: '100'
          show_full_output: 'true'
          mock_mode: ${{ inputs.mock_mode }}
      - uses: actions/upload-artifact@v4
        with:
          name: claude-discussion-output
          path: /tmp/discussion-plan-summary.md
          retention-days: 1
          if-no-files-found: ignore
