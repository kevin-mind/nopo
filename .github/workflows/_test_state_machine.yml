name: Test State Machine

on:
  workflow_dispatch:
    inputs:
      test_name:
        description: 'Test scenario to run'
        required: true
        type: choice
        options:
          # Issue jobs
          - issue-triage
          - issue-orchestrate
          - issue-comment
          - single-phase-green
          - multi-phase-sequential
          - ci-failure-recovery
          - circuit-breaker
          - phase-skip
          # PR jobs
          - pr-review
          - pr-response
          - pr-human-response
          - review-changes-requested
          # Discussion jobs
          - discussion-research
          - discussion-respond
          - discussion-summarize
          - discussion-plan
      mode:
        description: 'Test mode'
        type: choice
        default: dry-run
        options:
          - dry-run
          - stepwise
          - e2e
      cleanup_only:
        description: 'Only run cleanup (for debugging)'
        type: boolean
        default: false
      issue_number:
        description: 'Issue number for cleanup_only mode'
        type: string
        default: ''

# Only one E2E test at a time - queue don't cancel
concurrency:
  group: e2e-test
  cancel-in-progress: false

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write
  id-token: write

env:
  GH_TOKEN: ${{ secrets.NOPO_BOT_PAT || secrets.GITHUB_TOKEN }}

jobs:
  # Load the fixture configuration
  load-fixture:
    runs-on: ubuntu-latest
    outputs:
      fixture: ${{ steps.read.outputs.fixture }}
    steps:
      - uses: actions/checkout@v4

      - name: Read fixture file
        id: read
        run: |
          fixture_file=".github/test-fixtures/${{ inputs.test_name }}.json"
          if [[ ! -f "$fixture_file" ]]; then
            echo "::error::Fixture file not found: $fixture_file"
            exit 1
          fi

          # Read fixture as compact JSON
          # Use heredoc delimiter syntax for outputs with special characters
          fixture=$(cat "$fixture_file" | jq -c '.')

          delimiter=$(openssl rand -hex 16)
          echo "fixture<<$delimiter" >> $GITHUB_OUTPUT
          echo "$fixture" >> $GITHUB_OUTPUT
          echo "$delimiter" >> $GITHUB_OUTPUT

          echo "Loaded fixture: ${{ inputs.test_name }}"

  # Create test artifacts (issues, branches, PRs)
  setup:
    needs: load-fixture
    if: inputs.cleanup_only != true
    runs-on: ubuntu-latest
    outputs:
      issue_number: ${{ steps.create.outputs.issue_number }}
      sub_issue_numbers: ${{ steps.create.outputs.sub_issue_numbers }}
      branch_name: ${{ steps.create.outputs.branch_name }}
      pr_number: ${{ steps.create.outputs.pr_number }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Build test helper action
        run: |
          cd .github/actions-ts
          pnpm install --frozen-lockfile
          pnpm run build

      - name: Create test fixture
        id: create
        uses: ./.github/actions-ts/claude-test-helper
        with:
          action: create
          fixture_json: ${{ needs.load-fixture.outputs.fixture }}
          github_token: ${{ env.GH_TOKEN }}
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          stepwise_mode: ${{ inputs.mode == 'stepwise' }}
          dry_run_mode: ${{ inputs.mode == 'dry-run' }}

      - name: Output created resources
        run: |
          echo "## Test Fixture Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Parent Issue** | #${{ steps.create.outputs.issue_number }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Sub-issues** | ${{ steps.create.outputs.sub_issue_numbers }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Branch** | ${{ steps.create.outputs.branch_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **PR** | ${{ steps.create.outputs.pr_number }} |" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ inputs.mode }}" == "stepwise" ]]; then
            echo "| **Mode** | Stepwise (_test label added) |" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ inputs.mode }}" == "dry-run" ]]; then
            echo "| **Mode** | Dry-run (no test mode label, workflows skip) |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| **Mode** | E2E (_e2e label added) |" >> $GITHUB_STEP_SUMMARY
          fi

  # Run state machine in dry-run mode (direct call, no real execution)
  # In the new architecture:
  # - State machine derives actions (no execution)
  # - Executor would execute them (dry_run=true skips actual execution)
  run-dry-run:
    needs: [load-fixture, setup]
    if: |
      always() &&
      inputs.cleanup_only != true &&
      inputs.mode == 'dry-run' &&
      needs.setup.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      actions_json: ${{ steps.machine.outputs.actions_json }}
      final_state: ${{ steps.machine.outputs.final_state }}
      action_count: ${{ steps.machine.outputs.action_count }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Build actions
        run: |
          cd .github/actions-ts
          pnpm install --frozen-lockfile
          pnpm run build

      - name: Determine trigger type and context
        id: trigger
        env:
          FIXTURE_JSON: ${{ needs.load-fixture.outputs.fixture }}
        run: |
          # Extract trigger type from fixture or default based on job_type
          job_type=$(echo "$FIXTURE_JSON" | jq -r '.job_type // "issue-iterate"')
          trigger=$(echo "$FIXTURE_JSON" | jq -r '.trigger // empty')

          if [[ -z "$trigger" ]]; then
            case "$job_type" in
              issue-triage)
                trigger="issue_opened"
                ;;
              issue-iterate|issue-orchestrate)
                trigger="issue_assigned"
                ;;
              pr-review)
                trigger="pr_review_requested"
                ;;
              pr-response|pr-human-response)
                trigger="pr_review_submitted"
                ;;
              *)
                trigger="issue_assigned"
                ;;
            esac
          fi

          # Extract trigger context (ci_result, review_decision, etc.)
          ci_result=$(echo "$FIXTURE_JSON" | jq -r '.trigger_context.ci_result // empty')
          review_decision=$(echo "$FIXTURE_JSON" | jq -r '.trigger_context.review_decision // empty')
          reviewer=$(echo "$FIXTURE_JSON" | jq -r '.trigger_context.reviewer // empty')

          echo "trigger=$trigger" >> $GITHUB_OUTPUT
          echo "ci_result=$ci_result" >> $GITHUB_OUTPUT
          echo "review_decision=$review_decision" >> $GITHUB_OUTPUT
          echo "reviewer=$reviewer" >> $GITHUB_OUTPUT
          echo "Determined trigger: $trigger, ci_result: $ci_result, review_decision: $review_decision"

      # State machine now only derives actions (no execution)
      - name: Derive Actions (State Machine)
        id: machine
        uses: ./.github/actions-ts/claude-state-machine
        with:
          github_token: ${{ env.GH_TOKEN }}
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          issue_number: ${{ needs.setup.outputs.issue_number }}
          trigger: ${{ steps.trigger.outputs.trigger }}
          ci_result: ${{ steps.trigger.outputs.ci_result }}
          review_decision: ${{ steps.trigger.outputs.review_decision }}
          reviewer: ${{ steps.trigger.outputs.reviewer }}

      - name: Output dry-run results
        env:
          ACTIONS_JSON: ${{ steps.machine.outputs.actions_json }}
          FINAL_STATE: ${{ steps.machine.outputs.final_state }}
          ACTION_COUNT: ${{ steps.machine.outputs.action_count }}
        run: |
          echo "## State Machine Dry-Run Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Final State** | \`${FINAL_STATE}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Action Count** | ${ACTION_COUNT} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Actions (would be executed)" >> $GITHUB_STEP_SUMMARY
          echo '```json' >> $GITHUB_STEP_SUMMARY
          echo "$ACTIONS_JSON" | jq '.' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  # Trigger the state machine by assigning nopo-bot (stepwise/e2e modes only)
  trigger:
    needs: [setup]
    if: |
      always() &&
      inputs.cleanup_only != true &&
      inputs.mode != 'dry-run' &&
      needs.setup.result == 'success'
    runs-on: ubuntu-latest
    steps:
      # Dispatch triage via workflow_dispatch (E2E mode only)
      # Issue triggers were removed to use explicit workflow dispatch instead
      # Use GITHUB_TOKEN for workflow dispatch (PAT may not have workflow scope)
      - name: Dispatch triage workflow
        if: inputs.mode == 'e2e'
        env:
          ISSUE_NUMBER: ${{ needs.setup.outputs.issue_number }}
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Dispatching triage workflow for issue #$ISSUE_NUMBER..."
          gh workflow run claude.yml \
            --repo "$GITHUB_REPOSITORY" \
            -f resource_number="$ISSUE_NUMBER"
          echo "âœ… Triage workflow dispatched"

      # Wait for triage to complete before assigning nopo-bot (E2E mode only)
      - name: Wait for triage to complete
        if: inputs.mode == 'e2e'
        env:
          ISSUE_NUMBER: ${{ needs.setup.outputs.issue_number }}
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
        run: |
          echo "Waiting for triage to complete on issue #$ISSUE_NUMBER..."
          timeout=300  # 5 minutes for triage (matrix jobs add overhead)
          poll_interval=5
          start_time=$(date +%s)
          iteration=0

          while true; do
            current_time=$(date +%s)
            elapsed=$((current_time - start_time))
            iteration=$((iteration + 1))

            if [[ $elapsed -ge $timeout ]]; then
              echo "::error::Triage timeout after ${elapsed}s"
              exit 1
            fi

            # Get full issue state
            issue_json=$(gh issue view "$ISSUE_NUMBER" --repo "$GITHUB_REPOSITORY" \
              --json state,title,body,labels,assignees,projectItems 2>/dev/null || echo '{}')

            state=$(echo "$issue_json" | jq -r '.state // "UNKNOWN"')
            labels=$(echo "$issue_json" | jq -c '[.labels[]?.name] // []')
            assignees=$(echo "$issue_json" | jq -c '[.assignees[]?.login] // []')
            project_status=$(echo "$issue_json" | jq -r '.projectItems[0].fieldValueByName.name // "N/A"')
            has_triaged=$(echo "$issue_json" | jq '[.labels[]?.name] | any(. == "triaged")' 2>/dev/null || echo "false")
            has_state=$(echo "$issue_json" | jq '.body | contains("CLAUDE_MAIN_STATE")' 2>/dev/null || echo "false")

            # Build state object
            state_obj=$(jq -n \
              --arg elapsed "${elapsed}s" \
              --arg timeout "${timeout}s" \
              --arg poll "$iteration" \
              --arg issue "#$ISSUE_NUMBER" \
              --arg state "$state" \
              --arg status "$project_status" \
              --argjson labels "$labels" \
              --argjson assignees "$assignees" \
              --arg has_triaged "$has_triaged" \
              --arg has_state "$has_state" \
              '{
                meta: { elapsed: $elapsed, timeout: $timeout, poll: ($poll | tonumber), phase: "triage" },
                issue: { number: $issue, state: $state, status: $status, labels: $labels, assignees: $assignees },
                checks: { has_triaged_label: ($has_triaged == "true"), has_claude_state: ($has_state == "true") }
              }')

            echo "::group::â³ Triage Poll $iteration - ${elapsed}s/${timeout}s"
            echo "$state_obj" | jq '.'
            echo "::endgroup::"

            if [[ "$has_triaged" == "true" ]] || [[ "$has_state" == "true" ]]; then
              echo "âœ… Triage completed after ${elapsed}s"
              break
            fi

            sleep $poll_interval
          done

      - name: Trigger state machine
        env:
          ISSUE_NUMBER: ${{ needs.setup.outputs.issue_number }}
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
          GH_TOKEN_WORKFLOW: ${{ github.token }}
        run: |
          echo "Triggering state machine for issue #$ISSUE_NUMBER"

          # Assign nopo-bot (required for state machine to proceed)
          gh issue edit "$ISSUE_NUMBER" \
            --repo "$GITHUB_REPOSITORY" \
            --add-assignee nopo-bot
          echo "âœ… Assigned nopo-bot to issue #$ISSUE_NUMBER"

          # Dispatch orchestrate workflow (since issues:assigned trigger is removed)
          # Use GITHUB_TOKEN for workflow dispatch (PAT may not have workflow scope)
          GH_TOKEN="$GH_TOKEN_WORKFLOW" gh workflow run claude.yml \
            --repo "$GITHUB_REPOSITORY" \
            -f resource_number="$ISSUE_NUMBER" \
            -f continue=true
          echo "âœ… Orchestrate workflow dispatched"

      - name: Wait for workflow to start
        run: |
          echo "Waiting for claude workflow to be triggered..."
          sleep 10

  # Wait for state machine and verify (E2E mode only)
  verify:
    needs: [load-fixture, setup, trigger]
    if: |
      always() &&
      inputs.cleanup_only != true &&
      inputs.mode == 'e2e' &&
      needs.setup.result == 'success' &&
      needs.trigger.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Build test helper action
        run: |
          cd .github/actions-ts
          pnpm install --frozen-lockfile
          pnpm run build

      - name: Wait for state machine to complete
        # Step timeout allows cancellation to work - set slightly higher than fixture timeout
        timeout-minutes: 30
        env:
          ISSUE_NUMBER: ${{ needs.setup.outputs.issue_number }}
          SUB_ISSUE_NUMBERS: ${{ needs.setup.outputs.sub_issue_numbers }}
          FIXTURE_JSON: ${{ needs.load-fixture.outputs.fixture }}
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
        run: |
          # Debug: check if FIXTURE_JSON is valid
          echo "::group::Debug FIXTURE_JSON"
          echo "Length: ${#FIXTURE_JSON}"
          echo "Line count: $(printf '%s' "$FIXTURE_JSON" | wc -l)"
          echo "First 100 chars: ${FIXTURE_JSON:0:100}..."
          printf '%s' "$FIXTURE_JSON" | jq -e '.' >/dev/null 2>&1 && echo "Valid JSON: yes" || echo "Valid JSON: NO!"
          echo "::endgroup::"

          timeout=$(printf '%s' "$FIXTURE_JSON" | jq -r '.timeout // 300')
          poll_interval=$(printf '%s' "$FIXTURE_JSON" | jq -r '.poll_interval // 10')

          # Parse history table from issue body into JSON array
          # Table format: | Time | # | Phase | Action | SHA | Run |
          # Returns JSON array of history entries (always valid JSON)
          parse_history() {
            local body="$1"

            # First, check if there's a history table at all
            if ! echo "$body" | grep -q '## Iteration History'; then
              echo "[]"
              return 0
            fi

            # Extract just the data rows (skip header with "Time" and separator with "---")
            local rows
            rows=$(echo "$body" | grep -E '^\|' | grep -v 'Time' | grep -v '\-\-\-' 2>/dev/null || true)

            if [[ -z "$rows" ]]; then
              echo "[]"
              return 0
            fi

            # Use jq with raw input to parse the pipe-delimited rows
            # If jq fails for any reason, return empty array
            local result
            result=$(echo "$rows" | jq -Rs '
              split("\n") |
              map(select(length > 0)) |
              map(
                split("|") |
                map(gsub("^\\s+|\\s+$"; "")) |
                select(length >= 6) |
                {
                  iteration: (.[2] | tonumber? // 0),
                  phase: .[3],
                  action: .[4],
                  sha: .[5]
                }
              )
            ' 2>/dev/null) || result="[]"

            # Final safety check - ensure output is valid JSON array
            if echo "$result" | jq -e 'type == "array"' >/dev/null 2>&1; then
              echo "$result"
            else
              echo "[]"
            fi
          }

          # Simulate human merge action when PR has "ready-to-merge" label
          simulate_merge() {
            local pr_number="$1"
            echo "ðŸ”€ Simulating human merge for PR #$pr_number..."

            # Try to merge the PR
            if gh pr merge "$pr_number" --repo "$GITHUB_REPOSITORY" --squash --admin 2>/dev/null; then
              echo "âœ… Successfully merged PR #$pr_number"
              return 0
            else
              echo "::warning::Failed to merge PR #$pr_number"
              return 1
            fi
          }

          start_time=$(date +%s)
          iteration=0

          while true; do
            current_time=$(date +%s)
            elapsed=$((current_time - start_time))
            iteration=$((iteration + 1))

            if [[ $elapsed -ge $timeout ]]; then
              echo "::warning::Timeout reached after ${elapsed}s"
              break
            fi

            # Get full issue details
            issue_json=$(gh issue view "$ISSUE_NUMBER" --repo "$GITHUB_REPOSITORY" --json state,title,body,labels,assignees,projectItems 2>/dev/null || echo '{}')
            state=$(echo "$issue_json" | jq -r '.state // "UNKNOWN"')
            title=$(echo "$issue_json" | jq -r '.title // "Unknown"')
            body=$(echo "$issue_json" | jq -r '.body // ""')
            labels=$(echo "$issue_json" | jq -c '[.labels[]?.name] // []')
            assignees=$(echo "$issue_json" | jq -c '[.assignees[]?.login] // []')
            project_status=$(echo "$issue_json" | jq -r '.projectItems[0].fieldValueByName.name // "N/A"')

            # Check for PRs with "ready-to-merge" label and simulate human merge
            # Only merge PRs that are linked to the current test's issues
            all_test_issues="$ISSUE_NUMBER"
            if [[ -n "$SUB_ISSUE_NUMBERS" ]]; then
              IFS=',' read -ra SUB_NUMS <<< "$SUB_ISSUE_NUMBERS"
              for sub_num in "${SUB_NUMS[@]}"; do
                sub_num=$(echo "$sub_num" | tr -d ' ')
                all_test_issues="$all_test_issues $sub_num"
              done
            fi

            # Search for PRs with ready-to-merge label
            pr_list=$(gh pr list --repo "$GITHUB_REPOSITORY" --label "ready-to-merge" --json number,state,body 2>/dev/null || echo '[]')
            for pr_row in $(echo "$pr_list" | jq -c '.[]'); do
              pr_num=$(echo "$pr_row" | jq -r '.number')
              pr_state=$(echo "$pr_row" | jq -r '.state')
              pr_body=$(echo "$pr_row" | jq -r '.body // ""')

              # Check if PR is linked to one of the test issues
              is_test_pr=false
              for issue_num in $all_test_issues; do
                if echo "$pr_body" | grep -qE "(Fixes|Closes|Resolves) #$issue_num"; then
                  is_test_pr=true
                  break
                fi
              done

              if [[ "$pr_state" == "OPEN" && "$is_test_pr" == "true" ]]; then
                echo "::notice::PR #$pr_num has ready-to-merge label and is linked to test issues - simulating human merge"
                simulate_merge "$pr_num"
                # Wait for merge to propagate
                sleep 5
              fi
            done

            # Parse history from body
            history=$(parse_history "$body")

            # Validate inputs are valid JSON before building state object
            if ! echo "$labels" | jq -e '.' >/dev/null 2>&1; then
              echo "::warning::labels is not valid JSON: $labels"
              labels='[]'
            fi
            if ! echo "$assignees" | jq -e '.' >/dev/null 2>&1; then
              echo "::warning::assignees is not valid JSON: $assignees"
              assignees='[]'
            fi
            if ! echo "$history" | jq -e '.' >/dev/null 2>&1; then
              echo "::warning::history is not valid JSON: $history"
              history='[]'
            fi

            # Build state object
            state_obj=$(jq -n \
              --arg elapsed "${elapsed}s" \
              --arg timeout "${timeout}s" \
              --arg poll "$iteration" \
              --arg issue "#$ISSUE_NUMBER" \
              --arg title "$title" \
              --arg state "$state" \
              --arg status "$project_status" \
              --argjson labels "$labels" \
              --argjson assignees "$assignees" \
              --argjson history "$history" \
              '{
                meta: { elapsed: $elapsed, timeout: $timeout, poll: ($poll | tonumber) },
                issue: { number: $issue, title: $title, state: $state, status: $status, labels: $labels, assignees: $assignees },
                history: $history
              }')

            # Clear screen and print state (GitHub Actions compatible)
            echo "::group::Poll $iteration - Elapsed: ${elapsed}s"
            echo "$state_obj" | jq '.'
            echo "::endgroup::"

            if [[ "$state" == "CLOSED" ]]; then
              echo "âœ… Parent #$ISSUE_NUMBER closed - state machine completed"
              break
            fi

            if [[ "$state" == "UNKNOWN" ]]; then
              echo "::warning::Parent #$ISSUE_NUMBER not found - may have been deleted"
              break
            fi

            sleep "$poll_interval" &
            wait $! || break
          done

          # Final state
          echo "::group::Final State"
          echo "$state_obj" | jq '.'
          echo "::endgroup::"

      - name: Verify outcome
        id: verify
        uses: ./.github/actions-ts/claude-test-helper
        with:
          action: verify
          fixture_json: ${{ needs.load-fixture.outputs.fixture }}
          issue_number: ${{ needs.setup.outputs.issue_number }}
          github_token: ${{ env.GH_TOKEN }}
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}

      - name: Output verification result
        run: |
          echo "## Verification Result" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ steps.verify.outputs.verification_passed }}" == "true" ]]; then
            echo "### âœ… All checks passed!" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ Verification failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Errors:" >> $GITHUB_STEP_SUMMARY
            echo '```json' >> $GITHUB_STEP_SUMMARY
            echo '${{ steps.verify.outputs.verification_errors }}' >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

      - name: Gather failure analysis
        if: steps.verify.outputs.verification_passed != 'true'
        env:
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
          ISSUE_NUMBER: ${{ needs.setup.outputs.issue_number }}
          SUB_ISSUE_NUMBERS: ${{ needs.setup.outputs.sub_issue_numbers }}
        run: |
          echo "## Failure Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Parent issue details
          echo "### Parent Issue #$ISSUE_NUMBER" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          gh issue view "$ISSUE_NUMBER" --repo "$GITHUB_REPOSITORY" --json number,title,state,body,assignees,labels,projectItems 2>/dev/null | jq '{
            number: .number,
            title: .title,
            state: .state,
            assignees: [.assignees[].login],
            labels: [.labels[].name],
            project_status: .projectItems[0].status.name
          }' >> $GITHUB_STEP_SUMMARY || echo "Failed to fetch parent issue" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Sub-issues
          if [[ -n "$SUB_ISSUE_NUMBERS" ]]; then
            echo "### Sub-Issues" >> $GITHUB_STEP_SUMMARY
            IFS=',' read -ra SUB_NUMS <<< "$SUB_ISSUE_NUMBERS"
            for sub_num in "${SUB_NUMS[@]}"; do
              sub_num=$(echo "$sub_num" | tr -d ' ')
              echo "#### Sub-Issue #$sub_num" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              gh issue view "$sub_num" --repo "$GITHUB_REPOSITORY" --json number,title,state,assignees,projectItems 2>/dev/null | jq '{
                number: .number,
                title: .title,
                state: .state,
                assignees: [.assignees[].login],
                project_status: .projectItems[0].status.name
              }' >> $GITHUB_STEP_SUMMARY || echo "Failed to fetch sub-issue" >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
            done
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Related PRs
          echo "### Related PRs" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          gh pr list --repo "$GITHUB_REPOSITORY" --search "$ISSUE_NUMBER in:body" --json number,title,state,isDraft,headRefName 2>/dev/null | jq '.[] | {
            number: .number,
            title: .title,
            state: .state,
            draft: .isDraft,
            branch: .headRefName
          }' >> $GITHUB_STEP_SUMMARY || echo "No related PRs found" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Recent Claude workflow runs
          echo "### Recent Claude Workflow Runs" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          gh run list --repo "$GITHUB_REPOSITORY" --workflow="Claude" --limit=10 --json databaseId,displayTitle,status,conclusion,createdAt 2>/dev/null | \
            jq '.[] | select(.displayTitle | contains("#'"$ISSUE_NUMBER"'")) | {
              run_id: .databaseId,
              title: .displayTitle,
              status: .status,
              conclusion: .conclusion,
              created: .createdAt
            }' >> $GITHUB_STEP_SUMMARY || echo "Failed to fetch workflow runs" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Links for manual investigation
          echo "### Investigation Links" >> $GITHUB_STEP_SUMMARY
          echo "- [Parent Issue](https://github.com/$GITHUB_REPOSITORY/issues/$ISSUE_NUMBER)" >> $GITHUB_STEP_SUMMARY
          echo "- [Claude Workflow Runs](https://github.com/$GITHUB_REPOSITORY/actions/workflows/claude.yml?query=branch%3Amain)" >> $GITHUB_STEP_SUMMARY
          echo "- [Project Board](https://github.com/orgs/${GITHUB_REPOSITORY%/*}/projects/1)" >> $GITHUB_STEP_SUMMARY

  # Verify dry-run results against expected values (dry-run mode only)
  verify-dry-run:
    needs: [load-fixture, setup, run-dry-run]
    if: |
      always() &&
      inputs.cleanup_only != true &&
      inputs.mode == 'dry-run' &&
      needs.run-dry-run.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      passed: ${{ steps.verify.outputs.passed }}
      errors: ${{ steps.verify.outputs.errors }}
    steps:
      - name: Verify state machine outputs
        id: verify
        env:
          ACTIONS_JSON: ${{ needs.run-dry-run.outputs.actions_json }}
          FINAL_STATE: ${{ needs.run-dry-run.outputs.final_state }}
          ACTION_COUNT: ${{ needs.run-dry-run.outputs.action_count }}
          FIXTURE_JSON: ${{ needs.load-fixture.outputs.fixture }}
        run: |
          errors=""
          passed="true"

          # Extract expected values from fixture (if specified)
          expected_final_state=$(echo "$FIXTURE_JSON" | jq -r '.expected_machine.final_state // empty')
          expected_contains_actions=$(echo "$FIXTURE_JSON" | jq -r '.expected_machine.contains_actions // empty')
          expected_action_count=$(echo "$FIXTURE_JSON" | jq -r '.expected_machine.action_count // empty')

          # Verify final state (if expected)
          if [[ -n "$expected_final_state" ]]; then
            if [[ "$FINAL_STATE" != "$expected_final_state" ]]; then
              errors="$errors\n- final_state: expected '$expected_final_state', got '$FINAL_STATE'"
              passed="false"
            fi
          fi

          # Verify action count (if expected)
          if [[ -n "$expected_action_count" ]]; then
            if [[ "$ACTION_COUNT" != "$expected_action_count" ]]; then
              errors="$errors\n- action_count: expected '$expected_action_count', got '$ACTION_COUNT'"
              passed="false"
            fi
          fi

          # Verify actions contain expected action types (if specified)
          if [[ -n "$expected_contains_actions" && "$expected_contains_actions" != "null" ]]; then
            for action_type in $(echo "$expected_contains_actions" | jq -r '.[]'); do
              if ! echo "$ACTIONS_JSON" | jq -e ".[] | select(.type == \"$action_type\")" > /dev/null 2>&1; then
                errors="$errors\n- actions: expected to contain '$action_type' but didn't"
                passed="false"
              fi
            done
          fi

          echo "passed=$passed" >> $GITHUB_OUTPUT
          echo "errors=$errors" >> $GITHUB_OUTPUT

          # Output verification result
          echo "## Dry-Run Verification" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [[ "$passed" == "true" ]]; then
            echo "### âœ… All verifications passed!" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ Verification failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Errors:" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo -e "$errors" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

  # Cleanup test artifacts (always runs unless skipped)
  cleanup:
    needs: [setup, verify, run-dry-run, verify-dry-run]
    if: |
      always() &&
      (needs.setup.outputs.issue_number != '' || inputs.cleanup_only == true)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Build test helper action
        run: |
          cd .github/actions-ts
          pnpm install --frozen-lockfile
          pnpm run build

      - name: Determine issue number
        id: issue
        run: |
          if [[ "${{ inputs.cleanup_only }}" == "true" ]]; then
            issue_number="${{ inputs.issue_number }}"
            if [[ -z "$issue_number" ]]; then
              echo "::error::issue_number is required for cleanup_only mode"
              exit 1
            fi
          else
            issue_number="${{ needs.setup.outputs.issue_number }}"
          fi
          echo "issue_number=$issue_number" >> $GITHUB_OUTPUT

      - name: Cleanup test fixture
        uses: ./.github/actions-ts/claude-test-helper
        with:
          action: cleanup
          issue_number: ${{ steps.issue.outputs.issue_number }}
          github_token: ${{ env.GH_TOKEN }}
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}

      - name: Output cleanup result
        run: |
          echo "## Cleanup Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Cleaned up issue #${{ steps.issue.outputs.issue_number }} and related resources." >> $GITHUB_STEP_SUMMARY

  # Summary job
  summary:
    needs: [setup, trigger, verify, run-dry-run, verify-dry-run, cleanup]
    if: always() && inputs.cleanup_only != true
    runs-on: ubuntu-latest
    steps:
      - name: Generate summary
        env:
          ACTIONS_JSON: ${{ needs.run-dry-run.outputs.actions_json }}
          FINAL_STATE: ${{ needs.run-dry-run.outputs.final_state }}
          ACTION_COUNT: ${{ needs.run-dry-run.outputs.action_count }}
        run: |
          echo "# State Machine Test Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Test** | ${{ inputs.test_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Mode** | ${{ inputs.mode }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Issue** | #${{ needs.setup.outputs.issue_number }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ inputs.mode }}" == "dry-run" ]]; then
            echo "## State Machine Results" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| **Final State** | \`${FINAL_STATE:-N/A}\` |" >> $GITHUB_STEP_SUMMARY
            echo "| **Action Count** | ${ACTION_COUNT:-0} |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Actions" >> $GITHUB_STEP_SUMMARY
            echo '```json' >> $GITHUB_STEP_SUMMARY
            echo "$ACTIONS_JSON" | jq '.' 2>/dev/null || echo "[]" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          echo "## Job Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Setup | ${{ needs.setup.result }} |" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ inputs.mode }}" == "dry-run" ]]; then
            echo "| Run Dry-Run | ${{ needs.run-dry-run.result }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Verify Dry-Run | ${{ needs.verify-dry-run.result }} |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Trigger | ${{ needs.trigger.result }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Verify | ${{ needs.verify.result }} |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "| Cleanup | ${{ needs.cleanup.result }} |" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ inputs.mode }}" == "stepwise" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "---" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Stepwise Mode:** Check the claude workflow run triggered by this test to see the decision output." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The \`_test\` label prevents execution - only the decision is shown." >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "${{ inputs.mode }}" == "dry-run" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "---" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Dry-Run Mode:** State machine derived actions without executing them." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Actions shown above are what _would_ be executed in a real run." >> $GITHUB_STEP_SUMMARY
          fi
