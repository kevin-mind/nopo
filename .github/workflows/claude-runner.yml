name: Claude Runner

# Reusable workflow that runs the Claude state machine for an issue.
# Architecture:
# 1. derive-actions: Runs state machine to derive actions, formats as matrix
# 2. exec-state-actions: Matrix job (max-parallel: 1) executes each action in isolation
#
# Two-token architecture:
# - github_code_token (NOPO_BOT_PAT): For code operations (push, PR, project fields)
# - github_review_token (CLAUDE_REVIEWER_PAT): For review operations (submit reviews)

on:
  workflow_call:
    inputs:
      trigger:
        description: Event trigger type (issue_assigned, issue_edited, workflow_run_completed, pr_review_submitted, etc.)
        required: true
        type: string
      issue_number:
        description: Issue number to process
        required: true
        type: string
      ci_result:
        description: CI result (success, failure) - required for workflow_run_completed trigger
        required: false
        type: string
      ci_run_url:
        description: CI run URL - for workflow_run_completed trigger
        required: false
        type: string
      ci_commit_sha:
        description: CI commit SHA - for workflow_run_completed trigger
        required: false
        type: string
      review_decision:
        description: Review decision (APPROVED, CHANGES_REQUESTED, COMMENTED) - for pr_review_submitted trigger
        required: false
        type: string
      reviewer:
        description: Reviewer username - for pr_review_submitted trigger
        required: false
        type: string
      comment_context_type:
        description: Context type (Issue or PR) - for issue_comment trigger
        required: false
        type: string
      comment_context_description:
        description: Context description - for issue_comment trigger
        required: false
        type: string
      branch:
        description: Branch name for the work - for issue_comment trigger
        required: false
        type: string
      # Status signaling inputs
      job:
        description: Job name for status comments (e.g., 'issue-iterate', 'pr-review')
        required: false
        type: string
        default: ''
      resource_type:
        description: Resource type for status comments ('issue' or 'pr')
        required: false
        type: string
        default: 'issue'
      resource_number:
        description: Resource number (issue or PR number) for status comments
        required: false
        type: string
        default: '0'
      comment_id:
        description: Comment ID that triggered this run (for reactions)
        required: false
        type: string
        default: ''
      dry_run:
        description: Run in dry-run mode (log actions without executing)
        required: false
        type: boolean
        default: false
    outputs:
      final_state:
        description: Final state after machine execution
        value: ${{ jobs.derive-actions.outputs.final_state }}
      success:
        description: Whether execution completed successfully
        value: ${{ jobs.exec-state-actions.result == 'success' || jobs.derive-actions.outputs.action_count == '0' }}
      actions_json:
        description: JSON array of actions that were derived
        value: ${{ jobs.derive-actions.outputs.actions_json }}
      action_count:
        description: Number of actions derived
        value: ${{ jobs.derive-actions.outputs.action_count }}

permissions:
  contents: write
  pull-requests: write
  issues: write
  id-token: write

jobs:
  # ============================================================================
  # Phase 1: Derive Actions
  # Runs the state machine to determine what actions to execute
  # ============================================================================
  derive-actions:
    runs-on: ubuntu-latest
    outputs:
      final_state: ${{ steps.machine.outputs.final_state }}
      actions_json: ${{ steps.machine.outputs.actions_json }}
      action_count: ${{ steps.machine.outputs.action_count }}
      actions_matrix: ${{ steps.format.outputs.matrix }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch || 'main' }}
          fetch-depth: 1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Derive Actions (State Machine)
        id: machine
        uses: ./.github/actions-ts/claude-state-machine
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          issue_number: ${{ inputs.issue_number }}
          trigger: ${{ inputs.trigger }}
          ci_result: ${{ inputs.ci_result }}
          ci_run_url: ${{ inputs.ci_run_url }}
          ci_commit_sha: ${{ inputs.ci_commit_sha }}
          review_decision: ${{ inputs.review_decision }}
          reviewer: ${{ inputs.reviewer }}
          comment_context_type: ${{ inputs.comment_context_type }}
          comment_context_description: ${{ inputs.comment_context_description }}
          branch: ${{ inputs.branch }}
          max_retries: ${{ vars.MAX_CLAUDE_RETRIES || '5' }}

      - name: Format Actions Matrix
        id: format
        env:
          ACTIONS_JSON: ${{ steps.machine.outputs.actions_json }}
          ACTION_COUNT: ${{ steps.machine.outputs.action_count }}
        run: |
          if [[ "$ACTION_COUNT" == "0" || -z "$ACTIONS_JSON" || "$ACTIONS_JSON" == "[]" ]]; then
            echo "No actions to execute"
            echo "matrix=[]" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Add index to each action for ordering/identification
          matrix=$(echo "$ACTIONS_JSON" | jq -c '[to_entries | .[] | .value + {index: .key}]')
          echo "matrix=$matrix" >> $GITHUB_OUTPUT
          echo "Formatted matrix with ${ACTION_COUNT} actions"

      - name: Write Derivation Summary
        if: always()
        env:
          FINAL_STATE: ${{ steps.machine.outputs.final_state }}
          ACTION_COUNT: ${{ steps.machine.outputs.action_count }}
          ACTIONS_JSON: ${{ steps.machine.outputs.actions_json }}
          ISSUE_NUMBER: ${{ inputs.issue_number }}
          TRIGGER: ${{ inputs.trigger }}
          DRY_RUN: ${{ inputs.dry_run }}
        run: |
          dry_run_badge=""
          if [[ "$DRY_RUN" == "true" ]]; then
            dry_run_badge=" (DRY RUN)"
          fi

          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Claude State Machine - Derivation${dry_run_badge}

          | Property | Value |
          |----------|-------|
          | **Issue** | [#${ISSUE_NUMBER}](${{ github.server_url }}/${{ github.repository }}/issues/${ISSUE_NUMBER}) |
          | **Trigger** | \`${TRIGGER}\` |
          | **Final State** | \`${FINAL_STATE}\` |
          | **Actions Derived** | ${ACTION_COUNT} |

          ## Actions

          \`\`\`json
          ${ACTIONS_JSON}
          \`\`\`

          ---
          EOF

  # ============================================================================
  # Phase 2: Execute Actions
  # Matrix job that executes each action in isolation with max-parallel: 1
  # ============================================================================
  exec-state-actions:
    needs: [derive-actions]
    if: needs.derive-actions.outputs.action_count != '0' && needs.derive-actions.outputs.actions_matrix != '[]'
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 1
      fail-fast: true
      matrix:
        action: ${{ fromJson(needs.derive-actions.outputs.actions_matrix) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # For branch-dependent actions, checkout the appropriate branch
          ref: ${{ matrix.action.worktree || inputs.branch || 'main' }}
          fetch-depth: 0
          persist-credentials: false

      - name: Configure git for PAT
        env:
          NOPO_BOT_PAT: ${{ secrets.NOPO_BOT_PAT }}
        run: |
          git config --local --unset-all http.https://github.com/.extraheader || true
          git config url."https://${NOPO_BOT_PAT}@github.com/".insteadOf "https://github.com/"
          git config user.name "nopo-bot"
          git config user.email "nopo-bot@users.noreply.github.com"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      # Execute runClaude actions via the run-claude action for rich logging
      # Uses NOPO_BOT_PAT for all Claude runs (needs repo scope for permission checks)
      # CLAUDE_REVIEWER_PAT is used only for post-processing (labels, project fields)
      - name: Run Claude
        if: matrix.action.type == 'runClaude' && !inputs.dry_run
        uses: ./.github/actions/run-claude
        with:
          prompt: ${{ matrix.action.prompt }}
          prompt_file: ${{ matrix.action.promptFile }}
          prompt_replacements: ${{ toJson(matrix.action.promptVars) }}
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          model: "claude-opus-4-5-20251101"
          max_turns: "50"

      - name: Execute Action
        if: matrix.action.type != 'runClaude'
        uses: ./.github/actions-ts/claude-state-executor
        with:
          github_code_token: ${{ secrets.NOPO_BOT_PAT }}
          github_review_token: ${{ secrets.CLAUDE_REVIEWER_PAT }}
          # Wrap single action in array for executor
          actions_json: ${{ format('[{0}]', toJson(matrix.action)) }}
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          dry_run: ${{ inputs.dry_run && 'true' || 'false' }}

      # Post-processing for triage: Apply labels and project fields from triage-output.json
      - name: Apply triage labels and project fields
        if: matrix.action.type == 'runClaude' && inputs.trigger == 'issue_triage' && !inputs.dry_run
        env:
          GH_TOKEN: ${{ secrets.CLAUDE_REVIEWER_PAT }}
          ISSUE_NUMBER: ${{ inputs.issue_number }}
          PROJECT_NUMBER: ${{ vars.PROJECT_NUMBER || '1' }}
        run: |
          if [[ ! -f triage-output.json ]]; then
            echo "No triage-output.json found - skipping triage application"
            exit 0
          fi

          echo "Applying triage from triage-output.json:"
          cat triage-output.json

          # Extract values
          type=$(jq -r '.type // empty' triage-output.json)
          priority=$(jq -r '.priority // empty' triage-output.json)
          size=$(jq -r '.size // empty' triage-output.json)
          estimate=$(jq -r '.estimate // empty' triage-output.json)
          topics=$(jq -r '.topics[]? // empty' triage-output.json)

          # Apply labels
          labels=""
          if [[ -n "$type" && "$type" != "null" ]]; then
            labels="$type"
            echo "Adding type label: $type"
          fi
          for topic in $topics; do
            if [[ -n "$topic" ]]; then
              labels="${labels:+$labels,}topic:$topic"
              echo "Adding topic label: topic:$topic"
            fi
          done
          labels="${labels:+$labels,}triaged"
          echo "Adding triaged label"

          if [[ -n "$labels" ]]; then
            echo "Applying labels: $labels"
            gh issue edit "$ISSUE_NUMBER" --add-label "$labels" || true
          fi

          # Get project fields and item info
          echo "Fetching project fields..."
          PROJECT_INFO=$(gh api graphql -f query='
            query($org: String!, $repo: String!, $issueNumber: Int!, $projectNumber: Int!) {
              repository(owner: $org, name: $repo) {
                issue(number: $issueNumber) {
                  id
                  projectItems(first: 10) {
                    nodes {
                      id
                      project { number }
                    }
                  }
                }
              }
              organization(login: $org) {
                projectV2(number: $projectNumber) {
                  id
                  fields(first: 30) {
                    nodes {
                      ... on ProjectV2SingleSelectField {
                        id
                        name
                        options { id name }
                      }
                      ... on ProjectV2Field {
                        id
                        name
                        dataType
                      }
                    }
                  }
                }
              }
            }
          ' -f org='${{ github.repository_owner }}' -f repo='${{ github.event.repository.name }}' -F issueNumber="$ISSUE_NUMBER" -F projectNumber="$PROJECT_NUMBER")

          PROJECT_ID=$(echo "$PROJECT_INFO" | jq -r '.data.organization.projectV2.id')
          ISSUE_ID=$(echo "$PROJECT_INFO" | jq -r '.data.repository.issue.id')
          ITEM_ID=$(echo "$PROJECT_INFO" | jq -r --argjson pn "$PROJECT_NUMBER" '.data.repository.issue.projectItems.nodes[] | select(.project.number == $pn) | .id')

          # Add to project if not already
          if [[ -z "$ITEM_ID" || "$ITEM_ID" == "null" ]]; then
            echo "Adding issue to project..."
            ITEM_ID=$(gh api graphql -f query='
              mutation($projectId: ID!, $contentId: ID!) {
                addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                  item { id }
                }
              }
            ' -f projectId="$PROJECT_ID" -f contentId="$ISSUE_ID" --jq '.data.addProjectV2ItemById.item.id')
          fi

          echo "Project ID: $PROJECT_ID"
          echo "Item ID: $ITEM_ID"

          # Update Priority field (single select)
          if [[ -n "$priority" && "$priority" != "null" ]]; then
            PRIORITY_FIELD_ID=$(echo "$PROJECT_INFO" | jq -r '.data.organization.projectV2.fields.nodes[] | select(.name == "Priority") | .id')
            PRIORITY_OPTION_ID=$(echo "$PROJECT_INFO" | jq -r --arg p "$priority" '.data.organization.projectV2.fields.nodes[] | select(.name == "Priority") | .options[]? | select(.name | ascii_downcase == ($p | ascii_downcase)) | .id')

            if [[ -n "$PRIORITY_FIELD_ID" && -n "$PRIORITY_OPTION_ID" && "$PRIORITY_OPTION_ID" != "null" ]]; then
              echo "Setting Priority to: $priority"
              gh api graphql -f query='
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId, itemId: $itemId, fieldId: $fieldId,
                    value: { singleSelectOptionId: $optionId }
                  }) { projectV2Item { id } }
                }
              ' -f projectId="$PROJECT_ID" -f itemId="$ITEM_ID" -f fieldId="$PRIORITY_FIELD_ID" -f optionId="$PRIORITY_OPTION_ID" || true
            fi
          fi

          # Update Size field (single select)
          if [[ -n "$size" && "$size" != "null" ]]; then
            SIZE_FIELD_ID=$(echo "$PROJECT_INFO" | jq -r '.data.organization.projectV2.fields.nodes[] | select(.name == "Size") | .id')
            SIZE_OPTION_ID=$(echo "$PROJECT_INFO" | jq -r --arg s "$size" '.data.organization.projectV2.fields.nodes[] | select(.name == "Size") | .options[]? | select(.name | ascii_downcase == ($s | ascii_downcase)) | .id')

            if [[ -n "$SIZE_FIELD_ID" && -n "$SIZE_OPTION_ID" && "$SIZE_OPTION_ID" != "null" ]]; then
              echo "Setting Size to: $size"
              gh api graphql -f query='
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId, itemId: $itemId, fieldId: $fieldId,
                    value: { singleSelectOptionId: $optionId }
                  }) { projectV2Item { id } }
                }
              ' -f projectId="$PROJECT_ID" -f itemId="$ITEM_ID" -f fieldId="$SIZE_FIELD_ID" -f optionId="$SIZE_OPTION_ID" || true
            fi
          fi

          # Update Estimate field (number)
          if [[ -n "$estimate" && "$estimate" != "null" ]]; then
            ESTIMATE_FIELD_ID=$(echo "$PROJECT_INFO" | jq -r '.data.organization.projectV2.fields.nodes[] | select(.name == "Estimate") | .id')

            if [[ -n "$ESTIMATE_FIELD_ID" && "$ESTIMATE_FIELD_ID" != "null" ]]; then
              echo "Setting Estimate to: $estimate"
              gh api graphql -f query='
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $estimate: Float!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId, itemId: $itemId, fieldId: $fieldId,
                    value: { number: $estimate }
                  }) { projectV2Item { id } }
                }
              ' -f projectId="$PROJECT_ID" -f itemId="$ITEM_ID" -f fieldId="$ESTIMATE_FIELD_ID" -F estimate="$estimate" || true
            fi
          fi

          echo "Triage fields applied successfully"

      # Upload triage output artifact for debugging
      - name: Upload triage output
        if: matrix.action.type == 'runClaude' && inputs.trigger == 'issue_triage' && !inputs.dry_run
        uses: actions/upload-artifact@v4
        with:
          name: claude-triage-output
          path: triage-output.json
          retention-days: 1
          if-no-files-found: ignore

      - name: Write Action Summary
        if: always()
        env:
          ACTION_TYPE: ${{ matrix.action.type }}
          ACTION_INDEX: ${{ matrix.action.index }}
          ISSUE_NUMBER: ${{ inputs.issue_number }}
          DRY_RUN: ${{ inputs.dry_run }}
        run: |
          dry_run_badge=""
          if [[ "$DRY_RUN" == "true" ]]; then
            dry_run_badge=" (DRY RUN)"
          fi

          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Action ${ACTION_INDEX}: ${ACTION_TYPE}${dry_run_badge}

          | Property | Value |
          |----------|-------|
          | **Issue** | [#${ISSUE_NUMBER}](${{ github.server_url }}/${{ github.repository }}/issues/${ISSUE_NUMBER}) |
          | **Action Type** | \`${ACTION_TYPE}\` |
          | **Index** | ${ACTION_INDEX} |

          ---
          EOF
