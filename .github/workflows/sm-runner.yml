name: Claude Runner

# Reusable workflow that runs the Claude state machine for an issue.
# Architecture:
# 1. derive-actions: Runs state machine to derive actions, formats as matrix
# 2. exec-state-actions: Matrix job (max-parallel: 1) executes each action in isolation
#
# Two-token architecture:
# - github_code_token (NOPO_BOT_PAT): For code operations (push, PR, project fields)
# - github_review_token (CLAUDE_REVIEWER_PAT): For review operations (submit reviews)

on:
  workflow_call:
    inputs:
      context_json:
        description: |
          Unified JSON context from detect-event containing all routing and resource info.
          Includes: job, trigger, resource_type, resource_number, parent_issue, comment_id,
          concurrency_group, cancel_in_progress, skip, skip_reason, plus context-specific
          fields (issue_number, branch_name, ci_result, etc.)
        required: true
        type: string
      dry_run:
        description: Run in dry-run mode (log actions without executing)
        required: false
        type: boolean
        default: false
      continue:
        description: Continue to next state (true) or stop after this iteration (false)
        required: false
        type: boolean
        default: true
    outputs:
      final_state:
        description: Final state after machine execution
        value: ${{ jobs.derive-actions.outputs.final_state }}
      success:
        description: Whether execution completed successfully
        value: ${{ jobs.exec-state-actions.result == 'success' || jobs.derive-actions.outputs.action_count == '0' }}
      actions_json:
        description: JSON array of actions that were derived
        value: ${{ jobs.derive-actions.outputs.actions_json }}
      action_count:
        description: Number of actions derived
        value: ${{ jobs.derive-actions.outputs.action_count }}

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write  # Required for gh workflow run (retrigger)
  id-token: write

# Extract commonly used fields from context_json for readability
# These are available as: ${{ fromJson(inputs.context_json).field_name }}
# Or use the ctx alias defined in env blocks

jobs:
  # ============================================================================
  # Phase 0: E2E MODE DETECTION
  # Parses e2e marker from PR head commit or config file to enable test instrumentation
  # Security: Only honors e2e markers when the referenced workflow is actually running
  # ============================================================================
  e2e-detect:
    runs-on: ubuntu-latest
    outputs:
      e2e_mode: ${{ steps.detect.outputs.e2e_mode }}
      ci_outcome: ${{ steps.detect.outputs.ci_outcome }}
      release_outcome: ${{ steps.detect.outputs.release_outcome }}
      review_outcome: ${{ steps.detect.outputs.review_outcome }}
    steps:
      - name: Checkout for config file
        uses: actions/checkout@v4
        with:
          ref: ${{ fromJson(inputs.context_json).branch_name || 'main' }}
          sparse-checkout: .github/e2e-test-config.json
          sparse-checkout-cone-mode: false
        continue-on-error: true

      - name: Get PR head commit
        id: commit
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
          BRANCH: ${{ fromJson(inputs.context_json).branch_name }}
        run: |
          # Try to get commit message from PR associated with the issue
          if [[ -n "$BRANCH" ]]; then
            # If we have a branch, get the head commit from it
            commit_msg=$(gh api repos/${{ github.repository }}/commits/$BRANCH --jq '.commit.message' 2>/dev/null || echo "")
          else
            # Try to find PR for this issue
            prs=$(gh pr list --repo ${{ github.repository }} --state all --limit 5 --json number,headRefName,body --jq ".[] | select(.body | contains(\"#$ISSUE_NUMBER\"))")
            if [[ -n "$prs" ]]; then
              branch=$(echo "$prs" | jq -r '.headRefName' | head -1)
              if [[ -n "$branch" && "$branch" != "null" ]]; then
                commit_msg=$(gh api repos/${{ github.repository }}/commits/$branch --jq '.commit.message' 2>/dev/null || echo "")
              fi
            fi
          fi

          echo "message<<EOF" >> $GITHUB_OUTPUT
          echo "${commit_msg:-}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Detect E2E mode
        id: detect
        env:
          GH_TOKEN: ${{ github.token }}
          COMMIT_MSG: ${{ steps.commit.outputs.message }}
        run: |
          e2e_mode=false
          run_id=""
          ci_outcome="success"
          release_outcome="success"
          review_outcome="approved"

          # Method 1: Check for e2e config file
          if [[ -f ".github/e2e-test-config.json" ]]; then
            echo "Found .github/e2e-test-config.json"
            config=$(cat .github/e2e-test-config.json)
            run_id=$(echo "$config" | jq -r '.run_id // empty')
            iteration=$(echo "$config" | jq -r '.iteration // 0')

            if [[ -n "$run_id" ]]; then
              # Get outcomes for current iteration (default to last if past array length)
              ci_outcome=$(echo "$config" | jq -r --argjson i "$iteration" '.outcomes.ci[$i] // .outcomes.ci[-1] // "success"')
              release_outcome=$(echo "$config" | jq -r --argjson i "$iteration" '.outcomes.release[$i] // .outcomes.release[-1] // "success"')
              review_outcome=$(echo "$config" | jq -r --argjson i "$iteration" '.outcomes.review[$i] // .outcomes.review[-1] // "approved"')

              echo "Config file: run_id=$run_id, iteration=$iteration, ci=$ci_outcome, release=$release_outcome, review=$review_outcome"
            fi
          fi

          # Method 2: Check commit message for marker pattern (fallback)
          if [[ -z "$run_id" && "$COMMIT_MSG" =~ \[e2e:([0-9]+):ci=(success|failure):release=(success|failure):review=(approved|changes_requested|comment)\] ]]; then
            run_id="${BASH_REMATCH[1]}"
            ci_outcome="${BASH_REMATCH[2]}"
            release_outcome="${BASH_REMATCH[3]}"
            review_outcome="${BASH_REMATCH[4]}"
            echo "Found e2e marker in commit: run_id=$run_id, ci=$ci_outcome, release=$release_outcome, review=$review_outcome"
          fi

          # Verify the workflow is actually running
          if [[ -n "$run_id" ]]; then
            status=$(gh api repos/${{ github.repository }}/actions/runs/$run_id --jq '.status' 2>/dev/null || echo "not_found")

            if [[ "$status" == "in_progress" ]]; then
              echo "::notice::E2E mode verified - workflow $run_id is running"
              e2e_mode=true
            else
              echo "::warning::E2E marker found but workflow $run_id is not running (status: $status)"
            fi
          else
            echo "No e2e marker found"
          fi

          echo "e2e_mode=$e2e_mode" >> $GITHUB_OUTPUT
          echo "ci_outcome=$ci_outcome" >> $GITHUB_OUTPUT
          echo "release_outcome=$release_outcome" >> $GITHUB_OUTPUT
          echo "review_outcome=$review_outcome" >> $GITHUB_OUTPUT

  # ============================================================================
  # Phase 0a: Derive Context
  # Fetches issue context (iteration, phase) for use in logging
  # ============================================================================
  derive-context:
    needs: [e2e-detect]
    runs-on: ubuntu-latest
    outputs:
      iteration: ${{ steps.context.outputs.iteration }}
      phase: ${{ steps.context.outputs.phase }}
      parent_issue_number: ${{ steps.context.outputs.parent_issue_number }}
      sub_issue_number: ${{ steps.context.outputs.sub_issue_number }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Fetch Context
        id: context
        uses: ./.github/statemachine/actions-ts/router
        with:
          mode: context
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          context_json: ${{ inputs.context_json }}

  # ============================================================================
  # Phase 0b: Log Run Start
  # Appends history entry with loading emoji and workflow link
  # ============================================================================
  log-run-start:
    needs: [derive-context]
    # Skip for merge-queue-logging and discussion jobs (discussions don't have issue history)
    if: ${{ fromJson(inputs.context_json).job != 'merge-queue-logging' && !startsWith(fromJson(inputs.context_json).job, 'discussion-') }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Append history entry
        uses: ./.github/statemachine/issue/actions-ts/executor
        with:
          github_code_token: ${{ secrets.NOPO_BOT_PAT }}
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          actions_json: |
            [{
              "type": "appendHistory",
              "issueNumber": ${{ needs.derive-context.outputs.parent_issue_number || fromJson(inputs.context_json).parent_issue || fromJson(inputs.context_json).issue_number }},
              "iteration": ${{ needs.derive-context.outputs.iteration || 0 }},
              "phase": "${{ needs.derive-context.outputs.phase || '-' }}",
              "message": "⏳ running...",
              "runLink": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }]
          dry_run: ${{ inputs.dry_run && 'true' || 'false' }}

  # ============================================================================
  # Phase 1: Derive Actions
  # Runs the state machine to determine what actions to execute
  # ============================================================================
  derive-actions:
    needs: [e2e-detect, log-run-start, derive-context]
    # Run even if log-run-start was skipped (e.g., for discussions)
    if: ${{ !cancelled() && !failure() }}
    runs-on: ubuntu-latest
    outputs:
      final_state: ${{ steps.machine.outputs.final_state }}
      transition_name: ${{ steps.machine.outputs.transition_name }}
      actions_json: ${{ steps.machine.outputs.actions_json }}
      action_count: ${{ steps.machine.outputs.action_count }}
      actions_matrix: ${{ steps.format.outputs.matrix }}
      iteration: ${{ steps.machine.outputs.iteration }}
      phase: ${{ steps.machine.outputs.phase }}
      parent_issue_number: ${{ steps.machine.outputs.parent_issue_number }}
      pr_number: ${{ steps.machine.outputs.pr_number }}
      commit_sha: ${{ steps.machine.outputs.commit_sha }}
      agent_notes: ${{ steps.machine.outputs.agent_notes }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Always checkout main for router - it's infrastructure code
          # The exec-state-actions job uses the appropriate branch for code operations
          ref: main
          fetch-depth: 1

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Derive Actions (State Machine Router)
        id: machine
        uses: ./.github/statemachine/actions-ts/router
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          context_json: ${{ inputs.context_json }}
          max_retries: ${{ vars.MAX_CLAUDE_RETRIES || '5' }}

      - name: Format Actions Matrix
        id: format
        env:
          ACTIONS_JSON: ${{ steps.machine.outputs.actions_json }}
          ACTION_COUNT: ${{ steps.machine.outputs.action_count }}
        run: |
          if [[ "$ACTION_COUNT" == "0" || -z "$ACTIONS_JSON" || "$ACTIONS_JSON" == "[]" ]]; then
            echo "No actions to execute"
            echo "matrix=[]" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Add index to each action for ordering/identification
          # Note: jq -c produces compact single-line JSON with properly escaped characters
          matrix=$(printf '%s' "$ACTIONS_JSON" | jq -c '[to_entries | .[] | .value + {index: .key}]')

          if [[ -z "$matrix" || "$matrix" == "[]" || "$matrix" == "null" ]]; then
            echo "::error::Failed to format matrix from ACTIONS_JSON"
            echo "matrix=[]" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Debug: show matrix info and verify it's valid JSON
          echo "Matrix length: ${#matrix}"
          echo "First 200 chars: ${matrix:0:200}"

          # Verify jq can parse the output (catches any escaping issues)
          # CRITICAL: Use printf instead of echo to avoid escape sequence interpretation
          if ! printf '%s' "$matrix" | jq -e 'length' > /dev/null 2>&1; then
            echo "::error::Matrix is not valid JSON"
            echo "matrix=[]" >> $GITHUB_OUTPUT
            exit 1
          fi

          # CRITICAL: Use printf instead of echo to avoid escape sequence interpretation
          # echo interprets \r\n as actual CR LF, breaking the JSON
          # printf '%s' preserves the literal backslash sequences
          # Note: Use simple assignment since jq -c guarantees single-line output
          # and the JSON escape sequences (like \r\n) are preserved
          printf 'matrix=%s\n' "$matrix" >> $GITHUB_OUTPUT

          # Debug: verify the output was written correctly
          echo "Formatted matrix with ${ACTION_COUNT} actions"
          echo "Matrix preview (first 100 chars): ${matrix:0:100}"

      - name: Write Derivation Summary
        if: always()
        env:
          FINAL_STATE: ${{ steps.machine.outputs.final_state }}
          TRANSITION_NAME: ${{ steps.machine.outputs.transition_name }}
          ACTION_COUNT: ${{ steps.machine.outputs.action_count }}
          ACTIONS_JSON: ${{ steps.machine.outputs.actions_json }}
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
          TRIGGER: ${{ fromJson(inputs.context_json).trigger }}
          DRY_RUN: ${{ inputs.dry_run }}
        run: |
          dry_run_badge=""
          if [[ "$DRY_RUN" == "true" ]]; then
            dry_run_badge=" (DRY RUN)"
          fi

          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Claude State Machine - ${TRANSITION_NAME}${dry_run_badge}

          | Property | Value |
          |----------|-------|
          | **Issue** | [#${ISSUE_NUMBER}](${{ github.server_url }}/${{ github.repository }}/issues/${ISSUE_NUMBER}) |
          | **Trigger** | \`${TRIGGER}\` |
          | **Transition** | **${TRANSITION_NAME}** |
          | **Final State** | \`${FINAL_STATE}\` |
          | **Actions Derived** | ${ACTION_COUNT} |

          ## Actions

          \`\`\`json
          ${ACTIONS_JSON}
          \`\`\`

          ---
          EOF

  # ============================================================================
  # Phase 2: Execute Actions
  # Matrix job that executes each action in isolation with max-parallel: 1
  # ============================================================================
  exec-state-actions:
    needs: [e2e-detect, derive-actions]
    # always() is required because derive-actions has a custom 'if' condition
    # Without always(), GitHub skips this job even when derive-actions succeeds
    if: ${{ always() && needs.derive-actions.outputs.action_count != '0' && needs.derive-actions.result == 'success' }}
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 1
      fail-fast: true
      matrix:
        action: ${{ fromJson(needs.derive-actions.outputs.actions_matrix || '[]') }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # For branch-dependent actions, checkout the appropriate branch
          ref: ${{ matrix.action.worktree || fromJson(inputs.context_json).branch_name || 'main' }}
          fetch-depth: 0
          persist-credentials: false

      - name: Configure git for PAT
        env:
          NOPO_BOT_PAT: ${{ secrets.NOPO_BOT_PAT }}
        run: |
          git config --local --unset-all http.https://github.com/.extraheader || true
          git config url."https://${NOPO_BOT_PAT}@github.com/".insteadOf "https://github.com/"
          git config user.name "nopo-bot"
          git config user.email "nopo-bot@users.noreply.github.com"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      # ============================================================================
      # E2E Mode: Simulate review submission (skips real Claude run)
      # ============================================================================
      - name: E2E Simulate Review
        id: e2e-review
        if: |
          needs.e2e-detect.outputs.e2e_mode == 'true' &&
          matrix.action.type == 'runClaude' &&
          matrix.action.token == 'review' &&
          !inputs.dry_run
        env:
          GH_TOKEN: ${{ secrets.CLAUDE_REVIEWER_PAT }}
          PR_NUMBER: ${{ matrix.action.promptVars.PR_NUMBER }}
          REVIEW_OUTCOME: ${{ needs.e2e-detect.outputs.review_outcome }}
        run: |
          echo "::notice::E2E mode: simulating review with outcome=$REVIEW_OUTCOME"

          # Map e2e outcome to GitHub event type
          case "$REVIEW_OUTCOME" in
            approved)
              event="APPROVE"
              body="E2E Test: Simulated approval review"
              ;;
            changes_requested)
              event="REQUEST_CHANGES"
              body="E2E Test: Simulated changes requested review"
              ;;
            comment)
              event="COMMENT"
              body="E2E Test: Simulated comment review"
              ;;
            *)
              echo "::error::Unknown review outcome: $REVIEW_OUTCOME"
              exit 1
              ;;
          esac

          # Submit the simulated review
          gh api \
            --method POST \
            "/repos/$GITHUB_REPOSITORY/pulls/$PR_NUMBER/reviews" \
            -f event="$event" \
            -f body="$body"

          echo "✅ E2E simulated review submitted: $event"

      # Merge agent notes into prompt variables
      # Agent notes are now parsed from the issue body during context building
      # and passed through the router output, eliminating the need for a separate fetch
      - name: Prepare prompt variables
        id: prompt-vars
        if: |
          matrix.action.type == 'runClaude' &&
          !inputs.dry_run &&
          needs.e2e-detect.outputs.e2e_mode != 'true'
        env:
          PROMPT_VARS: ${{ toJson(matrix.action.promptVars) }}
          AGENT_NOTES: ${{ needs.derive-actions.outputs.agent_notes }}
        run: |
          # Add AGENT_NOTES to the prompt variables (use -c for compact single-line JSON)
          merged=$(echo "$PROMPT_VARS" | jq -c --arg notes "${AGENT_NOTES:-No previous agent notes found.}" '. + {AGENT_NOTES: $notes}')
          echo "merged=$merged" >> $GITHUB_OUTPUT

      # Install Claude Code for SDK-based execution
      # Also needed for actions that run Claude internally:
      # - applyDiscussionResearchOutput: runs parallel investigations
      # - runClaudeGrooming: runs 4 parallel grooming agents
      # - applyGroomingOutput: runs summary agent
      - name: Install Claude Code
        if: |
          (matrix.action.type == 'runClaude' || matrix.action.type == 'applyDiscussionResearchOutput' || matrix.action.type == 'runClaudeGrooming' || matrix.action.type == 'applyGroomingOutput') &&
          !inputs.dry_run &&
          needs.e2e-detect.outputs.e2e_mode != 'true'
        run: |
          curl -fsSL https://claude.ai/install.sh | bash
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      # Execute runClaude actions via the TypeScript action for SDK-based execution
      # Uses NOPO_BOT_PAT for all Claude runs (needs repo scope for permission checks)
      # CLAUDE_REVIEWER_PAT is used only for post-processing (labels, project fields)
      # Agent notes are injected via AGENT_NOTES prompt variable
      # Skip in e2e mode - e2e-review step handles review actions
      - name: Run Claude
        id: run-claude
        if: |
          matrix.action.type == 'runClaude' &&
          !inputs.dry_run &&
          needs.e2e-detect.outputs.e2e_mode != 'true'
        uses: ./.github/statemachine/shared/actions-ts/claude
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        with:
          prompt: ${{ matrix.action.prompt }}
          prompt_file: ${{ matrix.action.promptFile }}
          prompt_dir: ${{ matrix.action.promptDir }}
          prompts_base: ${{ matrix.action.promptsBase }}
          prompt_vars: ${{ steps.prompt-vars.outputs.merged || toJson(matrix.action.promptVars) }}

      # Note: Review submission is now handled by the applyReviewOutput action in the executor
      # The state machine emits [runClaude, applyReviewOutput] for review flows

      # Upload artifact if action produces one (runs after runClaude, only for runClaude type)
      # For executor-handled actions (runClaudeGrooming), upload happens AFTER Execute Action
      - name: Upload artifact (runClaude)
        if: matrix.action.type == 'runClaude' && matrix.action.producesArtifact && !inputs.dry_run
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.action.producesArtifact.name }}
          path: ${{ matrix.action.producesArtifact.path }}
          retention-days: 1
          if-no-files-found: error

      # Note: Agent notes are now stored in the issue body by applyIterateOutput
      # No longer need to upload them as artifacts

      # Download artifact if action consumes one (runs before executor)
      # Note: path: . extracts to current directory so the file path matches what the executor expects
      - name: Download artifact
        if: matrix.action.consumesArtifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.action.consumesArtifact.name }}
          path: .

      - name: Execute Action
        id: execute
        if: matrix.action.type != 'runClaude'
        uses: ./.github/statemachine/issue/actions-ts/executor
        # OAuth token needed for actions that run Claude internally (runClaudeGrooming, applyDiscussionResearchOutput)
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        with:
          github_code_token: ${{ secrets.NOPO_BOT_PAT }}
          github_review_token: ${{ secrets.CLAUDE_REVIEWER_PAT }}
          # Wrap single action in array for executor
          actions_json: ${{ format('[{0}]', toJson(matrix.action)) }}
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          dry_run: ${{ inputs.dry_run && 'true' || 'false' }}

      # Upload artifact for executor-handled actions (runs AFTER Execute Action creates the file)
      - name: Upload artifact (executor)
        if: matrix.action.type != 'runClaude' && matrix.action.producesArtifact && !inputs.dry_run
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.action.producesArtifact.name }}
          path: ${{ matrix.action.producesArtifact.path }}
          retention-days: 1
          if-no-files-found: error

      - name: Write Action Summary
        if: always()
        env:
          ACTION_TYPE: ${{ matrix.action.type }}
          ACTION_INDEX: ${{ matrix.action.index }}
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
          DRY_RUN: ${{ inputs.dry_run }}
        run: |
          dry_run_badge=""
          if [[ "$DRY_RUN" == "true" ]]; then
            dry_run_badge=" (DRY RUN)"
          fi

          cat >> $GITHUB_STEP_SUMMARY << EOF
          # Action ${ACTION_INDEX}: ${ACTION_TYPE}${dry_run_badge}

          | Property | Value |
          |----------|-------|
          | **Issue** | [#${ISSUE_NUMBER}](${{ github.server_url }}/${{ github.repository }}/issues/${ISSUE_NUMBER}) |
          | **Action Type** | \`${ACTION_TYPE}\` |
          | **Index** | ${ACTION_INDEX} |

          ---
          EOF

  # ============================================================================
  # Phase 3: Log Run End
  # Updates history entry with outcome
  # Uses the log-run-end action for outcome determination and history update
  # ============================================================================
  log-run-end:
    needs: [e2e-detect, derive-context, log-run-start, derive-actions, exec-state-actions]
    # Skip for merge-queue-logging and discussion jobs (discussions don't have issue history)
    if: ${{ always() && fromJson(inputs.context_json).job != 'merge-queue-logging' && !startsWith(fromJson(inputs.context_json).job, 'discussion-') }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Log run end
        uses: ./.github/statemachine/shared/actions-ts/log-run-end
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          issue_number: ${{ needs.derive-context.outputs.parent_issue_number || fromJson(inputs.context_json).parent_issue || fromJson(inputs.context_json).issue_number }}
          derive_result: ${{ needs.derive-actions.result }}
          exec_result: ${{ needs.exec-state-actions.result }}
          action_count: ${{ needs.derive-actions.outputs.action_count }}
          transition_name: ${{ needs.derive-actions.outputs.transition_name }}
          iteration: ${{ needs.derive-context.outputs.iteration || 0 }}
          phase: ${{ needs.derive-context.outputs.phase || '-' }}
          sub_issue_number: ${{ needs.derive-context.outputs.sub_issue_number }}
          pr_number: ${{ needs.derive-actions.outputs.pr_number }}
          commit_sha: ${{ needs.derive-actions.outputs.commit_sha || fromJson(inputs.context_json).ci_commit_sha }}
          run_url: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          dry_run: ${{ inputs.dry_run && 'true' || 'false' }}

  # ============================================================================
  # Phase 4: Check and Retrigger
  # If not in terminal state and didn't run Claude, retrigger to continue loop
  # NOTE: Requires NOPO_BOT_PAT to have 'actions:write' scope for workflow_dispatch
  # ============================================================================
  check-retrigger:
    needs: [e2e-detect, derive-actions, exec-state-actions, log-run-end]
    if: |
      always() &&
      needs.exec-state-actions.result == 'success' &&
      !inputs.dry_run
    runs-on: ubuntu-latest
    steps:
      - name: Check if should continue
        id: check
        env:
          FINAL_STATE: ${{ needs.derive-actions.outputs.final_state }}
          ACTIONS_JSON: ${{ needs.derive-actions.outputs.actions_json }}
        run: |
          # Don't retrigger if we just ran Claude (waiting for push → CI)
          if echo "$ACTIONS_JSON" | jq -e 'map(select(.type == "runClaude")) | length > 0' > /dev/null 2>&1; then
            echo "Ran runClaude, waiting for CI completion"
            echo "should_retrigger=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Don't retrigger for terminal states or states waiting for external events
          # - reviewing: waiting for pull_request_review:submitted event
          # - triaged: waiting for issues:assigned event (orchestrate assigns sub-issue)
          # - orchestrationRunning: waiting for issues:assigned event (sub-issue iteration)
          # - orchestrationWaiting: waiting for pull_request_review:submitted event
          # - orchestrationComplete: all phases done, no more work needed
          # - grooming: waiting for human to answer questions and remove needs-info label
          case "$FINAL_STATE" in
            done|blocked|error|alreadyDone|alreadyBlocked|terminal|reviewing|triaged|orchestrationRunning|orchestrationWaiting|orchestrationComplete|grooming)
              echo "Terminal/waiting state: $FINAL_STATE, no retrigger needed"
              echo "should_retrigger=false" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "Non-terminal state: $FINAL_STATE, will retrigger"
              echo "should_retrigger=true" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Retrigger workflow
        if: steps.check.outputs.should_retrigger == 'true'
        env:
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
          CONTINUE: ${{ inputs.continue }}
        run: |
          if [[ "$CONTINUE" == "true" ]]; then
            echo "Retriggering workflow for issue #${ISSUE_NUMBER}"
            gh workflow run sm-trigger.yml \
              --repo "$REPO" \
              -f action=auto \
              -f resource_number="$ISSUE_NUMBER"
          else
            echo "::notice::Would retrigger workflow for issue #${ISSUE_NUMBER} (continue=false, skipped)"
            echo "To continue, manually dispatch with: gh workflow run sm-trigger.yml -f action=auto -f resource_number=$ISSUE_NUMBER"
          fi
