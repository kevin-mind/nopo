name: Claude Runner

# Reusable workflow that runs the Claude state machine for an issue.
# Architecture: Single action (sm-run) performs the complete cycle:
#   1. Derive actions via state machine transition
#   2. Log run start (history entry)
#   3. Execute derived actions sequentially
#   4. Log run end (update history with outcome)
#   5. Determine retrigger decision
#
# Two-token architecture:
# - github_code_token (NOPO_BOT_PAT): For code operations (push, PR, project fields)
# - github_review_token (CLAUDE_REVIEWER_PAT): For review operations (submit reviews)

on:
  workflow_call:
    inputs:
      context_json:
        description: |
          Unified JSON context from the detect step containing all routing and resource info.
          Includes: job, trigger, resource_type, resource_number, parent_issue, comment_id,
          concurrency_group, cancel_in_progress, skip, skip_reason, plus context-specific
          fields (issue_number, branch_name, ci_result, etc.)
        required: true
        type: string
      dry_run:
        description: Run in dry-run mode (log actions without executing)
        required: false
        type: boolean
        default: false
      continue:
        description: Continue to next state (true) or stop after this iteration (false)
        required: false
        type: boolean
        default: true
      expected_state_json:
        description: Predicted post-run state JSON from sm-plan (for verification)
        required: false
        type: string
        default: ''
    outputs:
      final_state:
        description: Final state after machine execution
        value: ${{ jobs.run.outputs.final_state }}
      success:
        description: Whether execution completed successfully
        value: ${{ jobs.run.outputs.success }}
      actions_json:
        description: JSON array of actions that were derived
        value: ${{ jobs.run.outputs.actions_json }}
      action_count:
        description: Number of actions derived
        value: ${{ jobs.run.outputs.action_count }}

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write  # Required for gh workflow run (retrigger)
  id-token: write

jobs:
  # ============================================================================
  # E2E MODE DETECTION
  # Parses e2e marker from PR head commit or config file to enable test instrumentation
  # Security: Only honors e2e markers when the referenced workflow is actually running
  # ============================================================================
  e2e-detect:
    runs-on: ubuntu-latest
    outputs:
      e2e_mode: ${{ steps.detect.outputs.e2e_mode }}
      ci_outcome: ${{ steps.detect.outputs.ci_outcome }}
      release_outcome: ${{ steps.detect.outputs.release_outcome }}
      review_outcome: ${{ steps.detect.outputs.review_outcome }}
    steps:
      - name: Checkout for config file
        uses: actions/checkout@v4
        with:
          ref: ${{ fromJson(inputs.context_json).branch_name || 'main' }}
          sparse-checkout: .github/e2e-test-config.json
          sparse-checkout-cone-mode: false
        continue-on-error: true

      - name: Get PR head commit
        id: commit
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ fromJson(inputs.context_json).issue_number }}
          BRANCH: ${{ fromJson(inputs.context_json).branch_name }}
        run: |
          # Try to get commit message from PR associated with the issue
          if [[ -n "$BRANCH" ]]; then
            # If we have a branch, get the head commit from it
            commit_msg=$(gh api repos/${{ github.repository }}/commits/$BRANCH --jq '.commit.message' 2>/dev/null || echo "")
          else
            # Try to find PR for this issue
            prs=$(gh pr list --repo ${{ github.repository }} --state all --limit 5 --json number,headRefName,body --jq ".[] | select(.body | contains(\"#$ISSUE_NUMBER\"))")
            if [[ -n "$prs" ]]; then
              branch=$(echo "$prs" | jq -r '.headRefName' | head -1)
              if [[ -n "$branch" && "$branch" != "null" ]]; then
                commit_msg=$(gh api repos/${{ github.repository }}/commits/$branch --jq '.commit.message' 2>/dev/null || echo "")
              fi
            fi
          fi

          echo "message<<EOF" >> $GITHUB_OUTPUT
          echo "${commit_msg:-}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Detect E2E mode
        id: detect
        env:
          GH_TOKEN: ${{ github.token }}
          COMMIT_MSG: ${{ steps.commit.outputs.message }}
        run: |
          e2e_mode=false
          run_id=""
          ci_outcome="success"
          release_outcome="success"
          review_outcome="approved"

          # Method 1: Check for e2e config file
          if [[ -f ".github/e2e-test-config.json" ]]; then
            echo "Found .github/e2e-test-config.json"
            config=$(cat .github/e2e-test-config.json)
            run_id=$(echo "$config" | jq -r '.run_id // empty')
            iteration=$(echo "$config" | jq -r '.iteration // 0')

            if [[ -n "$run_id" ]]; then
              # Get outcomes for current iteration (default to last if past array length)
              ci_outcome=$(echo "$config" | jq -r --argjson i "$iteration" '.outcomes.ci[$i] // .outcomes.ci[-1] // "success"')
              release_outcome=$(echo "$config" | jq -r --argjson i "$iteration" '.outcomes.release[$i] // .outcomes.release[-1] // "success"')
              review_outcome=$(echo "$config" | jq -r --argjson i "$iteration" '.outcomes.review[$i] // .outcomes.review[-1] // "approved"')

              echo "Config file: run_id=$run_id, iteration=$iteration, ci=$ci_outcome, release=$release_outcome, review=$review_outcome"
            fi
          fi

          # Method 2: Check commit message for marker pattern (fallback)
          if [[ -z "$run_id" && "$COMMIT_MSG" =~ \[e2e:([0-9]+):ci=(success|failure):release=(success|failure):review=(approved|changes_requested|comment)\] ]]; then
            run_id="${BASH_REMATCH[1]}"
            ci_outcome="${BASH_REMATCH[2]}"
            release_outcome="${BASH_REMATCH[3]}"
            review_outcome="${BASH_REMATCH[4]}"
            echo "Found e2e marker in commit: run_id=$run_id, ci=$ci_outcome, release=$release_outcome, review=$review_outcome"
          fi

          # Verify the workflow is actually running
          if [[ -n "$run_id" ]]; then
            status=$(gh api repos/${{ github.repository }}/actions/runs/$run_id --jq '.status' 2>/dev/null || echo "not_found")

            if [[ "$status" == "in_progress" ]]; then
              echo "::notice::E2E mode verified - workflow $run_id is running"
              e2e_mode=true
            else
              echo "::warning::E2E marker found but workflow $run_id is not running (status: $status)"
            fi
          else
            echo "No e2e marker found"
          fi

          echo "e2e_mode=$e2e_mode" >> $GITHUB_OUTPUT
          echo "ci_outcome=$ci_outcome" >> $GITHUB_OUTPUT
          echo "release_outcome=$release_outcome" >> $GITHUB_OUTPUT
          echo "review_outcome=$review_outcome" >> $GITHUB_OUTPUT

  # ============================================================================
  # UNIFIED RUN
  # Single job that derives actions, executes them, and logs the outcome
  # ============================================================================
  run:
    needs: [e2e-detect]
    runs-on: ubuntu-latest
    outputs:
      final_state: ${{ steps.sm.outputs.final_state }}
      success: ${{ steps.sm.outputs.success }}
      actions_json: ${{ steps.sm.outputs.actions_json }}
      action_count: ${{ steps.sm.outputs.action_count }}
      transition_name: ${{ steps.sm.outputs.transition_name }}
      should_retrigger: ${{ steps.sm.outputs.should_retrigger }}
      issue_number: ${{ steps.sm.outputs.issue_number }}
      retrigger_resource_number: ${{ steps.sm.outputs.retrigger_resource_number }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Checkout main for the action infrastructure code
          # sm-run will switch branches when needed for execution
          ref: main
          fetch-depth: 0
          persist-credentials: false

      - name: Configure git for PAT
        env:
          NOPO_BOT_PAT: ${{ secrets.NOPO_BOT_PAT }}
        run: |
          git config --local --unset-all http.https://github.com/.extraheader || true
          git config url."https://${NOPO_BOT_PAT}@github.com/".insteadOf "https://github.com/"
          git config user.name "nopo-bot"
          git config user.email "nopo-bot@users.noreply.github.com"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      # Install Claude Code CLI for SDK-based execution
      # Only needed when not in E2E mode and not dry-running
      - name: Install Claude Code
        if: |
          needs.e2e-detect.outputs.e2e_mode != 'true' &&
          !inputs.dry_run
        run: |
          curl -fsSL https://claude.ai/install.sh | bash
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Run State Machine
        id: sm
        uses: ./packages/statemachine/actions/sm-run
        env:
          CLAUDE_CODE_OAUTH_TOKEN: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
        with:
          context_json: ${{ inputs.context_json }}
          github_code_token: ${{ secrets.NOPO_BOT_PAT }}
          github_review_token: ${{ secrets.CLAUDE_REVIEWER_PAT }}
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          max_retries: ${{ vars.MAX_CLAUDE_RETRIES || '5' }}
          dry_run: ${{ inputs.dry_run && 'true' || 'false' }}
          continue: ${{ inputs.continue && 'true' || 'false' }}
          e2e_mode: ${{ needs.e2e-detect.outputs.e2e_mode }}
          e2e_review_outcome: ${{ needs.e2e-detect.outputs.review_outcome }}

  # ============================================================================
  # VERIFY STATE CHANGES
  # Compares actual post-run state against predicted outcomes from sm-plan.
  # Only runs when expected_state_json is provided (issue triggers, not discussions).
  # ============================================================================
  verify:
    needs: [run]
    if: |
      needs.run.result == 'success' &&
      inputs.expected_state_json != '' &&
      !inputs.dry_run
    runs-on: ubuntu-latest
    outputs:
      verified: ${{ steps.verify.outputs.verified }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
          sparse-checkout: packages/statemachine/actions/sm-verify
          sparse-checkout-cone-mode: false

      - name: Verify State Changes
        id: verify
        uses: ./packages/statemachine/actions/sm-verify
        with:
          github_token: ${{ secrets.NOPO_BOT_PAT }}
          expected_state_json: ${{ inputs.expected_state_json }}
          project_number: ${{ vars.PROJECT_NUMBER || '1' }}
          actual_should_retrigger: ${{ needs.run.outputs.should_retrigger }}

  # ============================================================================
  # RETRIGGER
  # Dispatches the next iteration if verification passed and sm-run says to retrigger.
  # If verify was skipped (no expected_state_json), retrigger proceeds normally.
  # ============================================================================
  retrigger:
    needs: [run, verify]
    if: |
      always() &&
      !cancelled() &&
      needs.run.result == 'success' &&
      needs.run.outputs.should_retrigger == 'true' &&
      (needs.verify.result == 'success' || needs.verify.result == 'skipped') &&
      !inputs.dry_run
    runs-on: ubuntu-latest
    steps:
      - name: Retrigger workflow
        env:
          GH_TOKEN: ${{ secrets.NOPO_BOT_PAT }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ needs.run.outputs.retrigger_resource_number || needs.run.outputs.issue_number || fromJson(inputs.context_json).issue_number }}
        run: |
          echo "Retriggering workflow for issue #${ISSUE_NUMBER}"
          gh workflow run sm-trigger.yml \
            --repo "$REPO" \
            -f resource_number="$ISSUE_NUMBER"
