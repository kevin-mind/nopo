# This file was auto-generated by github-actions-workflow-ts.
# Do not edit directly. Instead, edit the corresponding .wac.ts file in .github/workflows-ts/
# and run `pnpm run gwf:build` to regenerate this file.
name: Claude Issue Loop
'on':
  issues:
    types:
      - opened
      - edited
      - assigned
      - unlabeled
  issue_comment:
    types:
      - created
  pull_request_review_comment:
    types:
      - created
  workflow_dispatch:
    inputs:
      issue_number:
        description: Issue number to process
        required: true
        type: string
      action:
        description: Action to simulate
        required: true
        type: choice
        options:
          - triage
          - implement
          - respond
concurrency:
  group: claude-issue-${{ github.event.issue.number || github.event.pull_request.number || github.event.inputs.issue_number }}-${{ github.event.action || github.event.inputs.action }}
  cancel-in-progress: false
permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write
defaults:
  run:
    shell: bash
jobs:
  triage-check:
    runs-on: ubuntu-latest
    if: |-
      (github.event_name == 'issues' &&
       (
         ((github.event.action == 'opened' || github.event.action == 'edited') &&
          !contains(github.event.issue.labels.*.name, 'triaged')) ||
         (github.event.action == 'unlabeled' && github.event.label.name == 'triaged')
       )
      ) ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'triage')
    outputs:
      should_triage: ${{ steps.check.outputs.should_triage }}
      issue_number: ${{ steps.check.outputs.issue_number }}
      issue_title: ${{ steps.check.outputs.issue_title }}
      issue_body: ${{ steps.check.outputs.issue_body }}
    steps:
      - id: check
        name: gh api graphql (check sub-issue)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number || github.event.inputs.issue_number }}
        run: |-
          repo_name="${GITHUB_REPOSITORY#*/}"
          owner="${GITHUB_REPOSITORY%/*}"

          result=$(gh api graphql -H "GraphQL-Features: sub_issues" -f query='
            query($owner: String!, $repo: String!, $number: Int!) {
              repository(owner: $owner, name: $repo) {
                issue(number: $number) {
                  title
                  body
                  parent { number }
                }
              }
            }
          ' \
            -F owner="$owner" \
            -F repo="$repo_name" \
            -F number="$ISSUE_NUMBER" 2>/dev/null || echo '{"data":{"repository":{"issue":null}}}')

          issue=$(echo "$result" | jq -r '.data.repository.issue')

          if [[ -z "$issue" || "$issue" == "null" ]]; then
            echo "is_sub_issue=false" >> $GITHUB_OUTPUT
            echo "should_triage=false" >> $GITHUB_OUTPUT
            echo "issue_title=" >> $GITHUB_OUTPUT
            {
              echo 'issue_body<<EOF'
              echo ''
              echo 'EOF'
            } >> $GITHUB_OUTPUT
            exit 0
          fi

          parent=$(echo "$issue" | jq -r '.parent.number // empty')
          title=$(echo "$issue" | jq -r '.title')
          body=$(echo "$issue" | jq -r '.body // ""')

          if [[ -n "$parent" ]]; then
            echo "is_sub_issue=true" >> $GITHUB_OUTPUT
            echo "should_triage=false" >> $GITHUB_OUTPUT
          else
            echo "is_sub_issue=false" >> $GITHUB_OUTPUT
            echo "should_triage=true" >> $GITHUB_OUTPUT
          fi

          echo "issue_title=$title" >> $GITHUB_OUTPUT
          echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
          {
            echo 'issue_body<<EOF'
            echo "$body"
            echo 'EOF'
          } >> $GITHUB_OUTPUT
  triage:
    needs:
      - triage-check
    runs-on: ubuntu-latest
    if: needs.triage-check.outputs.should_triage == 'true'
    concurrency:
      group: claude-triage-${{ needs.triage-check.outputs.issue_number }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4
      - id: bot_comment
        name: gh issue comment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ needs.triage-check.outputs.issue_number }}
          BODY: |-
            ðŸ‘€ **nopo-bot** is triaging this issue...

            [View workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
        run: |-
          comment_url=$(gh issue comment "$ISSUE_NUMBER" --body "$BODY" --repo "$GITHUB_REPOSITORY" 2>&1)
          comment_id=$(echo "$comment_url" | grep -oE '[0-9]+$' || echo "")
          echo "comment_id=$comment_id" >> $GITHUB_OUTPUT
      - uses: anthropics/claude-code-action@v1
        id: claude_triage
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          settings: .claude/settings.json
          prompt: |-
            You are triaging issue #${{ needs.triage-check.outputs.issue_number }}: "${{ needs.triage-check.outputs.issue_title }}"

            Issue body:
            ${{ needs.triage-check.outputs.issue_body }}

            ## Issue Structure
            Issues follow this structure (from task.yml template):
            - **Description**: Brief TLDR of what needs to be done
            - **Details**: Implementation details, affected files, technical requirements
            - **Questions**: Open questions that need answers (checkboxes)
            - **Todo**: Specific tasks to complete (checkboxes)

            ## Your Tasks

            ### 1. ANALYZE AND WRITE TRIAGE OUTPUT
            Analyze the issue and write a JSON file with your triage decisions.
            This file is the SINGLE SOURCE OF TRUTH for labels and project fields.

            **CRITICAL**: You MUST write this file FIRST before any other actions:

            ```bash
            cat > triage-output.json << 'EOF'
            {
              "type": "<bug|enhancement|documentation|refactor|test|chore>",
              "priority": "<low|medium|high|critical|null>",
              "size": "<xs|s|m|l|xl>",
              "estimate": <hours as number: 1, 2, 3, 5, 8, 13, or 21>,
              "topics": ["topic_name_1", "topic_name_2"],
              "needs_info": <true|false>
            }
            EOF
            ```

            **How to determine values:**
            - **type**: Based on issue category (bug fix, new feature, docs update, etc.)
            - **priority**: Extract from "### Priority" section in issue body. If not specified, use `null`
              (Note: priority is only used for project fields, NOT as a label)
            - **size**: Based on scope of work:
              - XS: < 1 hour, single file change
              - S: 1-3 hours, few files
              - M: 3-8 hours, moderate complexity
              - L: 8-21 hours, significant work
              - XL: 21+ hours, major feature/refactor
            - **estimate**: Hours of work (must match size: XS=1, S=2-3, M=5-8, L=13, XL=21)
            - **topics**: 1-3 topic names (lowercase with underscores, e.g., "cli_core", "docker_builds")
              - First check existing topics: `gh label list --search "topic:" --json name --jq '.[].name'`
              - Reuse existing topics when applicable
            - **needs_info**: true if critical information is missing

            ### 2. SEARCH FOR RELATED CONTENT
            - Use `gh issue list` to find similar/related issues
            - Link to related issues in a comment
            - Check if this might be a duplicate

            ### 3. UPDATE THE ISSUE BODY
            Use `gh issue edit ${{ needs.triage-check.outputs.issue_number }} --body "..."` to improve the issue:

            **Description**: Improve clarity if needed, make it a concise TLDR

            **Details**: Expand with technical context:
            - Reference specific files/functions that will be affected
            - Link to relevant internal docs (files in `decisions/`, `nopo/docs/`, READMEs)
            - Link to external documentation (libraries, APIs, standards)
            - Add code snippets or examples if helpful

            **Questions**:
            - If questions exist, research and answer them (check the box and add answer)
            - Add new questions if you identify uncertainties

            **Todo**:
            - Break down vague tasks into specific, actionable items
            - Add missing tasks you identify from analyzing the codebase
            - Each todo should be completable in a single commit

            ### 4. CREATE SUB-ISSUES FOR PHASED WORK
            If the issue is large (Size L or XL) and has distinct implementation phases:
            1. Identify clear phases in the Todo section (e.g., "Phase 1: Setup", "Phase 2: Core Implementation")
            2. Create a sub-issue for each phase using `gh issue create`
            3. Link each new issue as a sub-issue to this parent issue
            4. Each sub-issue should have a focused scope completable in 1-3 days
            5. Sub-issues do NOT need full triage structure - just a clear title and todo list

            **When to create sub-issues:**
            - Work naturally splits into sequential phases
            - Different phases could be assigned to different implementers
            - Total estimated work exceeds 5 days

            **Sub-issue format:**
            - Title: "[Sub] Phase N: <phase description> (parent #${{ needs.triage-check.outputs.issue_number }})"
            - Body: Brief description + specific todo items for that phase

            ### 5. VALIDATE COMPLETENESS
            - If critical info is missing, set `needs_info: true` in the triage output
            - Ask clarifying questions in a comment

            ## Commands
            ```bash
            # STEP 1: Write triage output file (DO THIS FIRST!)
            cat > triage-output.json << 'EOF'
            {
              "type": "enhancement",
              "priority": "medium",
              "size": "m",
              "estimate": 5,
              "topics": ["cli_core", "docker_builds"],
              "needs_info": false
            }
            EOF

            # Verify the file was created correctly
            cat triage-output.json

            # View current issue
            gh issue view ${{ needs.triage-check.outputs.issue_number }}

            # Update issue body (use heredoc for multiline)
            gh issue edit ${{ needs.triage-check.outputs.issue_number }} --body "$(cat <<'EOF'
            ... new body content ...
            EOF
            )"

            # List existing topic labels (to reuse existing topics)
            gh label list --search "topic:" --json name --jq '.[].name'

            # ============================================
            # SUB-ISSUE CREATION (only for L/XL issues)
            # ============================================

            # Step 1: Create a new issue for a phase
            gh issue create --title "[Sub] Phase 1: Setup (parent #${{ needs.triage-check.outputs.issue_number }})" --body "Phase 1 tasks..."

            # Step 2: Get the new issue's ID (from the URL returned by gh issue create)
            gh api graphql -f query='
              query($owner: String!, $repo: String!, $number: Int!) {
                repository(owner: $owner, name: $repo) {
                  issue(number: $number) { id }
                }
              }
            ' -f owner="${GITHUB_REPOSITORY_OWNER}" -f repo="${GITHUB_REPOSITORY#*/}" -F number=NEW_ISSUE_NUMBER

            # Step 3: Link as sub-issue to parent
            gh api graphql -H "GraphQL-Features: sub_issues" -f query='
              mutation($parentId: ID!, $subIssueId: ID!) {
                addSubIssue(input: { issueId: $parentId, subIssueId: $subIssueId }) {
                  issue { title }
                  subIssue { title }
                }
              }
            ' -f parentId="PARENT_ISSUE_ID" -f subIssueId="NEW_ISSUE_ID"
            ```

            IMPORTANT:
            - You MUST write triage-output.json - the workflow step reads your JSON and applies them
            - DO NOT add labels yourself - the workflow step reads your JSON and applies them
            - DO NOT assign the issue to anyone
            - Focus on making the issue clear and actionable for implementation
            - Preserve the issue structure (Description, Details, Questions, Todo sections)
            - Only create sub-issues if the work genuinely requires phased implementation
          claude_args: '--model claude-opus-4-5-20251101 --max-turns 50'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - id: parse
        name: Parse triage output
        run: |-
          # Check if triage output exists
          if [[ ! -f triage-output.json ]]; then
            echo "WARNING: triage-output.json not found"
            echo "has_output=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "has_output=true" >> "$GITHUB_OUTPUT"

          # Parse triage output
          TYPE=$(jq -r '.type // empty' triage-output.json)
          PRIORITY=$(jq -r '.priority // empty' triage-output.json)
          SIZE=$(jq -r '.size // empty' triage-output.json)
          ESTIMATE=$(jq -r '.estimate // 5' triage-output.json)
          NEEDS_INFO=$(jq -r '.needs_info // false' triage-output.json)
          TOPICS=$(jq -r '.topics // [] | join(",")' triage-output.json)

          # Build labels list
          LABELS="triaged"
          [[ -n "$TYPE" && "$TYPE" != "null" ]] && LABELS="$LABELS,$TYPE"
          [[ "$NEEDS_INFO" == "true" ]] && LABELS="$LABELS,needs-info"

          # Output parsed values
          echo "type=$TYPE" >> "$GITHUB_OUTPUT"
          echo "priority=$PRIORITY" >> "$GITHUB_OUTPUT"
          echo "size=$SIZE" >> "$GITHUB_OUTPUT"
          echo "estimate=$ESTIMATE" >> "$GITHUB_OUTPUT"
          echo "needs_info=$NEEDS_INFO" >> "$GITHUB_OUTPUT"
          echo "topics=$TOPICS" >> "$GITHUB_OUTPUT"
          echo "labels=$LABELS" >> "$GITHUB_OUTPUT"

          echo "Parsed: type=$TYPE priority=$PRIORITY size=$SIZE estimate=$ESTIMATE"
      - step:
          name: gh issue edit --add-label
          env:
            GH_TOKEN: ${{ secrets.PROJECT_TOKEN || secrets.GITHUB_TOKEN }}
            ISSUE_NUMBER: ${{ needs.triage-check.outputs.issue_number }}
            LABELS: ${{ steps.parse.outputs.labels }}
          run: gh issue edit "$ISSUE_NUMBER" --add-label "$LABELS" --repo "$GITHUB_REPOSITORY"
        if: steps.parse.outputs.has_output == 'true'
      - step:
          name: Create and apply topic labels
          env:
            GH_TOKEN: ${{ secrets.PROJECT_TOKEN || secrets.GITHUB_TOKEN }}
            ISSUE_NUMBER: ${{ needs.triage-check.outputs.issue_number }}
            TOPICS: ${{ steps.parse.outputs.topics }}
          run: |-
            # Skip if no topics
            [[ -z "$TOPICS" ]] && exit 0

            IFS=',' read -ra TOPIC_ARRAY <<< "$TOPICS"
            for topic in "${TOPIC_ARRAY[@]}"; do
              [[ -z "$topic" ]] && continue
              topic_label="topic:$topic"

              # Create label if it doesn't exist (--force updates if exists)
              gh label create "$topic_label" --color "7057ff" --description "Related to $topic" --repo "$GITHUB_REPOSITORY" --force || true

              # Add label to issue
              gh issue edit "$ISSUE_NUMBER" --add-label "$topic_label" --repo "$GITHUB_REPOSITORY" || true
            done
        if: steps.parse.outputs.has_output == 'true' && steps.parse.outputs.topics != ''
      - id: project
        name: gh api graphql (get project item)
        env:
          GH_TOKEN: ${{ secrets.PROJECT_TOKEN || secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ needs.triage-check.outputs.issue_number }}
        run: |-
          repo_name="${GITHUB_REPOSITORY#*/}"
          owner="${GITHUB_REPOSITORY%/*}"

          result=$(gh api graphql -f query='query($owner: String!, $repo: String!, $number: Int!) {
                repository(owner: $owner, name: $repo) {
                  issue(number: $number) {
                    projectItems(first: 1) {
                      nodes { id project { id } }
                    }
                  }
                }
              }'   -f owner="$owner"   -f repo="$repo_name"   -F number="$ISSUE_NUMBER" 2>/dev/null || echo '{}')

          item_id=$(echo "$result" | jq -r '.data.repository.issue.projectItems.nodes[0].id // empty')
          project_id=$(echo "$result" | jq -r '.data.repository.issue.projectItems.nodes[0].project.id // empty')

          if [[ -z "$item_id" || "$item_id" == "null" ]]; then
            echo "Issue #$ISSUE_NUMBER not linked to any project"
            echo "has_project=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "has_project=true" >> "$GITHUB_OUTPUT"
          echo "item_id=$item_id" >> "$GITHUB_OUTPUT"
          echo "project_id=$project_id" >> "$GITHUB_OUTPUT"
      - step:
          name: gh api graphql (update project priority)
          env:
            GH_TOKEN: ${{ secrets.PROJECT_TOKEN || secrets.GITHUB_TOKEN }}
            PROJECT_ID: ${{ steps.project.outputs.project_id }}
            ITEM_ID: ${{ steps.project.outputs.item_id }}
            PRIORITY: ${{ steps.parse.outputs.priority }}
          run: |-
            # Map priority to option ID
            case "$PRIORITY" in
              critical) OPTION_ID="79628723" ;;  # P0
              high)     OPTION_ID="0a877460" ;;  # P1
              *)        OPTION_ID="da944a9c" ;;  # P2
            esac

            gh api graphql -f query='mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId, itemId: $itemId, fieldId: $fieldId,
                    value: { singleSelectOptionId: $optionId }
                  }) { projectV2Item { id } }
                }'   -f projectId="$PROJECT_ID"   -f itemId="$ITEM_ID"   -f fieldId="PVTSSF_lADOBBYMds4BMB5szg7bd4o"   -f optionId="$OPTION_ID"
        if: steps.project.outputs.has_project == 'true'
      - step:
          name: gh api graphql (update project size)
          env:
            GH_TOKEN: ${{ secrets.PROJECT_TOKEN || secrets.GITHUB_TOKEN }}
            PROJECT_ID: ${{ steps.project.outputs.project_id }}
            ITEM_ID: ${{ steps.project.outputs.item_id }}
            SIZE: ${{ steps.parse.outputs.size }}
          run: |-
            # Map size to option ID
            case "$SIZE" in
              xs) OPTION_ID="6c6483d2" ;;
              s)  OPTION_ID="f784b110" ;;
              m)  OPTION_ID="7515a9f1" ;;
              l)  OPTION_ID="817d0097" ;;
              xl) OPTION_ID="db339eb2" ;;
              *)  OPTION_ID="7515a9f1" ;;  # Default to M
            esac

            gh api graphql -f query='mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId, itemId: $itemId, fieldId: $fieldId,
                    value: { singleSelectOptionId: $optionId }
                  }) { projectV2Item { id } }
                }'   -f projectId="$PROJECT_ID"   -f itemId="$ITEM_ID"   -f fieldId="PVTSSF_lADOBBYMds4BMB5szg7bd4s"   -f optionId="$OPTION_ID"
        if: steps.project.outputs.has_project == 'true'
      - step:
          name: gh api graphql (update project estimate)
          env:
            GH_TOKEN: ${{ secrets.PROJECT_TOKEN || secrets.GITHUB_TOKEN }}
            PROJECT_ID: ${{ steps.project.outputs.project_id }}
            ITEM_ID: ${{ steps.project.outputs.item_id }}
            ESTIMATE: ${{ steps.parse.outputs.estimate }}
          run: |-
            gh api graphql -f query='mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $number: Float!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId, itemId: $itemId, fieldId: $fieldId,
                    value: { number: $number }
                  }) { projectV2Item { id } }
                }'   -f projectId="$PROJECT_ID"   -f itemId="$ITEM_ID"   -f fieldId="PVTF_lADOBBYMds4BMB5szg7bd4w"   -F number="$ESTIMATE"
        if: steps.project.outputs.has_project == 'true'
      - name: gh api (add reaction)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMENT_ID: ${{ steps.bot_comment.outputs.comment_id }}
          REACTION: rocket
        run: gh api "repos/$GITHUB_REPOSITORY/issues/comments/$COMMENT_ID/reactions" -f content="$REACTION"
      - name: gh api (add reaction)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMENT_ID: ${{ steps.bot_comment.outputs.comment_id }}
          REACTION: eyes
        run: gh api "repos/$GITHUB_REPOSITORY/issues/comments/$COMMENT_ID/reactions" -f content="$REACTION"
  implement-check:
    runs-on: ubuntu-latest
    if: |-
      github.event.action == 'assigned' &&
      github.event_name == 'issues' &&
      github.event.assignee.login == 'nopo-bot'
    outputs:
      should_implement: ${{ steps.check_pr.outputs.has_pr == 'false' }}
      issue_title: ${{ github.event.issue.title }}
      issue_body: ${{ steps.issue.outputs.body }}
      issue_comments: ${{ steps.issue.outputs.comments }}
      bot_comment_id: ${{ steps.bot_comment.outputs.comment_id }}
    steps:
      - id: check_triaged
        name: gh issue view (check label)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          LABEL: triaged
        run: |-
          has_label=$(gh issue view "$ISSUE_NUMBER" --repo "$GITHUB_REPOSITORY" --json labels --jq ".labels[].name" | grep -c "^$LABEL$" || true)
          echo "has_label=$([[ "$has_label" -gt 0 ]] && echo "true" || echo "false")" >> $GITHUB_OUTPUT
      - id: check_status
        name: gh api graphql (check project status)
        env:
          GH_TOKEN: ${{ secrets.PROJECT_TOKEN || secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |-
          repo_name="${GITHUB_REPOSITORY#*/}"
          owner="${GITHUB_REPOSITORY%/*}"

          result=$(gh api graphql -f query='
            query($owner: String!, $repo: String!, $issue: Int!) {
              repository(owner: $owner, name: $repo) {
                issue(number: $issue) {
                  projectItems(first: 10) {
                    nodes {
                      fieldValueByName(name: "Status") {
                        ... on ProjectV2ItemFieldSingleSelectValue {
                          name
                        }
                      }
                    }
                  }
                }
              }
            }
          ' \
            -F owner="$owner" \
            -F repo="$repo_name" \
            -F issue="$ISSUE_NUMBER" 2>/dev/null || echo '{}')

          status=$(echo "$result" | jq -r '.data.repository.issue.projectItems.nodes[0].fieldValueByName.name // ""')

          echo "status=$status" >> $GITHUB_OUTPUT

          # Can implement if status is empty, Ready, or Backlog
          if [[ -z "$status" || "$status" == "Ready" || "$status" == "Backlog" ]]; then
            echo "can_implement=true" >> $GITHUB_OUTPUT
          else
            echo "can_implement=false" >> $GITHUB_OUTPUT
          fi
      - id: issue
        name: gh issue view (with comments)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |-
          issue=$(gh issue view "$ISSUE_NUMBER" --repo "$GITHUB_REPOSITORY" --json title,body,labels,comments)
          echo "title=$(echo "$issue" | jq -r '.title')" >> $GITHUB_OUTPUT
          {
            echo 'body<<EOF'
            echo "$issue" | jq -r '.body'
            echo 'EOF'
          } >> $GITHUB_OUTPUT
          echo "labels=$(echo "$issue" | jq -c '[.labels[].name]')" >> $GITHUB_OUTPUT
          {
            echo 'comments<<EOF'
            echo "$issue" | jq -r '.comments[] | "---\nAuthor: \(.author.login)\n\(.body)\n"'
            echo 'EOF'
          } >> $GITHUB_OUTPUT
      - id: bot_comment
        name: gh issue comment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          BODY: |-
            ðŸ‘€ **nopo-bot** is implementing this issue...

            [View workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
        run: |-
          comment_url=$(gh issue comment "$ISSUE_NUMBER" --body "$BODY" --repo "$GITHUB_REPOSITORY" 2>&1)
          comment_id=$(echo "$comment_url" | grep -oE '[0-9]+$' || echo "")
          echo "comment_id=$comment_id" >> $GITHUB_OUTPUT
      - id: check_pr
        name: gh pr list (for issue)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |-
          # Search for PRs that mention "Fixes #N" or "Closes #N"
          prs=$(gh pr list --repo "$GITHUB_REPOSITORY" --state open --json number,headRefName,url,body)

          # Find PR that references this issue
          pr=$(echo "$prs" | jq -r --arg issue "$ISSUE_NUMBER" '
            .[] | select(.body | test("(Fixes|Closes|Resolves) #" + $issue + "([^0-9]|$)"; "i"))
          ' | head -1)

          if [[ -n "$pr" && "$pr" != "null" ]]; then
            echo "has_pr=true" >> $GITHUB_OUTPUT
            echo "pr_number=$(echo "$pr" | jq -r '.number')" >> $GITHUB_OUTPUT
            echo "pr_branch=$(echo "$pr" | jq -r '.headRefName')" >> $GITHUB_OUTPUT
            echo "pr_url=$(echo "$pr" | jq -r '.url')" >> $GITHUB_OUTPUT
          else
            echo "has_pr=false" >> $GITHUB_OUTPUT
            echo "pr_number=" >> $GITHUB_OUTPUT
            echo "pr_branch=" >> $GITHUB_OUTPUT
            echo "pr_url=" >> $GITHUB_OUTPUT
          fi
  implement-update-project:
    needs:
      - implement-check
    if: needs.implement-check.outputs.should_implement == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: gh api graphql (update project status)
        env:
          GH_TOKEN: ${{ secrets.PROJECT_TOKEN || secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          TARGET_STATUS: In progress
        run: |-
          repo_name="${GITHUB_REPOSITORY#*/}"
          owner="${GITHUB_REPOSITORY%/*}"

          # Find the project item
          result=$(gh api graphql -f query='query($owner: String!, $repo: String!, $issue: Int!) {
                repository(owner: $owner, name: $repo) {
                  issue(number: $issue) {
                    projectItems(first: 10) {
                      nodes {
                        id
                        project {
                          id
                          title
                          field(name: "Status") {
                            ... on ProjectV2SingleSelectField {
                              id
                              options { id name }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }'   -F owner="$owner"   -F repo="$repo_name"   -F issue="$ISSUE_NUMBER" 2>/dev/null || echo "{}")

          # Extract project info
          item=$(echo "$result" | jq -r '.data.repository.issue.projectItems.nodes[0] // empty')
          if [[ -z "$item" ]]; then
            echo "No project item found for issue #$ISSUE_NUMBER"
            exit 0
          fi

          item_id=$(echo "$item" | jq -r '.id')
          project_id=$(echo "$item" | jq -r '.project.id')
          field_id=$(echo "$item" | jq -r '.project.field.id')
          option_id=$(echo "$item" | jq -r --arg status "$TARGET_STATUS" '.project.field.options[] | select(.name == $status) | .id')

          if [[ -z "$option_id" ]]; then
            echo "Status '$TARGET_STATUS' not found in project"
            exit 0
          fi

          # Update the status
          gh api graphql -f query='mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $projectId
                  itemId: $itemId
                  fieldId: $fieldId
                  value: { singleSelectOptionId: $optionId }
                }) {
                  projectV2Item { id }
                }
              }'   -F projectId="$project_id"   -F itemId="$item_id"   -F fieldId="$field_id"   -F optionId="$option_id"

          echo "Updated project status to '$TARGET_STATUS'"
  implement:
    needs:
      - implement-check
      - implement-update-project
    if: always() && needs.implement-check.outputs.should_implement == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: git config
        env:
          USER_NAME: Claude Bot
          USER_EMAIL: claude-bot@anthropic.com
        run: |-
          git config --global user.name "$USER_NAME"
          git config --global user.email "$USER_EMAIL"
      - id: branch
        name: git checkout -b (with diff)
        env:
          BRANCH_NAME: claude/issue/${{ github.event.issue.number }}
        run: |-
          existing_branch="false"
          diff=""

          if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
            git checkout "$BRANCH_NAME"
            existing_branch="true"
            diff=$(git diff main.."$BRANCH_NAME" --stat 2>/dev/null || echo "")
          elif git show-ref --verify --quiet "refs/remotes/origin/$BRANCH_NAME"; then
            git checkout -b "$BRANCH_NAME" "origin/$BRANCH_NAME"
            existing_branch="true"
            diff=$(git diff main.."$BRANCH_NAME" --stat 2>/dev/null || echo "")
          else
            git checkout -b "$BRANCH_NAME"
            existing_branch="false"
          fi

          echo "name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "existing_branch=$existing_branch" >> $GITHUB_OUTPUT
          {
            echo 'diff<<EOF'
            echo "$diff"
            echo 'EOF'
          } >> $GITHUB_OUTPUT
      - uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          assignee_trigger: nopo-bot
          settings: .claude/settings.json
          show_full_output: 'true'
          prompt: |-
            Implement issue #${{ github.event.issue.number }}: "${{ needs.implement-check.outputs.issue_title }}"

            ${{ needs.implement-check.outputs.issue_body }}

            You are on branch `${{ steps.branch.outputs.name }}`.
            ${{ steps.branch.outputs.existing_branch == 'true' && format('
            ## âš ï¸ EXISTING BRANCH - Previous work detected

            This branch already has changes from a previous implementation attempt:
            \`\`\`
            {0}
            \`\`\`

            **CRITICAL**: Review what is already done. Do NOT re-implement completed work.
            Start from the CURRENT state of the code and continue toward the goal.
            If an edit fails because the text is not found, the change may already be applied.
            ', steps.branch.outputs.diff) || '' }}

            ## Instructions

            1. Follow CLAUDE.md guidelines strictly
            2. **FIRST: Run `git status` and `git log -3` to understand current branch state**
            3. **Read each file before editing** - the Edit tool requires this
            4. **If an edit fails, re-read the file** - it may already be modified
            5. **Never repeat a failed edit** - if text not found, the change is likely done
            6. Address Todo items that haven't been completed yet
            7. Run `make check` and `make test` - fix any failures
            8. Commit with a descriptive message
            9. Push to origin
            10. Create DRAFT PR with `gh pr create --draft --reviewer nopo-bot`
                - Body MUST contain "Fixes #${{ github.event.issue.number }}"

            If you notice conflicts with other open PRs, note them in the PR description.
          claude_args: '--model claude-opus-4-5-20251101 --max-turns 200'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Salvage partial progress
        if: failure()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          BRANCH_NAME: ${{ steps.branch.outputs.name }}
        run: |-
          # Check if there are uncommitted changes
          if ! git diff --quiet HEAD 2>/dev/null; then
            git add -A
            git commit -m "WIP: Partial implementation progress

          Fixes #$ISSUE_NUMBER" || true
            git push origin "$BRANCH_NAME" || true

            # Create draft PR if it doesn't exist
            existing_pr=$(gh pr list --head "$BRANCH_NAME" --json number --jq '.[0].number')
            if [[ -z "$existing_pr" ]]; then
              gh pr create --draft --title "WIP: Implementation for #$ISSUE_NUMBER"       --body "Fixes #$ISSUE_NUMBER

          **Note**: This is partial progress from an interrupted implementation."       --reviewer nopo-bot || true
            fi
          fi
      - name: gh api (add reaction)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMENT_ID: ${{ needs.implement-check.outputs.bot_comment_id }}
          REACTION: rocket
        run: gh api "repos/$GITHUB_REPOSITORY/issues/comments/$COMMENT_ID/reactions" -f content="$REACTION"
      - name: gh api (add reaction)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMENT_ID: ${{ needs.implement-check.outputs.bot_comment_id }}
          REACTION: eyes
        run: gh api "repos/$GITHUB_REPOSITORY/issues/comments/$COMMENT_ID/reactions" -f content="$REACTION"
      - name: gh issue edit --remove-assignee
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ASSIGNEES: nopo-bot
        run: gh issue edit "$ISSUE_NUMBER" --remove-assignee "$ASSIGNEES" --repo "$GITHUB_REPOSITORY"
  comment:
    runs-on: ubuntu-latest
    if: |-
      (github.event_name == 'issue_comment' || github.event_name == 'pull_request_review_comment') &&
      contains(github.event.comment.body, '@claude') &&
      github.event.comment.user.type != 'Bot'
    steps:
      - id: bot_comment
        name: gh issue comment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
          BODY: |-
            ðŸ‘€ **nopo-bot** is responding to your request...

            [View workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
        run: |-
          comment_url=$(gh issue comment "$ISSUE_NUMBER" --body "$BODY" --repo "$GITHUB_REPOSITORY" 2>&1)
          comment_id=$(echo "$comment_url" | grep -oE '[0-9]+$' || echo "")
          echo "comment_id=$comment_id" >> $GITHUB_OUTPUT
      - id: count_comments
        name: gh api (count comments)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
          USER_LOGIN: claude[bot]
        run: |-
          review_comments=$(gh api "repos/$GITHUB_REPOSITORY/pulls/$PR_NUMBER/comments" --jq "[.[] | select(.user.login == \"$USER_LOGIN\")] | length")
          issue_comments=$(gh api "repos/$GITHUB_REPOSITORY/issues/$PR_NUMBER/comments" --jq "[.[] | select(.user.login == \"$USER_LOGIN\")] | length")
          reviews=$(gh api "repos/$GITHUB_REPOSITORY/pulls/$PR_NUMBER/reviews" --jq "[.[] | select(.user.login == \"$USER_LOGIN\")] | length")
          total=$((review_comments + issue_comments + reviews))
          echo "count=$total" >> $GITHUB_OUTPUT
      - id: check_limit
        name: Check comment limit
        env:
          COMMENT_COUNT: ${{ steps.count_comments.outputs.count }}
          MAX_COMMENTS: '50'
        run: |-
          if [[ "$COMMENT_COUNT" -ge "$MAX_COMMENTS" ]]; then
            echo "exceeded=true" >> $GITHUB_OUTPUT
            echo "Claude has made $COMMENT_COUNT comments (max: $MAX_COMMENTS). Stopping."
          else
            echo "exceeded=false" >> $GITHUB_OUTPUT
          fi
      - id: pr_context
        name: gh pr view (branch)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          IS_PR: ${{ github.event.issue.pull_request != '' }}
          PR_NUMBER: ${{ github.event.issue.number }}
        run: |-
          if [[ "$IS_PR" == "true" ]]; then
            branch=$(gh pr view "$PR_NUMBER" --repo "$GITHUB_REPOSITORY" --json headRefName --jq '.headRefName')
            echo "is_pr=true" >> $GITHUB_OUTPUT
            echo "branch=$branch" >> $GITHUB_OUTPUT
          else
            echo "is_pr=false" >> $GITHUB_OUTPUT
            echo "branch=main" >> $GITHUB_OUTPUT
          fi
      - if: steps.check_limit.outputs.exceeded == 'false'
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.pr_context.outputs.branch }}
          fetch-depth: 0
      - if: steps.check_limit.outputs.exceeded == 'false'
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          settings: .claude/settings.json
          trigger_phrase: '@claude'
          prompt: |-
            You are responding to a question or request in a GitHub ${{ steps.pr_context.outputs.is_pr == 'true' && 'PR' || 'issue' }} comment.

            ${{ steps.pr_context.outputs.is_pr == 'true' && format('This is PR #{0} on branch `{1}`. You are checked out on the PR branch with the code changes.', github.event.issue.number, steps.pr_context.outputs.branch) || format('This is issue #{0}. You are checked out on main.', github.event.issue.number) }}

            ## Your Task

            Read the user's comment carefully and respond ONLY to what they asked.
            DO NOT make unrelated suggestions or analyze unrelated code.

            ## Action Detection

            **If the user's comment contains ACTION WORDS** like:
            - "fix", "implement", "change", "update", "add", "remove", "refactor", "delete"
            - "do it", "make it", "apply", "commit", "push"

            Then **DO IT IMMEDIATELY** - make the code changes and push them. Do NOT ask
            "Would you like me to..." or "Should I..." - the user explicitly asked, so act.

            **If the comment is a QUESTION or ANALYSIS REQUEST** (no action words):
            - Answer the question
            - Explain the code
            - Suggest approaches (let user decide if they want implementation)

            For large-scale implementation (new features), users should:
            - Assign `nopo-bot` to an issue for full implementation

            Focus on:
            - Detecting whether this is an ACTION REQUEST or a QUESTION
            - For actions: implement immediately, commit, and push
            - For questions: provide clear, helpful answers

            ## IMPORTANT: Always Post Your Response

            After completing your analysis, you MUST post your response as a comment:
            ```
            gh issue comment ${{ github.event.issue.number }} --repo "$GITHUB_REPOSITORY" --body "## Response

            <your detailed response to the user's SPECIFIC question/request>"
            ```

            NEVER leave the issue/PR without a visible response - your analysis must be posted as a comment.
          claude_args: '--model claude-opus-4-5-20251101 --max-turns 100'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: gh api (add reaction)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMENT_ID: ${{ steps.bot_comment.outputs.comment_id }}
          REACTION: rocket
        run: gh api "repos/$GITHUB_REPOSITORY/issues/comments/$COMMENT_ID/reactions" -f content="$REACTION"
      - name: gh api (add reaction)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMENT_ID: ${{ steps.bot_comment.outputs.comment_id }}
          REACTION: eyes
        run: gh api "repos/$GITHUB_REPOSITORY/issues/comments/$COMMENT_ID/reactions" -f content="$REACTION"
