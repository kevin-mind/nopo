You are triaging issue #{{ISSUE_NUMBER}}: "{{ISSUE_TITLE}}"

Issue body:
{{ISSUE_BODY}}

## Issue Structure
Issues follow this structure (from task.yml template):
- **Description**: Brief TLDR of what needs to be done
- **Details**: Implementation details, affected files, technical requirements
- **Questions**: Open questions that need answers (checkboxes)
- **Phases**: ALL issues get sub-issues (even XS/S single-phase work)
  - Each sub-issue has its own todos and ships as a separate PR
  - Parent issues do NOT have todos - todos go in sub-issues only

## Your Tasks

### 1. ANALYZE AND WRITE TRIAGE OUTPUT
Analyze the issue and write a JSON file with your triage decisions.
This file is the SINGLE SOURCE OF TRUTH for labels and project fields.

**CRITICAL**: You MUST write this file FIRST before any other actions:

```bash
cat > triage-output.json << 'EOF'
{
  "type": "<bug|enhancement|documentation|refactor|test|chore>",
  "priority": "<low|medium|high|critical|null>",
  "size": "<xs|s|m|l|xl>",
  "estimate": <hours as number: 1, 2, 3, 5, 8, 13, or 21>,
  "topics": ["topic_name_1", "topic_name_2"],
  "needs_info": <true|false>
}
EOF
```

**How to determine values:**
- **type**: Based on issue category (bug fix, new feature, docs update, etc.)
- **priority**: Extract from "### Priority" section in issue body. If not specified, use `null`
  (Note: priority is only used for project fields, NOT as a label)
- **size**: Based on scope of work:
  - XS: < 1 hour, single file change
  - S: 1-3 hours, few files
  - M: 3-8 hours, moderate complexity
  - L: 8-21 hours, significant work
  - XL: 21+ hours, major feature/refactor
- **estimate**: Hours of work (must match size: XS=1, S=2-3, M=5-8, L=13, XL=21)
- **topics**: 1-3 topic names (lowercase with underscores, e.g., "cli_core", "docker_builds")
  - First check existing topics: `gh label list --search "topic:" --json name --jq '.[].name'`
  - Reuse existing topics when applicable
- **needs_info**: true if critical information is missing

### 2. SEARCH FOR RELATED CONTENT
- Use `gh issue list` to find similar/related issues
- Link to related issues in a comment
- Check if this might be a duplicate

### 3. UPDATE THE ISSUE BODY
Use `gh issue edit {{ISSUE_NUMBER}} --body "..."` to improve the issue:

**Description**: Improve clarity if needed, make it a concise TLDR

**Details**: Expand with technical context:
- Reference specific files/functions that will be affected
- Link to relevant internal docs (files in `decisions/`, `nopo/docs/`, READMEs)
- Link to external documentation (libraries, APIs, standards)
- Add code snippets or examples if helpful

**Questions**:
- If questions exist, research and answer them (check the box and add answer)
- Add new questions if you identify uncertainties

### 4. CREATE SUB-ISSUES (REQUIRED FOR ALL ISSUES)

**You MUST create at least one sub-issue for EVERY issue.** Sub-issues are where the
actual work happens - they contain the todos, get branches, and produce PRs.

- **XS/S issues**: Create a single sub-issue with all todos
- **M/L/XL issues**: Create 2-5 sub-issues, one per phase

**Phase design principles (for multi-phase work):**
- Each phase should be **independently shippable** (no broken states after merge)
- Phase 1 often: schema changes, interfaces, types, config
- Middle phases: core implementation, one feature at a time
- Final phase: integration, cleanup, documentation

**Todo guidelines - IMPORTANT:**
- Todos must be **specific implementation tasks**, not generic workflow steps
- DO NOT include obvious things like:
  - "Commit and push changes"
  - "Create PR"
  - "Run tests"
  - "Ensure CI passes"
  - "Merge PR"
- These workflow steps happen for EVERY issue and are handled by the automation
- Only include tasks that are UNIQUE to this specific issue

**Sub-issue format:**
- Title: `[Phase N] <Phase Title>`
- Body: Phase-specific todos as checkboxes

**Example sub-issue creation:**
```bash
# Create Phase 1 sub-issue
PHASE1=$(gh issue create \
  --title "[Phase 1] Database Schema" \
  --body "$(cat <<'EOF'
## Description
Set up database schema for user preferences.

## Todo
- [ ] Add new migration for user_preferences table
- [ ] Create UserPreference model
- [ ] Add model tests

Parent: #{{ISSUE_NUMBER}}
EOF
)" --json number --jq '.number')
echo "Created sub-issue #$PHASE1"

# Create Phase 2 sub-issue
PHASE2=$(gh issue create \
  --title "[Phase 2] API Endpoints" \
  --body "$(cat <<'EOF'
## Description
Implement REST API endpoints for preferences.

## Todo
- [ ] Add GET /api/preferences endpoint
- [ ] Add PUT /api/preferences endpoint
- [ ] Add unit tests for endpoints

Parent: #{{ISSUE_NUMBER}}
EOF
)" --json number --jq '.number')
echo "Created sub-issue #$PHASE2"

# Create Phase 3 sub-issue
PHASE3=$(gh issue create \
  --title "[Phase 3] Frontend Integration" \
  --body "$(cat <<'EOF'
## Description
Add preferences UI and wire up to API.

## Todo
- [ ] Add preferences page component
- [ ] Wire up API calls
- [ ] Add E2E test for preferences flow

Parent: #{{ISSUE_NUMBER}}
EOF
)" --json number --jq '.number')
echo "Created sub-issue #$PHASE3"
```

**Link sub-issues to parent and add to project with "Ready" status:**
```bash
# Get the parent issue node ID
PARENT_ID=$(gh api graphql -f query='
  query($owner: String!, $repo: String!, $number: Int!) {
    repository(owner: $owner, name: $repo) {
      issue(number: $number) { id }
    }
  }
' -f owner='{{REPO_OWNER}}' -f repo='{{REPO_NAME}}' -F number={{ISSUE_NUMBER}} --jq '.data.repository.issue.id')

# Get project ID and Ready status option ID
PROJECT_INFO=$(gh api graphql -f query='
  query($org: String!, $projectNumber: Int!) {
    organization(login: $org) {
      projectV2(number: $projectNumber) {
        id
        fields(first: 20) {
          nodes {
            ... on ProjectV2SingleSelectField {
              id
              name
              options { id name }
            }
          }
        }
      }
    }
  }
' -f org='{{REPO_OWNER}}' -F projectNumber=1)

PROJECT_ID=$(echo "$PROJECT_INFO" | jq -r '.data.organization.projectV2.id')
STATUS_FIELD_ID=$(echo "$PROJECT_INFO" | jq -r '.data.organization.projectV2.fields.nodes[] | select(.name == "Status") | .id')
READY_OPTION_ID=$(echo "$PROJECT_INFO" | jq -r '.data.organization.projectV2.fields.nodes[] | select(.name == "Status") | .options[] | select(.name == "Ready") | .id')

# Get sub-issue node IDs, link to parent, add to project with "Ready" status
for SUB_NUM in $PHASE1 $PHASE2 $PHASE3; do
  SUB_ID=$(gh api graphql -f query='
    query($owner: String!, $repo: String!, $number: Int!) {
      repository(owner: $owner, name: $repo) {
        issue(number: $number) { id }
      }
    }
  ' -f owner='{{REPO_OWNER}}' -f repo='{{REPO_NAME}}' -F number=$SUB_NUM --jq '.data.repository.issue.id')

  # Link sub-issue to parent
  gh api graphql -f query='
    mutation($parentId: ID!, $childId: ID!) {
      addSubIssue(input: {issueId: $parentId, subIssueId: $childId}) {
        issue { number }
        subIssue { number }
      }
    }
  ' -f parentId="$PARENT_ID" -f childId="$SUB_ID" \
    -H "GraphQL-Features: sub_issues"

  echo "Linked sub-issue #$SUB_NUM to parent #{{ISSUE_NUMBER}}"

  # Add sub-issue to project
  ITEM_ID=$(gh api graphql -f query='
    mutation($projectId: ID!, $contentId: ID!) {
      addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
        item { id }
      }
    }
  ' -f projectId="$PROJECT_ID" -f contentId="$SUB_ID" --jq '.data.addProjectV2ItemById.item.id')

  # Set sub-issue status to "Ready" (not default "In progress")
  gh api graphql -f query='
    mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
      updateProjectV2ItemFieldValue(input: {
        projectId: $projectId
        itemId: $itemId
        fieldId: $fieldId
        value: { singleSelectOptionId: $optionId }
      }) {
        projectV2Item { id }
      }
    }
  ' -f projectId="$PROJECT_ID" -f itemId="$ITEM_ID" -f fieldId="$STATUS_FIELD_ID" -f optionId="$READY_OPTION_ID"

  echo "Added sub-issue #$SUB_NUM to project with Ready status"
done
```

**Update main issue body:**
After creating sub-issues, update the main issue body to include:
1. The original description/details/questions
2. The CLAUDE_MAIN_STATE block (sub-issues are visible in GitHub's sub-issues list)

```bash
gh issue edit {{ISSUE_NUMBER}} --body "$(cat <<'EOF'
## Description
Brief TLDR of the issue.

## Details
Technical context, affected files, links to docs.

## Approach
High-level technical approach for the implementation.

## Questions
- [x] Question 1? Answer here.

<!-- CLAUDE_MAIN_STATE
orchestration_iteration: 0
sub_issues: [<PHASE1_NUM>, <PHASE2_NUM>, <PHASE3_NUM>]
current_sub_issue: 0
sub_issue_status: {}
complete: false
-->
EOF
)"
```

**If work cannot fit in 5 phases:**
If the issue is too large to break into 5 or fewer phases, DO NOT create sub-issues.
Instead, post a comment suggesting the user split the work into smaller, focused issues:

```markdown
This issue is too large to implement in 5 phases. I recommend splitting it into smaller issues:

1. **Issue 1: <suggested title>** - <brief scope>
2. **Issue 2: <suggested title>** - <brief scope>
3. **Issue 3: <suggested title>** - <brief scope>

Each of these can then be triaged and implemented independently with their own sub-issues.
Please close this issue and create the smaller issues, or narrow the scope of this issue.
```

Set `needs_info: true` in the triage output when suggesting a split.

### 5. VALIDATE COMPLETENESS
- If critical info is missing, set `needs_info: true` in the triage output
- Ask clarifying questions in a comment

## Commands Reference
```bash
# STEP 1: Write triage output file (DO THIS FIRST!)
cat > triage-output.json << 'EOF'
{
  "type": "enhancement",
  "priority": "medium",
  "size": "m",
  "estimate": 5,
  "topics": ["cli_core", "docker_builds"],
  "needs_info": false
}
EOF

# Verify the file was created correctly
cat triage-output.json

# View current issue
gh issue view {{ISSUE_NUMBER}}

# Update issue body (use heredoc for multiline)
gh issue edit {{ISSUE_NUMBER}} --body "$(cat <<'EOF'
## Description
Brief TLDR of the issue.

## Details
Technical context, affected files, links to docs.

## Approach
High-level technical approach.

## Questions
- [x] Question 1? Answer here.

<!-- CLAUDE_MAIN_STATE
orchestration_iteration: 0
sub_issues: [<PHASE1_NUM>]
current_sub_issue: 0
sub_issue_status: {}
complete: false
-->
EOF
)"

# List existing topic labels (to reuse existing topics)
gh label list --search "topic:" --json name --jq '.[].name'

# Post a comment (for suggesting splits or asking questions)
gh issue comment {{ISSUE_NUMBER}} --body "Your comment here..."

# Create a sub-issue (for M/L/XL issues with phases)
gh issue create --title "[Phase 1] Title" --body "..." --json number --jq '.number'

# Get issue node ID for GraphQL
gh api graphql -f query='query($owner: String!, $repo: String!, $number: Int!) {
  repository(owner: $owner, name: $repo) { issue(number: $number) { id } }
}' -f owner='{{REPO_OWNER}}' -f repo='{{REPO_NAME}}' -F number=123 --jq '.data.repository.issue.id'

# Link sub-issue to parent (requires sub_issues feature flag)
gh api graphql -f query='mutation($parentId: ID!, $childId: ID!) {
  addSubIssue(input: {issueId: $parentId, subIssueId: $childId}) {
    issue { number }
    subIssue { number }
  }
}' -f parentId="PARENT_NODE_ID" -f childId="CHILD_NODE_ID" \
  -H "GraphQL-Features: sub_issues"
```

IMPORTANT:
- You MUST write triage-output.json - the workflow step reads your JSON and applies labels/fields
- DO NOT add labels yourself - the workflow step reads your JSON and applies them
- DO NOT assign the issue to anyone
- You MUST create at least one sub-issue for EVERY issue (even XS/S)
- Parent issues should NOT have a "## Todo" section - todos go in sub-issues only
- Each sub-issue title MUST start with `[Phase N]` (use `[Phase 1]` for single-phase work)
- Link sub-issues to parent using the GraphQL addSubIssue mutation
- Initialize CLAUDE_MAIN_STATE in main issue after creating sub-issues
- Maximum 5 phases; if more needed, suggest splitting the issue
- Todos must be specific implementation tasks, NOT generic workflow steps
