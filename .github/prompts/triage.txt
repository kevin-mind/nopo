You are triaging issue #{{ISSUE_NUMBER}}: "{{ISSUE_TITLE}}"

Issue body:
{{ISSUE_BODY}}

## Issue Structure
Issues follow this structure (from task.yml template):
- **Description**: Brief TLDR of what needs to be done
- **Details**: Implementation details, affected files, technical requirements
- **Questions**: Open questions that need answers (checkboxes)
- **Phases**: For M/L/XL issues, create separate sub-issues for each phase
  - Each sub-issue has its own todos and ships as a separate PR
  - For XS/S issues, a single "## Todo" section in the main issue is fine

## Your Tasks

### 1. ANALYZE AND WRITE TRIAGE OUTPUT
Analyze the issue and write a JSON file with your triage decisions.
This file is the SINGLE SOURCE OF TRUTH for labels and project fields.

**CRITICAL**: You MUST write this file FIRST before any other actions:

```bash
cat > triage-output.json << 'EOF'
{
  "type": "<bug|enhancement|documentation|refactor|test|chore>",
  "priority": "<low|medium|high|critical|null>",
  "size": "<xs|s|m|l|xl>",
  "estimate": <hours as number: 1, 2, 3, 5, 8, 13, or 21>,
  "topics": ["topic_name_1", "topic_name_2"],
  "needs_info": <true|false>
}
EOF
```

**How to determine values:**
- **type**: Based on issue category (bug fix, new feature, docs update, etc.)
- **priority**: Extract from "### Priority" section in issue body. If not specified, use `null`
  (Note: priority is only used for project fields, NOT as a label)
- **size**: Based on scope of work:
  - XS: < 1 hour, single file change
  - S: 1-3 hours, few files
  - M: 3-8 hours, moderate complexity
  - L: 8-21 hours, significant work
  - XL: 21+ hours, major feature/refactor
- **estimate**: Hours of work (must match size: XS=1, S=2-3, M=5-8, L=13, XL=21)
- **topics**: 1-3 topic names (lowercase with underscores, e.g., "cli_core", "docker_builds")
  - First check existing topics: `gh label list --search "topic:" --json name --jq '.[].name'`
  - Reuse existing topics when applicable
- **needs_info**: true if critical information is missing

### 2. SEARCH FOR RELATED CONTENT
- Use `gh issue list` to find similar/related issues
- Link to related issues in a comment
- Check if this might be a duplicate

### 3. UPDATE THE ISSUE BODY
Use `gh issue edit {{ISSUE_NUMBER}} --body "..."` to improve the issue:

**Description**: Improve clarity if needed, make it a concise TLDR

**Details**: Expand with technical context:
- Reference specific files/functions that will be affected
- Link to relevant internal docs (files in `decisions/`, `nopo/docs/`, READMEs)
- Link to external documentation (libraries, APIs, standards)
- Add code snippets or examples if helpful

**Questions**:
- If questions exist, research and answer them (check the box and add answer)
- Add new questions if you identify uncertainties

### 4. CREATE SUB-ISSUES FOR PHASES (M/L/XL issues only)

For M/L/XL issues, create separate sub-issues for each phase. Each sub-issue becomes
an independent unit of work with its own branch, PR, and iteration loop.

**Phase design principles:**
- Each phase should be **independently shippable** (no broken states after merge)
- Phase 1 often: schema changes, interfaces, types, config
- Middle phases: core implementation, one feature at a time
- Final phase: integration, cleanup, documentation
- 2-5 phases is ideal; single-phase inline todos are fine for XS/S issues

**Sub-issue format:**
- Title: `[Phase N] <Phase Title>`
- Body: Phase-specific todos as checkboxes

**Example sub-issue creation:**
```bash
# Create Phase 1 sub-issue
PHASE1=$(gh issue create \
  --title "[Phase 1] Database Schema" \
  --body "$(cat <<'EOF'
## Description
Set up database schema for user preferences.

## Todo
- [ ] Add new migration for user_preferences table
- [ ] Create UserPreference model
- [ ] Add model tests

Parent: #{{ISSUE_NUMBER}}
EOF
)" --json number --jq '.number')
echo "Created sub-issue #$PHASE1"

# Create Phase 2 sub-issue
PHASE2=$(gh issue create \
  --title "[Phase 2] API Endpoints" \
  --body "$(cat <<'EOF'
## Description
Implement REST API endpoints for preferences.

## Todo
- [ ] Add GET /api/preferences endpoint
- [ ] Add PUT /api/preferences endpoint
- [ ] Add unit tests for endpoints

Parent: #{{ISSUE_NUMBER}}
EOF
)" --json number --jq '.number')
echo "Created sub-issue #$PHASE2"

# Create Phase 3 sub-issue
PHASE3=$(gh issue create \
  --title "[Phase 3] Frontend Integration" \
  --body "$(cat <<'EOF'
## Description
Add preferences UI and wire up to API.

## Todo
- [ ] Add preferences page component
- [ ] Wire up API calls
- [ ] Add E2E test for preferences flow

Parent: #{{ISSUE_NUMBER}}
EOF
)" --json number --jq '.number')
echo "Created sub-issue #$PHASE3"
```

**Link sub-issues to parent using GraphQL:**
```bash
# Get the parent issue node ID
PARENT_ID=$(gh api graphql -f query='
  query($owner: String!, $repo: String!, $number: Int!) {
    repository(owner: $owner, name: $repo) {
      issue(number: $number) { id }
    }
  }
' -f owner='{{REPO_OWNER}}' -f repo='{{REPO_NAME}}' -F number={{ISSUE_NUMBER}} --jq '.data.repository.issue.id')

# Get sub-issue node IDs and link them
for SUB_NUM in $PHASE1 $PHASE2 $PHASE3; do
  SUB_ID=$(gh api graphql -f query='
    query($owner: String!, $repo: String!, $number: Int!) {
      repository(owner: $owner, name: $repo) {
        issue(number: $number) { id }
      }
    }
  ' -f owner='{{REPO_OWNER}}' -f repo='{{REPO_NAME}}' -F number=$SUB_NUM --jq '.data.repository.issue.id')

  gh api graphql -f query='
    mutation($parentId: ID!, $childId: ID!) {
      addSubIssue(input: {issueId: $parentId, subIssueId: $childId}) {
        issue { number }
        subIssue { number }
      }
    }
  ' -f parentId="$PARENT_ID" -f childId="$SUB_ID" \
    -H "GraphQL-Features: sub_issues"

  echo "Linked sub-issue #$SUB_NUM to parent #{{ISSUE_NUMBER}}"
done
```

**Update main issue with phases table:**
After creating sub-issues, update the main issue body to include:
1. The original description/details/questions
2. A phases table showing all sub-issues
3. The CLAUDE_MAIN_STATE block

```bash
gh issue edit {{ISSUE_NUMBER}} --body "$(cat <<'EOF'
## Description
Brief TLDR of the issue.

## Details
Technical context, affected files, links to docs.

## Approach
High-level technical approach for the implementation.

## Questions
- [x] Question 1? Answer here.

## Phases

| # | Sub-Issue | Status |
|---|-----------|--------|
| 1 | #<PHASE1_NUM> | pending |
| 2 | #<PHASE2_NUM> | pending |
| 3 | #<PHASE3_NUM> | pending |

<!-- CLAUDE_MAIN_STATE
orchestration_iteration: 0
sub_issues: [<PHASE1_NUM>, <PHASE2_NUM>, <PHASE3_NUM>]
current_sub_issue: 0
sub_issue_status: {}
complete: false
-->
EOF
)"
```

**If work cannot fit in 5 phases:**
If the issue is too large to break into 5 or fewer phases, DO NOT create sub-issues.
Instead, post a comment suggesting the user split the work into smaller, focused issues:

```markdown
This issue is too large to implement in 5 phases. I recommend splitting it into smaller issues:

1. **Issue 1: <suggested title>** - <brief scope>
2. **Issue 2: <suggested title>** - <brief scope>
3. **Issue 3: <suggested title>** - <brief scope>

Each of these can then be triaged and implemented independently with their own sub-issues.
Please close this issue and create the smaller issues, or narrow the scope of this issue.
```

Set `needs_info: true` in the triage output when suggesting a split.

### 5. VALIDATE COMPLETENESS
- If critical info is missing, set `needs_info: true` in the triage output
- Ask clarifying questions in a comment

## Commands Reference
```bash
# STEP 1: Write triage output file (DO THIS FIRST!)
cat > triage-output.json << 'EOF'
{
  "type": "enhancement",
  "priority": "medium",
  "size": "m",
  "estimate": 5,
  "topics": ["cli_core", "docker_builds"],
  "needs_info": false
}
EOF

# Verify the file was created correctly
cat triage-output.json

# View current issue
gh issue view {{ISSUE_NUMBER}}

# Update issue body (use heredoc for multiline)
gh issue edit {{ISSUE_NUMBER}} --body "$(cat <<'EOF'
## Description
Brief TLDR of the issue.

## Details
Technical context, affected files, links to docs.

## Approach
High-level technical approach.

## Questions
- [x] Question 1? Answer here.

## Todo
- [ ] Task 1
- [ ] Task 2
EOF
)"

# List existing topic labels (to reuse existing topics)
gh label list --search "topic:" --json name --jq '.[].name'

# Post a comment (for suggesting splits or asking questions)
gh issue comment {{ISSUE_NUMBER}} --body "Your comment here..."

# Create a sub-issue (for M/L/XL issues with phases)
gh issue create --title "[Phase 1] Title" --body "..." --json number --jq '.number'

# Get issue node ID for GraphQL
gh api graphql -f query='query($owner: String!, $repo: String!, $number: Int!) {
  repository(owner: $owner, name: $repo) { issue(number: $number) { id } }
}' -f owner='{{REPO_OWNER}}' -f repo='{{REPO_NAME}}' -F number=123 --jq '.data.repository.issue.id'

# Link sub-issue to parent (requires sub_issues feature flag)
gh api graphql -f query='mutation($parentId: ID!, $childId: ID!) {
  addSubIssue(input: {issueId: $parentId, subIssueId: $childId}) {
    issue { number }
    subIssue { number }
  }
}' -f parentId="PARENT_NODE_ID" -f childId="CHILD_NODE_ID" \
  -H "GraphQL-Features: sub_issues"
```

IMPORTANT:
- You MUST write triage-output.json - the workflow step reads your JSON and applies labels/fields
- DO NOT add labels yourself - the workflow step reads your JSON and applies them
- DO NOT assign the issue to anyone
- For XS/S issues: Use inline "## Todo" section with checkboxes
- For M/L/XL issues: Create sub-issues for each phase (2-5 phases)
- Each sub-issue title MUST start with `[Phase N]`
- Link sub-issues to parent using the GraphQL addSubIssue mutation
- Initialize CLAUDE_MAIN_STATE in main issue after creating sub-issues
- Maximum 5 phases; if more needed, suggest splitting the issue
