// This file is auto-generated. Do not edit directly.
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toCommandProperties = exports2.toCommandValue = void 0;
    function toCommandValue(input) {
      if (input === null || input === void 0) {
        return "";
      } else if (typeof input === "string" || input instanceof String) {
        return input;
      }
      return JSON.stringify(input);
    }
    exports2.toCommandValue = toCommandValue;
    function toCommandProperties(annotationProperties) {
      if (!Object.keys(annotationProperties).length) {
        return {};
      }
      return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
      };
    }
    exports2.toCommandProperties = toCommandProperties;
  }
});

// ../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/command.js
var require_command = __commonJS({
  "../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/command.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      o[k22] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v3) {
      Object.defineProperty(o, "default", { enumerable: true, value: v3 });
    } : function(o, v3) {
      o["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.issue = exports2.issueCommand = void 0;
    var os = __importStar(require("os"));
    var utils_1 = require_utils();
    function issueCommand(command, properties, message) {
      const cmd = new Command(command, properties, message);
      process.stdout.write(cmd.toString() + os.EOL);
    }
    exports2.issueCommand = issueCommand;
    function issue(name, message = "") {
      issueCommand(name, {}, message);
    }
    exports2.issue = issue;
    var CMD_STRING = "::";
    var Command = class {
      constructor(command, properties, message) {
        if (!command) {
          command = "missing.command";
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
      }
      toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
          cmdStr += " ";
          let first = true;
          for (const key in this.properties) {
            if (this.properties.hasOwnProperty(key)) {
              const val = this.properties[key];
              if (val) {
                if (first) {
                  first = false;
                } else {
                  cmdStr += ",";
                }
                cmdStr += `${key}=${escapeProperty(val)}`;
              }
            }
          }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
      }
    };
    function escapeData(s) {
      return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
    }
    function escapeProperty(s) {
      return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
    }
  }
});

// ../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS({
  "../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/file-command.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      o[k22] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v3) {
      Object.defineProperty(o, "default", { enumerable: true, value: v3 });
    } : function(o, v3) {
      o["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepareKeyValueMessage = exports2.issueFileCommand = void 0;
    var crypto = __importStar(require("crypto"));
    var fs2 = __importStar(require("fs"));
    var os = __importStar(require("os"));
    var utils_1 = require_utils();
    function issueFileCommand(command, message) {
      const filePath = process.env[`GITHUB_${command}`];
      if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
      }
      if (!fs2.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
      }
      fs2.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os.EOL}`, {
        encoding: "utf8"
      });
    }
    exports2.issueFileCommand = issueFileCommand;
    function prepareKeyValueMessage(key, value) {
      const delimiter = `ghadelimiter_${crypto.randomUUID()}`;
      const convertedValue = (0, utils_1.toCommandValue)(value);
      if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
      }
      if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
      }
      return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
    }
    exports2.prepareKeyValueMessage = prepareKeyValueMessage;
  }
});

// ../../node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS({
  "../../node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/proxy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkBypass = exports2.getProxyUrl = void 0;
    function getProxyUrl(reqUrl) {
      const usingSsl = reqUrl.protocol === "https:";
      if (checkBypass(reqUrl)) {
        return void 0;
      }
      const proxyVar = (() => {
        if (usingSsl) {
          return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
        } else {
          return process.env["http_proxy"] || process.env["HTTP_PROXY"];
        }
      })();
      if (proxyVar) {
        try {
          return new DecodedURL(proxyVar);
        } catch (_a) {
          if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
            return new DecodedURL(`http://${proxyVar}`);
        }
      } else {
        return void 0;
      }
    }
    exports2.getProxyUrl = getProxyUrl;
    function checkBypass(reqUrl) {
      if (!reqUrl.hostname) {
        return false;
      }
      const reqHost = reqUrl.hostname;
      if (isLoopbackAddress(reqHost)) {
        return true;
      }
      const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
      if (!noProxy) {
        return false;
      }
      let reqPort;
      if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
      } else if (reqUrl.protocol === "http:") {
        reqPort = 80;
      } else if (reqUrl.protocol === "https:") {
        reqPort = 443;
      }
      const upperReqHosts = [reqUrl.hostname.toUpperCase()];
      if (typeof reqPort === "number") {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
      }
      for (const upperNoProxyItem of noProxy.split(",").map((x3) => x3.trim().toUpperCase()).filter((x3) => x3)) {
        if (upperNoProxyItem === "*" || upperReqHosts.some((x3) => x3 === upperNoProxyItem || x3.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x3.endsWith(`${upperNoProxyItem}`))) {
          return true;
        }
      }
      return false;
    }
    exports2.checkBypass = checkBypass;
    function isLoopbackAddress(host) {
      const hostLower = host.toLowerCase();
      return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
    }
    var DecodedURL = class extends URL {
      constructor(url, base) {
        super(url, base);
        this._decodedUsername = decodeURIComponent(super.username);
        this._decodedPassword = decodeURIComponent(super.password);
      }
      get username() {
        return this._decodedUsername;
      }
      get password() {
        return this._decodedPassword;
      }
    };
  }
});

// ../../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS({
  "../../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/lib/tunnel.js"(exports2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var http = require("http");
    var https = require("https");
    var events = require("events");
    var assert = require("assert");
    var util = require("util");
    exports2.httpOverHttp = httpOverHttp;
    exports2.httpsOverHttp = httpsOverHttp;
    exports2.httpOverHttps = httpOverHttps;
    exports2.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self2 = this;
      self2.options = options || {};
      self2.proxyOptions = self2.options.proxy || {};
      self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
      self2.requests = [];
      self2.sockets = [];
      self2.on("free", function onFree(socket, host, port, localAddress) {
        var options2 = toOptions(host, port, localAddress);
        for (var i3 = 0, len = self2.requests.length; i3 < len; ++i3) {
          var pending = self2.requests[i3];
          if (pending.host === options2.host && pending.port === options2.port) {
            self2.requests.splice(i3, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self2.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
      var self2 = this;
      var options = mergeOptions({ request: req }, self2.options, toOptions(host, port, localAddress));
      if (self2.sockets.length >= this.maxSockets) {
        self2.requests.push(options);
        return;
      }
      self2.createSocket(options, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        req.onSocket(socket);
        function onFree() {
          self2.emit("free", socket, options);
        }
        function onCloseOrRemove(err) {
          self2.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self2 = this;
      var placeholder = {};
      self2.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self2.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false,
        headers: {
          host: options.host + ":" + options.port
        }
      });
      if (options.localAddress) {
        connectOptions.localAddress = options.localAddress;
      }
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
      }
      debug2("making CONNECT request");
      var connectReq = self2.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode !== 200) {
          debug2(
            "tunneling socket could not be established, statusCode=%d",
            res.statusCode
          );
          socket.destroy();
          var error2 = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error2.code = "ECONNRESET";
          options.request.emit("error", error2);
          self2.removeSocket(placeholder);
          return;
        }
        if (head.length > 0) {
          debug2("got illegal response body from proxy");
          socket.destroy();
          var error2 = new Error("got illegal response body from proxy");
          error2.code = "ECONNRESET";
          options.request.emit("error", error2);
          self2.removeSocket(placeholder);
          return;
        }
        debug2("tunneling connection has established");
        self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
        return cb(socket);
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug2(
          "tunneling socket could not be established, cause=%s\n",
          cause.message,
          cause.stack
        );
        var error2 = new Error("tunneling socket could not be established, cause=" + cause.message);
        error2.code = "ECONNRESET";
        options.request.emit("error", error2);
        self2.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1) {
        return;
      }
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createSocket(pending, function(socket2) {
          pending.request.onSocket(socket2);
        });
      }
    };
    function createSecureSocket(options, cb) {
      var self2 = this;
      TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
        var hostHeader = options.request.getHeader("host");
        var tlsOptions = mergeOptions({}, self2.options, {
          socket,
          servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
        });
        var secureSocket = tls.connect(0, tlsOptions);
        self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      });
    }
    function toOptions(host, port, localAddress) {
      if (typeof host === "string") {
        return {
          host,
          port,
          localAddress
        };
      }
      return host;
    }
    function mergeOptions(target) {
      for (var i3 = 1, len = arguments.length; i3 < len; ++i3) {
        var overrides = arguments[i3];
        if (typeof overrides === "object") {
          var keys = Object.keys(overrides);
          for (var j3 = 0, keyLen = keys.length; j3 < keyLen; ++j3) {
            var k = keys[j3];
            if (overrides[k] !== void 0) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }
    var debug2;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug2 = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug2 = function() {
      };
    }
    exports2.debug = debug2;
  }
});

// ../../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js
var require_tunnel2 = __commonJS({
  "../../node_modules/.pnpm/tunnel@0.0.6/node_modules/tunnel/index.js"(exports2, module2) {
    module2.exports = require_tunnel();
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/symbols.js"(exports2, module2) {
    module2.exports = {
      kClose: Symbol("close"),
      kDestroy: Symbol("destroy"),
      kDispatch: Symbol("dispatch"),
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kConnecting: Symbol("connecting"),
      kHeadersList: Symbol("headers list"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kServerName: Symbol("server name"),
      kLocalAddress: Symbol("local address"),
      kHost: Symbol("host"),
      kNoRef: Symbol("no ref"),
      kBodyUsed: Symbol("used"),
      kRunning: Symbol("running"),
      kBlocking: Symbol("blocking"),
      kPending: Symbol("pending"),
      kSize: Symbol("size"),
      kBusy: Symbol("busy"),
      kQueued: Symbol("queued"),
      kFree: Symbol("free"),
      kConnected: Symbol("connected"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol.for("nodejs.stream.destroyed"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClients: Symbol("clients"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelining"),
      kSocket: Symbol("socket"),
      kHostHeader: Symbol("host header"),
      kConnector: Symbol("connector"),
      kStrictContentLength: Symbol("strict content length"),
      kMaxRedirections: Symbol("maxRedirections"),
      kMaxRequests: Symbol("maxRequestsPerClient"),
      kProxy: Symbol("proxy agent options"),
      kCounter: Symbol("socket request counter"),
      kInterceptors: Symbol("dispatch interceptors"),
      kMaxResponseSize: Symbol("max response size"),
      kHTTP2Session: Symbol("http2Session"),
      kHTTP2SessionState: Symbol("http2Session state"),
      kHTTP2BuildRequest: Symbol("http2 build request"),
      kHTTP1BuildRequest: Symbol("http1 build request"),
      kHTTP2CopyHeaders: Symbol("http2 copy headers"),
      kHTTPConnVersion: Symbol("http connection version"),
      kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
      kConstruct: Symbol("constructable")
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js
var require_errors = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/errors.js"(exports2, module2) {
    "use strict";
    var UndiciError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    };
    var ConnectTimeoutError = class _ConnectTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ConnectTimeoutError);
        this.name = "ConnectTimeoutError";
        this.message = message || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    };
    var HeadersTimeoutError = class _HeadersTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersTimeoutError);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    };
    var HeadersOverflowError = class _HeadersOverflowError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersOverflowError);
        this.name = "HeadersOverflowError";
        this.message = message || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    };
    var BodyTimeoutError = class _BodyTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _BodyTimeoutError);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    };
    var ResponseStatusCodeError = class _ResponseStatusCodeError extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message);
        Error.captureStackTrace(this, _ResponseStatusCodeError);
        this.name = "ResponseStatusCodeError";
        this.message = message || "Response Status Code Error";
        this.code = "UND_ERR_RESPONSE_STATUS_CODE";
        this.body = body;
        this.status = statusCode;
        this.statusCode = statusCode;
        this.headers = headers;
      }
    };
    var InvalidArgumentError = class _InvalidArgumentError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidArgumentError);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    };
    var InvalidReturnValueError = class _InvalidReturnValueError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidReturnValueError);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    };
    var RequestAbortedError = class _RequestAbortedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestAbortedError);
        this.name = "AbortError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    };
    var InformationalError = class _InformationalError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InformationalError);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    };
    var RequestContentLengthMismatchError = class _RequestContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestContentLengthMismatchError);
        this.name = "RequestContentLengthMismatchError";
        this.message = message || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ResponseContentLengthMismatchError = class _ResponseContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseContentLengthMismatchError);
        this.name = "ResponseContentLengthMismatchError";
        this.message = message || "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ClientDestroyedError = class _ClientDestroyedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientDestroyedError);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    };
    var ClientClosedError = class _ClientClosedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientClosedError);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    };
    var SocketError = class _SocketError extends UndiciError {
      constructor(message, socket) {
        super(message);
        Error.captureStackTrace(this, _SocketError);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = socket;
      }
    };
    var NotSupportedError = class _NotSupportedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _NotSupportedError);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    };
    var BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "MissingUpstreamError";
        this.message = message || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    };
    var HTTPParserError = class _HTTPParserError extends Error {
      constructor(message, code, data) {
        super(message);
        Error.captureStackTrace(this, _HTTPParserError);
        this.name = "HTTPParserError";
        this.code = code ? `HPE_${code}` : void 0;
        this.data = data ? data.toString() : void 0;
      }
    };
    var ResponseExceededMaxSizeError = class _ResponseExceededMaxSizeError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseExceededMaxSizeError);
        this.name = "ResponseExceededMaxSizeError";
        this.message = message || "Response content exceeded max size";
        this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
      }
    };
    var RequestRetryError = class _RequestRetryError extends UndiciError {
      constructor(message, code, { headers, data }) {
        super(message);
        Error.captureStackTrace(this, _RequestRetryError);
        this.name = "RequestRetryError";
        this.message = message || "Request retry error";
        this.code = "UND_ERR_REQ_RETRY";
        this.statusCode = code;
        this.data = data;
        this.headers = headers;
      }
    };
    module2.exports = {
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError,
      RequestRetryError
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/constants.js
var require_constants = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/constants.js"(exports2, module2) {
    "use strict";
    var headerNameLowerCasedRecord = {};
    var wellknownHeaderNames = [
      "Accept",
      "Accept-Encoding",
      "Accept-Language",
      "Accept-Ranges",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Age",
      "Allow",
      "Alt-Svc",
      "Alt-Used",
      "Authorization",
      "Cache-Control",
      "Clear-Site-Data",
      "Connection",
      "Content-Disposition",
      "Content-Encoding",
      "Content-Language",
      "Content-Length",
      "Content-Location",
      "Content-Range",
      "Content-Security-Policy",
      "Content-Security-Policy-Report-Only",
      "Content-Type",
      "Cookie",
      "Cross-Origin-Embedder-Policy",
      "Cross-Origin-Opener-Policy",
      "Cross-Origin-Resource-Policy",
      "Date",
      "Device-Memory",
      "Downlink",
      "ECT",
      "ETag",
      "Expect",
      "Expect-CT",
      "Expires",
      "Forwarded",
      "From",
      "Host",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Range",
      "If-Unmodified-Since",
      "Keep-Alive",
      "Last-Modified",
      "Link",
      "Location",
      "Max-Forwards",
      "Origin",
      "Permissions-Policy",
      "Pragma",
      "Proxy-Authenticate",
      "Proxy-Authorization",
      "RTT",
      "Range",
      "Referer",
      "Referrer-Policy",
      "Refresh",
      "Retry-After",
      "Sec-WebSocket-Accept",
      "Sec-WebSocket-Extensions",
      "Sec-WebSocket-Key",
      "Sec-WebSocket-Protocol",
      "Sec-WebSocket-Version",
      "Server",
      "Server-Timing",
      "Service-Worker-Allowed",
      "Service-Worker-Navigation-Preload",
      "Set-Cookie",
      "SourceMap",
      "Strict-Transport-Security",
      "Supports-Loading-Mode",
      "TE",
      "Timing-Allow-Origin",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Upgrade-Insecure-Requests",
      "User-Agent",
      "Vary",
      "Via",
      "WWW-Authenticate",
      "X-Content-Type-Options",
      "X-DNS-Prefetch-Control",
      "X-Frame-Options",
      "X-Permitted-Cross-Domain-Policies",
      "X-Powered-By",
      "X-Requested-With",
      "X-XSS-Protection"
    ];
    for (let i3 = 0; i3 < wellknownHeaderNames.length; ++i3) {
      const key = wellknownHeaderNames[i3];
      const lowerCasedKey = key.toLowerCase();
      headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
    }
    Object.setPrototypeOf(headerNameLowerCasedRecord, null);
    module2.exports = {
      wellknownHeaderNames,
      headerNameLowerCasedRecord
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js
var require_util = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/util.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { kDestroyed, kBodyUsed } = require_symbols();
    var { IncomingMessage } = require("http");
    var stream = require("stream");
    var net = require("net");
    var { InvalidArgumentError } = require_errors();
    var { Blob: Blob2 } = require("buffer");
    var nodeUtil = require("util");
    var { stringify } = require("querystring");
    var { headerNameLowerCasedRecord } = require_constants();
    var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v3) => Number(v3));
    function nop() {
    }
    function isStream(obj) {
      return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
    }
    function isBlobLike(object) {
      return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
    }
    function buildURL(url, queryParams) {
      if (url.includes("?") || url.includes("#")) {
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      }
      const stringified = stringify(queryParams);
      if (stringified) {
        url += "?" + stringified;
      }
      return url;
    }
    function parseURL(url) {
      if (typeof url === "string") {
        url = new URL(url);
        if (!/^https?:/.test(url.origin || url.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        return url;
      }
      if (!url || typeof url !== "object") {
        throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
      }
      if (!/^https?:/.test(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      if (!(url instanceof URL)) {
        if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
          throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
        }
        if (url.path != null && typeof url.path !== "string") {
          throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
        }
        if (url.pathname != null && typeof url.pathname !== "string") {
          throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
        }
        if (url.hostname != null && typeof url.hostname !== "string") {
          throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
        }
        if (url.origin != null && typeof url.origin !== "string") {
          throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
        }
        const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
        let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
        let path2 = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
        if (origin.endsWith("/")) {
          origin = origin.substring(0, origin.length - 1);
        }
        if (path2 && !path2.startsWith("/")) {
          path2 = `/${path2}`;
        }
        url = new URL(origin + path2);
      }
      return url;
    }
    function parseOrigin(url) {
      url = parseURL(url);
      if (url.pathname !== "/" || url.search || url.hash) {
        throw new InvalidArgumentError("invalid url");
      }
      return url;
    }
    function getHostname(host) {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert(idx2 !== -1);
        return host.substring(1, idx2);
      }
      const idx = host.indexOf(":");
      if (idx === -1) return host;
      return host.substring(0, idx);
    }
    function getServerName(host) {
      if (!host) {
        return null;
      }
      assert.strictEqual(typeof host, "string");
      const servername = getHostname(host);
      if (net.isIP(servername)) {
        return "";
      }
      return servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
    }
    function isIterable(obj) {
      return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
    }
    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream(body)) {
        const state = body._readableState;
        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer(body)) {
        return body.byteLength;
      }
      return null;
    }
    function isDestroyed(stream2) {
      return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
    }
    function isReadableAborted(stream2) {
      const state = stream2 && stream2._readableState;
      return isDestroyed(stream2) && state && !state.endEmitted;
    }
    function destroy(stream2, err) {
      if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
        return;
      }
      if (typeof stream2.destroy === "function") {
        if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
          stream2.socket = null;
        }
        stream2.destroy(err);
      } else if (err) {
        process.nextTick((stream3, err2) => {
          stream3.emit("error", err2);
        }, stream2, err);
      }
      if (stream2.destroyed !== true) {
        stream2[kDestroyed] = true;
      }
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1e3 : null;
    }
    function headerNameToString(value) {
      return headerNameLowerCasedRecord[value] || value.toLowerCase();
    }
    function parseHeaders(headers, obj = {}) {
      if (!Array.isArray(headers)) return headers;
      for (let i3 = 0; i3 < headers.length; i3 += 2) {
        const key = headers[i3].toString().toLowerCase();
        let val = obj[key];
        if (!val) {
          if (Array.isArray(headers[i3 + 1])) {
            obj[key] = headers[i3 + 1].map((x3) => x3.toString("utf8"));
          } else {
            obj[key] = headers[i3 + 1].toString("utf8");
          }
        } else {
          if (!Array.isArray(val)) {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i3 + 1].toString("utf8"));
        }
      }
      if ("content-length" in obj && "content-disposition" in obj) {
        obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
      }
      return obj;
    }
    function parseRawHeaders(headers) {
      const ret = [];
      let hasContentLength = false;
      let contentDispositionIdx = -1;
      for (let n3 = 0; n3 < headers.length; n3 += 2) {
        const key = headers[n3 + 0].toString();
        const val = headers[n3 + 1].toString("utf8");
        if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
          ret.push(key, val);
          hasContentLength = true;
        } else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
          contentDispositionIdx = ret.push(key, val) - 1;
        } else {
          ret.push(key, val);
        }
      }
      if (hasContentLength && contentDispositionIdx !== -1) {
        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
      }
      return ret;
    }
    function isBuffer(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    function validateHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
        throw new InvalidArgumentError("invalid onBodySent method");
      }
      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
    }
    function isDisturbed(body) {
      return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
    }
    function isErrored(body) {
      return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function isReadable(body) {
      return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead
      };
    }
    async function* convertIterableToBuffer(iterable) {
      for await (const chunk of iterable) {
        yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
      }
    }
    var ReadableStream;
    function ReadableStreamFrom(iterable) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      if (ReadableStream.from) {
        return ReadableStream.from(convertIterableToBuffer(iterable));
      }
      let iterator;
      return new ReadableStream(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
              controller.enqueue(new Uint8Array(buf));
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          }
        },
        0
      );
    }
    function isFormDataLike(object) {
      return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
    }
    function throwIfAborted(signal) {
      if (!signal) {
        return;
      }
      if (typeof signal.throwIfAborted === "function") {
        signal.throwIfAborted();
      } else {
        if (signal.aborted) {
          const err = new Error("The operation was aborted");
          err.name = "AbortError";
          throw err;
        }
      }
    }
    function addAbortListener(signal, listener) {
      if ("addEventListener" in signal) {
        signal.addEventListener("abort", listener, { once: true });
        return () => signal.removeEventListener("abort", listener);
      }
      signal.addListener("abort", listener);
      return () => signal.removeListener("abort", listener);
    }
    var hasToWellFormed = !!String.prototype.toWellFormed;
    function toUSVString(val) {
      if (hasToWellFormed) {
        return `${val}`.toWellFormed();
      } else if (nodeUtil.toUSVString) {
        return nodeUtil.toUSVString(val);
      }
      return `${val}`;
    }
    function parseRangeHeader(range) {
      if (range == null || range === "") return { start: 0, end: null, size: null };
      const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
      return m ? {
        start: parseInt(m[1]),
        end: m[2] ? parseInt(m[2]) : null,
        size: m[3] ? parseInt(m[3]) : null
      } : null;
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    module2.exports = {
      kEnumerableProperty,
      nop,
      isDisturbed,
      isErrored,
      isReadable,
      toUSVString,
      isReadableAborted,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream,
      isIterable,
      isAsyncIterable,
      isDestroyed,
      headerNameToString,
      parseRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer,
      validateHandler,
      getSocketInfo,
      isFormDataLike,
      buildURL,
      throwIfAborted,
      addAbortListener,
      parseRangeHeader,
      nodeMajor,
      nodeMinor,
      nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,
      safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"]
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/timers.js
var require_timers = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/timers.js"(exports2, module2) {
    "use strict";
    var fastNow = Date.now();
    var fastNowTimeout;
    var fastTimers = [];
    function onTimeout() {
      fastNow = Date.now();
      let len = fastTimers.length;
      let idx = 0;
      while (idx < len) {
        const timer = fastTimers[idx];
        if (timer.state === 0) {
          timer.state = fastNow + timer.delay;
        } else if (timer.state > 0 && fastNow >= timer.state) {
          timer.state = -1;
          timer.callback(timer.opaque);
        }
        if (timer.state === -1) {
          timer.state = -2;
          if (idx !== len - 1) {
            fastTimers[idx] = fastTimers.pop();
          } else {
            fastTimers.pop();
          }
          len -= 1;
        } else {
          idx += 1;
        }
      }
      if (fastTimers.length > 0) {
        refreshTimeout();
      }
    }
    function refreshTimeout() {
      if (fastNowTimeout && fastNowTimeout.refresh) {
        fastNowTimeout.refresh();
      } else {
        clearTimeout(fastNowTimeout);
        fastNowTimeout = setTimeout(onTimeout, 1e3);
        if (fastNowTimeout.unref) {
          fastNowTimeout.unref();
        }
      }
    }
    var Timeout = class {
      constructor(callback, delay, opaque) {
        this.callback = callback;
        this.delay = delay;
        this.opaque = opaque;
        this.state = -2;
        this.refresh();
      }
      refresh() {
        if (this.state === -2) {
          fastTimers.push(this);
          if (!fastNowTimeout || fastTimers.length === 1) {
            refreshTimeout();
          }
        }
        this.state = 0;
      }
      clear() {
        this.state = -1;
      }
    };
    module2.exports = {
      setTimeout(callback, delay, opaque) {
        return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
      },
      clearTimeout(timeout) {
        if (timeout instanceof Timeout) {
          timeout.clear();
        } else {
          clearTimeout(timeout);
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS({
  "../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("node:events").EventEmitter;
    var inherits = require("node:util").inherits;
    function SBMH(needle) {
      if (typeof needle === "string") {
        needle = Buffer.from(needle);
      }
      if (!Buffer.isBuffer(needle)) {
        throw new TypeError("The needle has to be a String or a Buffer.");
      }
      const needleLength = needle.length;
      if (needleLength === 0) {
        throw new Error("The needle cannot be an empty String/Buffer.");
      }
      if (needleLength > 256) {
        throw new Error("The needle cannot have a length bigger than 256.");
      }
      this.maxMatches = Infinity;
      this.matches = 0;
      this._occ = new Array(256).fill(needleLength);
      this._lookbehind_size = 0;
      this._needle = needle;
      this._bufpos = 0;
      this._lookbehind = Buffer.alloc(needleLength);
      for (var i3 = 0; i3 < needleLength - 1; ++i3) {
        this._occ[needle[i3]] = needleLength - 1 - i3;
      }
    }
    inherits(SBMH, EventEmitter);
    SBMH.prototype.reset = function() {
      this._lookbehind_size = 0;
      this.matches = 0;
      this._bufpos = 0;
    };
    SBMH.prototype.push = function(chunk, pos) {
      if (!Buffer.isBuffer(chunk)) {
        chunk = Buffer.from(chunk, "binary");
      }
      const chlen = chunk.length;
      this._bufpos = pos || 0;
      let r3;
      while (r3 !== chlen && this.matches < this.maxMatches) {
        r3 = this._sbmh_feed(chunk);
      }
      return r3;
    };
    SBMH.prototype._sbmh_feed = function(data) {
      const len = data.length;
      const needle = this._needle;
      const needleLength = needle.length;
      const lastNeedleChar = needle[needleLength - 1];
      let pos = -this._lookbehind_size;
      let ch;
      if (pos < 0) {
        while (pos < 0 && pos <= len - needleLength) {
          ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
          if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
            this._lookbehind_size = 0;
            ++this.matches;
            this.emit("info", true);
            return this._bufpos = pos + needleLength;
          }
          pos += this._occ[ch];
        }
        if (pos < 0) {
          while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
            ++pos;
          }
        }
        if (pos >= 0) {
          this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
          this._lookbehind_size = 0;
        } else {
          const bytesToCutOff = this._lookbehind_size + pos;
          if (bytesToCutOff > 0) {
            this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
          }
          this._lookbehind.copy(
            this._lookbehind,
            0,
            bytesToCutOff,
            this._lookbehind_size - bytesToCutOff
          );
          this._lookbehind_size -= bytesToCutOff;
          data.copy(this._lookbehind, this._lookbehind_size);
          this._lookbehind_size += len;
          this._bufpos = len;
          return len;
        }
      }
      pos += (pos >= 0) * this._bufpos;
      if (data.indexOf(needle, pos) !== -1) {
        pos = data.indexOf(needle, pos);
        ++this.matches;
        if (pos > 0) {
          this.emit("info", true, data, this._bufpos, pos);
        } else {
          this.emit("info", true);
        }
        return this._bufpos = pos + needleLength;
      } else {
        pos = len - needleLength;
      }
      while (pos < len && (data[pos] !== needle[0] || Buffer.compare(
        data.subarray(pos, pos + len - pos),
        needle.subarray(0, len - pos)
      ) !== 0)) {
        ++pos;
      }
      if (pos < len) {
        data.copy(this._lookbehind, 0, pos, pos + (len - pos));
        this._lookbehind_size = len - pos;
      }
      if (pos > 0) {
        this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
      }
      this._bufpos = len;
      return len;
    };
    SBMH.prototype._sbmh_lookup_char = function(data, pos) {
      return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
    };
    SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
      for (var i3 = 0; i3 < len; ++i3) {
        if (this._sbmh_lookup_char(data, pos + i3) !== this._needle[i3]) {
          return false;
        }
      }
      return true;
    };
    module2.exports = SBMH;
  }
});

// ../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS({
  "../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js"(exports2, module2) {
    "use strict";
    var inherits = require("node:util").inherits;
    var ReadableStream = require("node:stream").Readable;
    function PartStream(opts) {
      ReadableStream.call(this, opts);
    }
    inherits(PartStream, ReadableStream);
    PartStream.prototype._read = function(n3) {
    };
    module2.exports = PartStream;
  }
});

// ../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS({
  "../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/getLimit.js"(exports2, module2) {
    "use strict";
    module2.exports = function getLimit(limits, name, defaultLimit) {
      if (!limits || limits[name] === void 0 || limits[name] === null) {
        return defaultLimit;
      }
      if (typeof limits[name] !== "number" || isNaN(limits[name])) {
        throw new TypeError("Limit " + name + " is not a valid number");
      }
      return limits[name];
    };
  }
});

// ../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS({
  "../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("node:events").EventEmitter;
    var inherits = require("node:util").inherits;
    var getLimit = require_getLimit();
    var StreamSearch = require_sbmh();
    var B_DCRLF = Buffer.from("\r\n\r\n");
    var RE_CRLF = /\r\n/g;
    var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
    function HeaderParser(cfg) {
      EventEmitter.call(this);
      cfg = cfg || {};
      const self2 = this;
      this.nread = 0;
      this.maxed = false;
      this.npairs = 0;
      this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2e3);
      this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
      this.buffer = "";
      this.header = {};
      this.finished = false;
      this.ss = new StreamSearch(B_DCRLF);
      this.ss.on("info", function(isMatch, data, start, end) {
        if (data && !self2.maxed) {
          if (self2.nread + end - start >= self2.maxHeaderSize) {
            end = self2.maxHeaderSize - self2.nread + start;
            self2.nread = self2.maxHeaderSize;
            self2.maxed = true;
          } else {
            self2.nread += end - start;
          }
          self2.buffer += data.toString("binary", start, end);
        }
        if (isMatch) {
          self2._finish();
        }
      });
    }
    inherits(HeaderParser, EventEmitter);
    HeaderParser.prototype.push = function(data) {
      const r3 = this.ss.push(data);
      if (this.finished) {
        return r3;
      }
    };
    HeaderParser.prototype.reset = function() {
      this.finished = false;
      this.buffer = "";
      this.header = {};
      this.ss.reset();
    };
    HeaderParser.prototype._finish = function() {
      if (this.buffer) {
        this._parseHeader();
      }
      this.ss.matches = this.ss.maxMatches;
      const header = this.header;
      this.header = {};
      this.buffer = "";
      this.finished = true;
      this.nread = this.npairs = 0;
      this.maxed = false;
      this.emit("header", header);
    };
    HeaderParser.prototype._parseHeader = function() {
      if (this.npairs === this.maxHeaderPairs) {
        return;
      }
      const lines = this.buffer.split(RE_CRLF);
      const len = lines.length;
      let m, h3;
      for (var i3 = 0; i3 < len; ++i3) {
        if (lines[i3].length === 0) {
          continue;
        }
        if (lines[i3][0] === "	" || lines[i3][0] === " ") {
          if (h3) {
            this.header[h3][this.header[h3].length - 1] += lines[i3];
            continue;
          }
        }
        const posColon = lines[i3].indexOf(":");
        if (posColon === -1 || posColon === 0) {
          return;
        }
        m = RE_HDR.exec(lines[i3]);
        h3 = m[1].toLowerCase();
        this.header[h3] = this.header[h3] || [];
        this.header[h3].push(m[2] || "");
        if (++this.npairs === this.maxHeaderPairs) {
          break;
        }
      }
    };
    module2.exports = HeaderParser;
  }
});

// ../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS({
  "../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js"(exports2, module2) {
    "use strict";
    var WritableStream = require("node:stream").Writable;
    var inherits = require("node:util").inherits;
    var StreamSearch = require_sbmh();
    var PartStream = require_PartStream();
    var HeaderParser = require_HeaderParser();
    var DASH = 45;
    var B_ONEDASH = Buffer.from("-");
    var B_CRLF = Buffer.from("\r\n");
    var EMPTY_FN = function() {
    };
    function Dicer(cfg) {
      if (!(this instanceof Dicer)) {
        return new Dicer(cfg);
      }
      WritableStream.call(this, cfg);
      if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {
        throw new TypeError("Boundary required");
      }
      if (typeof cfg.boundary === "string") {
        this.setBoundary(cfg.boundary);
      } else {
        this._bparser = void 0;
      }
      this._headerFirst = cfg.headerFirst;
      this._dashes = 0;
      this._parts = 0;
      this._finished = false;
      this._realFinish = false;
      this._isPreamble = true;
      this._justMatched = false;
      this._firstWrite = true;
      this._inHeader = true;
      this._part = void 0;
      this._cb = void 0;
      this._ignoreData = false;
      this._partOpts = { highWaterMark: cfg.partHwm };
      this._pause = false;
      const self2 = this;
      this._hparser = new HeaderParser(cfg);
      this._hparser.on("header", function(header) {
        self2._inHeader = false;
        self2._part.emit("header", header);
      });
    }
    inherits(Dicer, WritableStream);
    Dicer.prototype.emit = function(ev) {
      if (ev === "finish" && !this._realFinish) {
        if (!this._finished) {
          const self2 = this;
          process.nextTick(function() {
            self2.emit("error", new Error("Unexpected end of multipart data"));
            if (self2._part && !self2._ignoreData) {
              const type = self2._isPreamble ? "Preamble" : "Part";
              self2._part.emit("error", new Error(type + " terminated early due to unexpected end of multipart data"));
              self2._part.push(null);
              process.nextTick(function() {
                self2._realFinish = true;
                self2.emit("finish");
                self2._realFinish = false;
              });
              return;
            }
            self2._realFinish = true;
            self2.emit("finish");
            self2._realFinish = false;
          });
        }
      } else {
        WritableStream.prototype.emit.apply(this, arguments);
      }
    };
    Dicer.prototype._write = function(data, encoding, cb) {
      if (!this._hparser && !this._bparser) {
        return cb();
      }
      if (this._headerFirst && this._isPreamble) {
        if (!this._part) {
          this._part = new PartStream(this._partOpts);
          if (this.listenerCount("preamble") !== 0) {
            this.emit("preamble", this._part);
          } else {
            this._ignore();
          }
        }
        const r3 = this._hparser.push(data);
        if (!this._inHeader && r3 !== void 0 && r3 < data.length) {
          data = data.slice(r3);
        } else {
          return cb();
        }
      }
      if (this._firstWrite) {
        this._bparser.push(B_CRLF);
        this._firstWrite = false;
      }
      this._bparser.push(data);
      if (this._pause) {
        this._cb = cb;
      } else {
        cb();
      }
    };
    Dicer.prototype.reset = function() {
      this._part = void 0;
      this._bparser = void 0;
      this._hparser = void 0;
    };
    Dicer.prototype.setBoundary = function(boundary) {
      const self2 = this;
      this._bparser = new StreamSearch("\r\n--" + boundary);
      this._bparser.on("info", function(isMatch, data, start, end) {
        self2._oninfo(isMatch, data, start, end);
      });
    };
    Dicer.prototype._ignore = function() {
      if (this._part && !this._ignoreData) {
        this._ignoreData = true;
        this._part.on("error", EMPTY_FN);
        this._part.resume();
      }
    };
    Dicer.prototype._oninfo = function(isMatch, data, start, end) {
      let buf;
      const self2 = this;
      let i3 = 0;
      let r3;
      let shouldWriteMore = true;
      if (!this._part && this._justMatched && data) {
        while (this._dashes < 2 && start + i3 < end) {
          if (data[start + i3] === DASH) {
            ++i3;
            ++this._dashes;
          } else {
            if (this._dashes) {
              buf = B_ONEDASH;
            }
            this._dashes = 0;
            break;
          }
        }
        if (this._dashes === 2) {
          if (start + i3 < end && this.listenerCount("trailer") !== 0) {
            this.emit("trailer", data.slice(start + i3, end));
          }
          this.reset();
          this._finished = true;
          if (self2._parts === 0) {
            self2._realFinish = true;
            self2.emit("finish");
            self2._realFinish = false;
          }
        }
        if (this._dashes) {
          return;
        }
      }
      if (this._justMatched) {
        this._justMatched = false;
      }
      if (!this._part) {
        this._part = new PartStream(this._partOpts);
        this._part._read = function(n3) {
          self2._unpause();
        };
        if (this._isPreamble && this.listenerCount("preamble") !== 0) {
          this.emit("preamble", this._part);
        } else if (this._isPreamble !== true && this.listenerCount("part") !== 0) {
          this.emit("part", this._part);
        } else {
          this._ignore();
        }
        if (!this._isPreamble) {
          this._inHeader = true;
        }
      }
      if (data && start < end && !this._ignoreData) {
        if (this._isPreamble || !this._inHeader) {
          if (buf) {
            shouldWriteMore = this._part.push(buf);
          }
          shouldWriteMore = this._part.push(data.slice(start, end));
          if (!shouldWriteMore) {
            this._pause = true;
          }
        } else if (!this._isPreamble && this._inHeader) {
          if (buf) {
            this._hparser.push(buf);
          }
          r3 = this._hparser.push(data.slice(start, end));
          if (!this._inHeader && r3 !== void 0 && r3 < end) {
            this._oninfo(false, data, start + r3, end);
          }
        }
      }
      if (isMatch) {
        this._hparser.reset();
        if (this._isPreamble) {
          this._isPreamble = false;
        } else {
          if (start !== end) {
            ++this._parts;
            this._part.on("end", function() {
              if (--self2._parts === 0) {
                if (self2._finished) {
                  self2._realFinish = true;
                  self2.emit("finish");
                  self2._realFinish = false;
                } else {
                  self2._unpause();
                }
              }
            });
          }
        }
        this._part.push(null);
        this._part = void 0;
        this._ignoreData = false;
        this._justMatched = true;
        this._dashes = 0;
      }
    };
    Dicer.prototype._unpause = function() {
      if (!this._pause) {
        return;
      }
      this._pause = false;
      if (this._cb) {
        const cb = this._cb;
        this._cb = void 0;
        cb();
      }
    };
    module2.exports = Dicer;
  }
});

// ../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS({
  "../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/decodeText.js"(exports2, module2) {
    "use strict";
    var utf8Decoder = new TextDecoder("utf-8");
    var textDecoders = /* @__PURE__ */ new Map([
      ["utf-8", utf8Decoder],
      ["utf8", utf8Decoder]
    ]);
    function getDecoder(charset) {
      let lc;
      while (true) {
        switch (charset) {
          case "utf-8":
          case "utf8":
            return decoders.utf8;
          case "latin1":
          case "ascii":
          // TODO: Make these a separate, strict decoder?
          case "us-ascii":
          case "iso-8859-1":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "windows-1252":
          case "iso_8859-1:1987":
          case "cp1252":
          case "x-cp1252":
            return decoders.latin1;
          case "utf16le":
          case "utf-16le":
          case "ucs2":
          case "ucs-2":
            return decoders.utf16le;
          case "base64":
            return decoders.base64;
          default:
            if (lc === void 0) {
              lc = true;
              charset = charset.toLowerCase();
              continue;
            }
            return decoders.other.bind(charset);
        }
      }
    }
    var decoders = {
      utf8: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.utf8Slice(0, data.length);
      },
      latin1: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          return data;
        }
        return data.latin1Slice(0, data.length);
      },
      utf16le: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.ucs2Slice(0, data.length);
      },
      base64: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.base64Slice(0, data.length);
      },
      other: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        if (textDecoders.has(exports2.toString())) {
          try {
            return textDecoders.get(exports2).decode(data);
          } catch {
          }
        }
        return typeof data === "string" ? data : data.toString();
      }
    };
    function decodeText(text, sourceEncoding, destEncoding) {
      if (text) {
        return getDecoder(destEncoding)(text, sourceEncoding);
      }
      return text;
    }
    module2.exports = decodeText;
  }
});

// ../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS({
  "../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/parseParams.js"(exports2, module2) {
    "use strict";
    var decodeText = require_decodeText();
    var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
    var EncodedLookup = {
      "%00": "\0",
      "%01": "",
      "%02": "",
      "%03": "",
      "%04": "",
      "%05": "",
      "%06": "",
      "%07": "\x07",
      "%08": "\b",
      "%09": "	",
      "%0a": "\n",
      "%0A": "\n",
      "%0b": "\v",
      "%0B": "\v",
      "%0c": "\f",
      "%0C": "\f",
      "%0d": "\r",
      "%0D": "\r",
      "%0e": "",
      "%0E": "",
      "%0f": "",
      "%0F": "",
      "%10": "",
      "%11": "",
      "%12": "",
      "%13": "",
      "%14": "",
      "%15": "",
      "%16": "",
      "%17": "",
      "%18": "",
      "%19": "",
      "%1a": "",
      "%1A": "",
      "%1b": "\x1B",
      "%1B": "\x1B",
      "%1c": "",
      "%1C": "",
      "%1d": "",
      "%1D": "",
      "%1e": "",
      "%1E": "",
      "%1f": "",
      "%1F": "",
      "%20": " ",
      "%21": "!",
      "%22": '"',
      "%23": "#",
      "%24": "$",
      "%25": "%",
      "%26": "&",
      "%27": "'",
      "%28": "(",
      "%29": ")",
      "%2a": "*",
      "%2A": "*",
      "%2b": "+",
      "%2B": "+",
      "%2c": ",",
      "%2C": ",",
      "%2d": "-",
      "%2D": "-",
      "%2e": ".",
      "%2E": ".",
      "%2f": "/",
      "%2F": "/",
      "%30": "0",
      "%31": "1",
      "%32": "2",
      "%33": "3",
      "%34": "4",
      "%35": "5",
      "%36": "6",
      "%37": "7",
      "%38": "8",
      "%39": "9",
      "%3a": ":",
      "%3A": ":",
      "%3b": ";",
      "%3B": ";",
      "%3c": "<",
      "%3C": "<",
      "%3d": "=",
      "%3D": "=",
      "%3e": ">",
      "%3E": ">",
      "%3f": "?",
      "%3F": "?",
      "%40": "@",
      "%41": "A",
      "%42": "B",
      "%43": "C",
      "%44": "D",
      "%45": "E",
      "%46": "F",
      "%47": "G",
      "%48": "H",
      "%49": "I",
      "%4a": "J",
      "%4A": "J",
      "%4b": "K",
      "%4B": "K",
      "%4c": "L",
      "%4C": "L",
      "%4d": "M",
      "%4D": "M",
      "%4e": "N",
      "%4E": "N",
      "%4f": "O",
      "%4F": "O",
      "%50": "P",
      "%51": "Q",
      "%52": "R",
      "%53": "S",
      "%54": "T",
      "%55": "U",
      "%56": "V",
      "%57": "W",
      "%58": "X",
      "%59": "Y",
      "%5a": "Z",
      "%5A": "Z",
      "%5b": "[",
      "%5B": "[",
      "%5c": "\\",
      "%5C": "\\",
      "%5d": "]",
      "%5D": "]",
      "%5e": "^",
      "%5E": "^",
      "%5f": "_",
      "%5F": "_",
      "%60": "`",
      "%61": "a",
      "%62": "b",
      "%63": "c",
      "%64": "d",
      "%65": "e",
      "%66": "f",
      "%67": "g",
      "%68": "h",
      "%69": "i",
      "%6a": "j",
      "%6A": "j",
      "%6b": "k",
      "%6B": "k",
      "%6c": "l",
      "%6C": "l",
      "%6d": "m",
      "%6D": "m",
      "%6e": "n",
      "%6E": "n",
      "%6f": "o",
      "%6F": "o",
      "%70": "p",
      "%71": "q",
      "%72": "r",
      "%73": "s",
      "%74": "t",
      "%75": "u",
      "%76": "v",
      "%77": "w",
      "%78": "x",
      "%79": "y",
      "%7a": "z",
      "%7A": "z",
      "%7b": "{",
      "%7B": "{",
      "%7c": "|",
      "%7C": "|",
      "%7d": "}",
      "%7D": "}",
      "%7e": "~",
      "%7E": "~",
      "%7f": "\x7F",
      "%7F": "\x7F",
      "%80": "\x80",
      "%81": "\x81",
      "%82": "\x82",
      "%83": "\x83",
      "%84": "\x84",
      "%85": "\x85",
      "%86": "\x86",
      "%87": "\x87",
      "%88": "\x88",
      "%89": "\x89",
      "%8a": "\x8A",
      "%8A": "\x8A",
      "%8b": "\x8B",
      "%8B": "\x8B",
      "%8c": "\x8C",
      "%8C": "\x8C",
      "%8d": "\x8D",
      "%8D": "\x8D",
      "%8e": "\x8E",
      "%8E": "\x8E",
      "%8f": "\x8F",
      "%8F": "\x8F",
      "%90": "\x90",
      "%91": "\x91",
      "%92": "\x92",
      "%93": "\x93",
      "%94": "\x94",
      "%95": "\x95",
      "%96": "\x96",
      "%97": "\x97",
      "%98": "\x98",
      "%99": "\x99",
      "%9a": "\x9A",
      "%9A": "\x9A",
      "%9b": "\x9B",
      "%9B": "\x9B",
      "%9c": "\x9C",
      "%9C": "\x9C",
      "%9d": "\x9D",
      "%9D": "\x9D",
      "%9e": "\x9E",
      "%9E": "\x9E",
      "%9f": "\x9F",
      "%9F": "\x9F",
      "%a0": "\xA0",
      "%A0": "\xA0",
      "%a1": "\xA1",
      "%A1": "\xA1",
      "%a2": "\xA2",
      "%A2": "\xA2",
      "%a3": "\xA3",
      "%A3": "\xA3",
      "%a4": "\xA4",
      "%A4": "\xA4",
      "%a5": "\xA5",
      "%A5": "\xA5",
      "%a6": "\xA6",
      "%A6": "\xA6",
      "%a7": "\xA7",
      "%A7": "\xA7",
      "%a8": "\xA8",
      "%A8": "\xA8",
      "%a9": "\xA9",
      "%A9": "\xA9",
      "%aa": "\xAA",
      "%Aa": "\xAA",
      "%aA": "\xAA",
      "%AA": "\xAA",
      "%ab": "\xAB",
      "%Ab": "\xAB",
      "%aB": "\xAB",
      "%AB": "\xAB",
      "%ac": "\xAC",
      "%Ac": "\xAC",
      "%aC": "\xAC",
      "%AC": "\xAC",
      "%ad": "\xAD",
      "%Ad": "\xAD",
      "%aD": "\xAD",
      "%AD": "\xAD",
      "%ae": "\xAE",
      "%Ae": "\xAE",
      "%aE": "\xAE",
      "%AE": "\xAE",
      "%af": "\xAF",
      "%Af": "\xAF",
      "%aF": "\xAF",
      "%AF": "\xAF",
      "%b0": "\xB0",
      "%B0": "\xB0",
      "%b1": "\xB1",
      "%B1": "\xB1",
      "%b2": "\xB2",
      "%B2": "\xB2",
      "%b3": "\xB3",
      "%B3": "\xB3",
      "%b4": "\xB4",
      "%B4": "\xB4",
      "%b5": "\xB5",
      "%B5": "\xB5",
      "%b6": "\xB6",
      "%B6": "\xB6",
      "%b7": "\xB7",
      "%B7": "\xB7",
      "%b8": "\xB8",
      "%B8": "\xB8",
      "%b9": "\xB9",
      "%B9": "\xB9",
      "%ba": "\xBA",
      "%Ba": "\xBA",
      "%bA": "\xBA",
      "%BA": "\xBA",
      "%bb": "\xBB",
      "%Bb": "\xBB",
      "%bB": "\xBB",
      "%BB": "\xBB",
      "%bc": "\xBC",
      "%Bc": "\xBC",
      "%bC": "\xBC",
      "%BC": "\xBC",
      "%bd": "\xBD",
      "%Bd": "\xBD",
      "%bD": "\xBD",
      "%BD": "\xBD",
      "%be": "\xBE",
      "%Be": "\xBE",
      "%bE": "\xBE",
      "%BE": "\xBE",
      "%bf": "\xBF",
      "%Bf": "\xBF",
      "%bF": "\xBF",
      "%BF": "\xBF",
      "%c0": "\xC0",
      "%C0": "\xC0",
      "%c1": "\xC1",
      "%C1": "\xC1",
      "%c2": "\xC2",
      "%C2": "\xC2",
      "%c3": "\xC3",
      "%C3": "\xC3",
      "%c4": "\xC4",
      "%C4": "\xC4",
      "%c5": "\xC5",
      "%C5": "\xC5",
      "%c6": "\xC6",
      "%C6": "\xC6",
      "%c7": "\xC7",
      "%C7": "\xC7",
      "%c8": "\xC8",
      "%C8": "\xC8",
      "%c9": "\xC9",
      "%C9": "\xC9",
      "%ca": "\xCA",
      "%Ca": "\xCA",
      "%cA": "\xCA",
      "%CA": "\xCA",
      "%cb": "\xCB",
      "%Cb": "\xCB",
      "%cB": "\xCB",
      "%CB": "\xCB",
      "%cc": "\xCC",
      "%Cc": "\xCC",
      "%cC": "\xCC",
      "%CC": "\xCC",
      "%cd": "\xCD",
      "%Cd": "\xCD",
      "%cD": "\xCD",
      "%CD": "\xCD",
      "%ce": "\xCE",
      "%Ce": "\xCE",
      "%cE": "\xCE",
      "%CE": "\xCE",
      "%cf": "\xCF",
      "%Cf": "\xCF",
      "%cF": "\xCF",
      "%CF": "\xCF",
      "%d0": "\xD0",
      "%D0": "\xD0",
      "%d1": "\xD1",
      "%D1": "\xD1",
      "%d2": "\xD2",
      "%D2": "\xD2",
      "%d3": "\xD3",
      "%D3": "\xD3",
      "%d4": "\xD4",
      "%D4": "\xD4",
      "%d5": "\xD5",
      "%D5": "\xD5",
      "%d6": "\xD6",
      "%D6": "\xD6",
      "%d7": "\xD7",
      "%D7": "\xD7",
      "%d8": "\xD8",
      "%D8": "\xD8",
      "%d9": "\xD9",
      "%D9": "\xD9",
      "%da": "\xDA",
      "%Da": "\xDA",
      "%dA": "\xDA",
      "%DA": "\xDA",
      "%db": "\xDB",
      "%Db": "\xDB",
      "%dB": "\xDB",
      "%DB": "\xDB",
      "%dc": "\xDC",
      "%Dc": "\xDC",
      "%dC": "\xDC",
      "%DC": "\xDC",
      "%dd": "\xDD",
      "%Dd": "\xDD",
      "%dD": "\xDD",
      "%DD": "\xDD",
      "%de": "\xDE",
      "%De": "\xDE",
      "%dE": "\xDE",
      "%DE": "\xDE",
      "%df": "\xDF",
      "%Df": "\xDF",
      "%dF": "\xDF",
      "%DF": "\xDF",
      "%e0": "\xE0",
      "%E0": "\xE0",
      "%e1": "\xE1",
      "%E1": "\xE1",
      "%e2": "\xE2",
      "%E2": "\xE2",
      "%e3": "\xE3",
      "%E3": "\xE3",
      "%e4": "\xE4",
      "%E4": "\xE4",
      "%e5": "\xE5",
      "%E5": "\xE5",
      "%e6": "\xE6",
      "%E6": "\xE6",
      "%e7": "\xE7",
      "%E7": "\xE7",
      "%e8": "\xE8",
      "%E8": "\xE8",
      "%e9": "\xE9",
      "%E9": "\xE9",
      "%ea": "\xEA",
      "%Ea": "\xEA",
      "%eA": "\xEA",
      "%EA": "\xEA",
      "%eb": "\xEB",
      "%Eb": "\xEB",
      "%eB": "\xEB",
      "%EB": "\xEB",
      "%ec": "\xEC",
      "%Ec": "\xEC",
      "%eC": "\xEC",
      "%EC": "\xEC",
      "%ed": "\xED",
      "%Ed": "\xED",
      "%eD": "\xED",
      "%ED": "\xED",
      "%ee": "\xEE",
      "%Ee": "\xEE",
      "%eE": "\xEE",
      "%EE": "\xEE",
      "%ef": "\xEF",
      "%Ef": "\xEF",
      "%eF": "\xEF",
      "%EF": "\xEF",
      "%f0": "\xF0",
      "%F0": "\xF0",
      "%f1": "\xF1",
      "%F1": "\xF1",
      "%f2": "\xF2",
      "%F2": "\xF2",
      "%f3": "\xF3",
      "%F3": "\xF3",
      "%f4": "\xF4",
      "%F4": "\xF4",
      "%f5": "\xF5",
      "%F5": "\xF5",
      "%f6": "\xF6",
      "%F6": "\xF6",
      "%f7": "\xF7",
      "%F7": "\xF7",
      "%f8": "\xF8",
      "%F8": "\xF8",
      "%f9": "\xF9",
      "%F9": "\xF9",
      "%fa": "\xFA",
      "%Fa": "\xFA",
      "%fA": "\xFA",
      "%FA": "\xFA",
      "%fb": "\xFB",
      "%Fb": "\xFB",
      "%fB": "\xFB",
      "%FB": "\xFB",
      "%fc": "\xFC",
      "%Fc": "\xFC",
      "%fC": "\xFC",
      "%FC": "\xFC",
      "%fd": "\xFD",
      "%Fd": "\xFD",
      "%fD": "\xFD",
      "%FD": "\xFD",
      "%fe": "\xFE",
      "%Fe": "\xFE",
      "%fE": "\xFE",
      "%FE": "\xFE",
      "%ff": "\xFF",
      "%Ff": "\xFF",
      "%fF": "\xFF",
      "%FF": "\xFF"
    };
    function encodedReplacer(match) {
      return EncodedLookup[match];
    }
    var STATE_KEY = 0;
    var STATE_VALUE = 1;
    var STATE_CHARSET = 2;
    var STATE_LANG = 3;
    function parseParams(str) {
      const res = [];
      let state = STATE_KEY;
      let charset = "";
      let inquote = false;
      let escaping = false;
      let p3 = 0;
      let tmp = "";
      const len = str.length;
      for (var i3 = 0; i3 < len; ++i3) {
        const char = str[i3];
        if (char === "\\" && inquote) {
          if (escaping) {
            escaping = false;
          } else {
            escaping = true;
            continue;
          }
        } else if (char === '"') {
          if (!escaping) {
            if (inquote) {
              inquote = false;
              state = STATE_KEY;
            } else {
              inquote = true;
            }
            continue;
          } else {
            escaping = false;
          }
        } else {
          if (escaping && inquote) {
            tmp += "\\";
          }
          escaping = false;
          if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
            if (state === STATE_CHARSET) {
              state = STATE_LANG;
              charset = tmp.substring(1);
            } else {
              state = STATE_VALUE;
            }
            tmp = "";
            continue;
          } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
            state = char === "*" ? STATE_CHARSET : STATE_VALUE;
            res[p3] = [tmp, void 0];
            tmp = "";
            continue;
          } else if (!inquote && char === ";") {
            state = STATE_KEY;
            if (charset) {
              if (tmp.length) {
                tmp = decodeText(
                  tmp.replace(RE_ENCODED, encodedReplacer),
                  "binary",
                  charset
                );
              }
              charset = "";
            } else if (tmp.length) {
              tmp = decodeText(tmp, "binary", "utf8");
            }
            if (res[p3] === void 0) {
              res[p3] = tmp;
            } else {
              res[p3][1] = tmp;
            }
            tmp = "";
            ++p3;
            continue;
          } else if (!inquote && (char === " " || char === "	")) {
            continue;
          }
        }
        tmp += char;
      }
      if (charset && tmp.length) {
        tmp = decodeText(
          tmp.replace(RE_ENCODED, encodedReplacer),
          "binary",
          charset
        );
      } else if (tmp) {
        tmp = decodeText(tmp, "binary", "utf8");
      }
      if (res[p3] === void 0) {
        if (tmp) {
          res[p3] = tmp;
        }
      } else {
        res[p3][1] = tmp;
      }
      return res;
    }
    module2.exports = parseParams;
  }
});

// ../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS({
  "../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/basename.js"(exports2, module2) {
    "use strict";
    module2.exports = function basename(path2) {
      if (typeof path2 !== "string") {
        return "";
      }
      for (var i3 = path2.length - 1; i3 >= 0; --i3) {
        switch (path2.charCodeAt(i3)) {
          case 47:
          // '/'
          case 92:
            path2 = path2.slice(i3 + 1);
            return path2 === ".." || path2 === "." ? "" : path2;
        }
      }
      return path2 === ".." || path2 === "." ? "" : path2;
    };
  }
});

// ../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS({
  "../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/multipart.js"(exports2, module2) {
    "use strict";
    var { Readable } = require("node:stream");
    var { inherits } = require("node:util");
    var Dicer = require_Dicer();
    var parseParams = require_parseParams();
    var decodeText = require_decodeText();
    var basename = require_basename();
    var getLimit = require_getLimit();
    var RE_BOUNDARY = /^boundary$/i;
    var RE_FIELD = /^form-data$/i;
    var RE_CHARSET = /^charset$/i;
    var RE_FILENAME = /^filename$/i;
    var RE_NAME = /^name$/i;
    Multipart.detect = /^multipart\/form-data/i;
    function Multipart(boy, cfg) {
      let i3;
      let len;
      const self2 = this;
      let boundary;
      const limits = cfg.limits;
      const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
      const parsedConType = cfg.parsedConType || [];
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = { highWaterMark: cfg.fileHwm };
      for (i3 = 0, len = parsedConType.length; i3 < len; ++i3) {
        if (Array.isArray(parsedConType[i3]) && RE_BOUNDARY.test(parsedConType[i3][0])) {
          boundary = parsedConType[i3][1];
          break;
        }
      }
      function checkFinished() {
        if (nends === 0 && finished && !boy._done) {
          finished = false;
          self2.end();
        }
      }
      if (typeof boundary !== "string") {
        throw new Error("Multipart: Boundary not found");
      }
      const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
      const filesLimit = getLimit(limits, "files", Infinity);
      const fieldsLimit = getLimit(limits, "fields", Infinity);
      const partsLimit = getLimit(limits, "parts", Infinity);
      const headerPairsLimit = getLimit(limits, "headerPairs", 2e3);
      const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);
      let nfiles = 0;
      let nfields = 0;
      let nends = 0;
      let curFile;
      let curField;
      let finished = false;
      this._needDrain = false;
      this._pause = false;
      this._cb = void 0;
      this._nparts = 0;
      this._boy = boy;
      const parserCfg = {
        boundary,
        maxHeaderPairs: headerPairsLimit,
        maxHeaderSize: headerSizeLimit,
        partHwm: fileOpts.highWaterMark,
        highWaterMark: cfg.highWaterMark
      };
      this.parser = new Dicer(parserCfg);
      this.parser.on("drain", function() {
        self2._needDrain = false;
        if (self2._cb && !self2._pause) {
          const cb = self2._cb;
          self2._cb = void 0;
          cb();
        }
      }).on("part", function onPart(part) {
        if (++self2._nparts > partsLimit) {
          self2.parser.removeListener("part", onPart);
          self2.parser.on("part", skipPart);
          boy.hitPartsLimit = true;
          boy.emit("partsLimit");
          return skipPart(part);
        }
        if (curField) {
          const field = curField;
          field.emit("end");
          field.removeAllListeners("end");
        }
        part.on("header", function(header) {
          let contype;
          let fieldname;
          let parsed;
          let charset;
          let encoding;
          let filename;
          let nsize = 0;
          if (header["content-type"]) {
            parsed = parseParams(header["content-type"][0]);
            if (parsed[0]) {
              contype = parsed[0].toLowerCase();
              for (i3 = 0, len = parsed.length; i3 < len; ++i3) {
                if (RE_CHARSET.test(parsed[i3][0])) {
                  charset = parsed[i3][1].toLowerCase();
                  break;
                }
              }
            }
          }
          if (contype === void 0) {
            contype = "text/plain";
          }
          if (charset === void 0) {
            charset = defCharset;
          }
          if (header["content-disposition"]) {
            parsed = parseParams(header["content-disposition"][0]);
            if (!RE_FIELD.test(parsed[0])) {
              return skipPart(part);
            }
            for (i3 = 0, len = parsed.length; i3 < len; ++i3) {
              if (RE_NAME.test(parsed[i3][0])) {
                fieldname = parsed[i3][1];
              } else if (RE_FILENAME.test(parsed[i3][0])) {
                filename = parsed[i3][1];
                if (!preservePath) {
                  filename = basename(filename);
                }
              }
            }
          } else {
            return skipPart(part);
          }
          if (header["content-transfer-encoding"]) {
            encoding = header["content-transfer-encoding"][0].toLowerCase();
          } else {
            encoding = "7bit";
          }
          let onData, onEnd;
          if (isPartAFile(fieldname, contype, filename)) {
            if (nfiles === filesLimit) {
              if (!boy.hitFilesLimit) {
                boy.hitFilesLimit = true;
                boy.emit("filesLimit");
              }
              return skipPart(part);
            }
            ++nfiles;
            if (boy.listenerCount("file") === 0) {
              self2.parser._ignore();
              return;
            }
            ++nends;
            const file = new FileStream(fileOpts);
            curFile = file;
            file.on("end", function() {
              --nends;
              self2._pause = false;
              checkFinished();
              if (self2._cb && !self2._needDrain) {
                const cb = self2._cb;
                self2._cb = void 0;
                cb();
              }
            });
            file._read = function(n3) {
              if (!self2._pause) {
                return;
              }
              self2._pause = false;
              if (self2._cb && !self2._needDrain) {
                const cb = self2._cb;
                self2._cb = void 0;
                cb();
              }
            };
            boy.emit("file", fieldname, file, filename, encoding, contype);
            onData = function(data) {
              if ((nsize += data.length) > fileSizeLimit) {
                const extralen = fileSizeLimit - nsize + data.length;
                if (extralen > 0) {
                  file.push(data.slice(0, extralen));
                }
                file.truncated = true;
                file.bytesRead = fileSizeLimit;
                part.removeAllListeners("data");
                file.emit("limit");
                return;
              } else if (!file.push(data)) {
                self2._pause = true;
              }
              file.bytesRead = nsize;
            };
            onEnd = function() {
              curFile = void 0;
              file.push(null);
            };
          } else {
            if (nfields === fieldsLimit) {
              if (!boy.hitFieldsLimit) {
                boy.hitFieldsLimit = true;
                boy.emit("fieldsLimit");
              }
              return skipPart(part);
            }
            ++nfields;
            ++nends;
            let buffer = "";
            let truncated = false;
            curField = part;
            onData = function(data) {
              if ((nsize += data.length) > fieldSizeLimit) {
                const extralen = fieldSizeLimit - (nsize - data.length);
                buffer += data.toString("binary", 0, extralen);
                truncated = true;
                part.removeAllListeners("data");
              } else {
                buffer += data.toString("binary");
              }
            };
            onEnd = function() {
              curField = void 0;
              if (buffer.length) {
                buffer = decodeText(buffer, "binary", charset);
              }
              boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);
              --nends;
              checkFinished();
            };
          }
          part._readableState.sync = false;
          part.on("data", onData);
          part.on("end", onEnd);
        }).on("error", function(err) {
          if (curFile) {
            curFile.emit("error", err);
          }
        });
      }).on("error", function(err) {
        boy.emit("error", err);
      }).on("finish", function() {
        finished = true;
        checkFinished();
      });
    }
    Multipart.prototype.write = function(chunk, cb) {
      const r3 = this.parser.write(chunk);
      if (r3 && !this._pause) {
        cb();
      } else {
        this._needDrain = !r3;
        this._cb = cb;
      }
    };
    Multipart.prototype.end = function() {
      const self2 = this;
      if (self2.parser.writable) {
        self2.parser.end();
      } else if (!self2._boy._done) {
        process.nextTick(function() {
          self2._boy._done = true;
          self2._boy.emit("finish");
        });
      }
    };
    function skipPart(part) {
      part.resume();
    }
    function FileStream(opts) {
      Readable.call(this, opts);
      this.bytesRead = 0;
      this.truncated = false;
    }
    inherits(FileStream, Readable);
    FileStream.prototype._read = function(n3) {
    };
    module2.exports = Multipart;
  }
});

// ../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS({
  "../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/utils/Decoder.js"(exports2, module2) {
    "use strict";
    var RE_PLUS = /\+/g;
    var HEX = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    function Decoder() {
      this.buffer = void 0;
    }
    Decoder.prototype.write = function(str) {
      str = str.replace(RE_PLUS, " ");
      let res = "";
      let i3 = 0;
      let p3 = 0;
      const len = str.length;
      for (; i3 < len; ++i3) {
        if (this.buffer !== void 0) {
          if (!HEX[str.charCodeAt(i3)]) {
            res += "%" + this.buffer;
            this.buffer = void 0;
            --i3;
          } else {
            this.buffer += str[i3];
            ++p3;
            if (this.buffer.length === 2) {
              res += String.fromCharCode(parseInt(this.buffer, 16));
              this.buffer = void 0;
            }
          }
        } else if (str[i3] === "%") {
          if (i3 > p3) {
            res += str.substring(p3, i3);
            p3 = i3;
          }
          this.buffer = "";
          ++p3;
        }
      }
      if (p3 < len && this.buffer === void 0) {
        res += str.substring(p3);
      }
      return res;
    };
    Decoder.prototype.reset = function() {
      this.buffer = void 0;
    };
    module2.exports = Decoder;
  }
});

// ../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/types/urlencoded.js"(exports2, module2) {
    "use strict";
    var Decoder = require_Decoder();
    var decodeText = require_decodeText();
    var getLimit = require_getLimit();
    var RE_CHARSET = /^charset$/i;
    UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
    function UrlEncoded(boy, cfg) {
      const limits = cfg.limits;
      const parsedConType = cfg.parsedConType;
      this.boy = boy;
      this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
      this.fieldsLimit = getLimit(limits, "fields", Infinity);
      let charset;
      for (var i3 = 0, len = parsedConType.length; i3 < len; ++i3) {
        if (Array.isArray(parsedConType[i3]) && RE_CHARSET.test(parsedConType[i3][0])) {
          charset = parsedConType[i3][1].toLowerCase();
          break;
        }
      }
      if (charset === void 0) {
        charset = cfg.defCharset || "utf8";
      }
      this.decoder = new Decoder();
      this.charset = charset;
      this._fields = 0;
      this._state = "key";
      this._checkingBytes = true;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._key = "";
      this._val = "";
      this._keyTrunc = false;
      this._valTrunc = false;
      this._hitLimit = false;
    }
    UrlEncoded.prototype.write = function(data, cb) {
      if (this._fields === this.fieldsLimit) {
        if (!this.boy.hitFieldsLimit) {
          this.boy.hitFieldsLimit = true;
          this.boy.emit("fieldsLimit");
        }
        return cb();
      }
      let idxeq;
      let idxamp;
      let i3;
      let p3 = 0;
      const len = data.length;
      while (p3 < len) {
        if (this._state === "key") {
          idxeq = idxamp = void 0;
          for (i3 = p3; i3 < len; ++i3) {
            if (!this._checkingBytes) {
              ++p3;
            }
            if (data[i3] === 61) {
              idxeq = i3;
              break;
            } else if (data[i3] === 38) {
              idxamp = i3;
              break;
            }
            if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesKey;
            }
          }
          if (idxeq !== void 0) {
            if (idxeq > p3) {
              this._key += this.decoder.write(data.toString("binary", p3, idxeq));
            }
            this._state = "val";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._val = "";
            this._bytesVal = 0;
            this._valTrunc = false;
            this.decoder.reset();
            p3 = idxeq + 1;
          } else if (idxamp !== void 0) {
            ++this._fields;
            let key;
            const keyTrunc = this._keyTrunc;
            if (idxamp > p3) {
              key = this._key += this.decoder.write(data.toString("binary", p3, idxamp));
            } else {
              key = this._key;
            }
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            if (key.length) {
              this.boy.emit(
                "field",
                decodeText(key, "binary", this.charset),
                "",
                keyTrunc,
                false
              );
            }
            p3 = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i3 > p3) {
              this._key += this.decoder.write(data.toString("binary", p3, i3));
            }
            p3 = i3;
            if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
              this._checkingBytes = false;
              this._keyTrunc = true;
            }
          } else {
            if (p3 < len) {
              this._key += this.decoder.write(data.toString("binary", p3));
            }
            p3 = len;
          }
        } else {
          idxamp = void 0;
          for (i3 = p3; i3 < len; ++i3) {
            if (!this._checkingBytes) {
              ++p3;
            }
            if (data[i3] === 38) {
              idxamp = i3;
              break;
            }
            if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesVal;
            }
          }
          if (idxamp !== void 0) {
            ++this._fields;
            if (idxamp > p3) {
              this._val += this.decoder.write(data.toString("binary", p3, idxamp));
            }
            this.boy.emit(
              "field",
              decodeText(this._key, "binary", this.charset),
              decodeText(this._val, "binary", this.charset),
              this._keyTrunc,
              this._valTrunc
            );
            this._state = "key";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            p3 = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i3 > p3) {
              this._val += this.decoder.write(data.toString("binary", p3, i3));
            }
            p3 = i3;
            if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
              this._checkingBytes = false;
              this._valTrunc = true;
            }
          } else {
            if (p3 < len) {
              this._val += this.decoder.write(data.toString("binary", p3));
            }
            p3 = len;
          }
        }
      }
      cb();
    };
    UrlEncoded.prototype.end = function() {
      if (this.boy._done) {
        return;
      }
      if (this._state === "key" && this._key.length > 0) {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          "",
          this._keyTrunc,
          false
        );
      } else if (this._state === "val") {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          decodeText(this._val, "binary", this.charset),
          this._keyTrunc,
          this._valTrunc
        );
      }
      this.boy._done = true;
      this.boy.emit("finish");
    };
    module2.exports = UrlEncoded;
  }
});

// ../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS({
  "../../node_modules/.pnpm/@fastify+busboy@2.1.1/node_modules/@fastify/busboy/lib/main.js"(exports2, module2) {
    "use strict";
    var WritableStream = require("node:stream").Writable;
    var { inherits } = require("node:util");
    var Dicer = require_Dicer();
    var MultipartParser = require_multipart();
    var UrlencodedParser = require_urlencoded();
    var parseParams = require_parseParams();
    function Busboy(opts) {
      if (!(this instanceof Busboy)) {
        return new Busboy(opts);
      }
      if (typeof opts !== "object") {
        throw new TypeError("Busboy expected an options-Object.");
      }
      if (typeof opts.headers !== "object") {
        throw new TypeError("Busboy expected an options-Object with headers-attribute.");
      }
      if (typeof opts.headers["content-type"] !== "string") {
        throw new TypeError("Missing Content-Type-header.");
      }
      const {
        headers,
        ...streamOptions
      } = opts;
      this.opts = {
        autoDestroy: false,
        ...streamOptions
      };
      WritableStream.call(this, this.opts);
      this._done = false;
      this._parser = this.getParserByHeaders(headers);
      this._finished = false;
    }
    inherits(Busboy, WritableStream);
    Busboy.prototype.emit = function(ev) {
      if (ev === "finish") {
        if (!this._done) {
          this._parser?.end();
          return;
        } else if (this._finished) {
          return;
        }
        this._finished = true;
      }
      WritableStream.prototype.emit.apply(this, arguments);
    };
    Busboy.prototype.getParserByHeaders = function(headers) {
      const parsed = parseParams(headers["content-type"]);
      const cfg = {
        defCharset: this.opts.defCharset,
        fileHwm: this.opts.fileHwm,
        headers,
        highWaterMark: this.opts.highWaterMark,
        isPartAFile: this.opts.isPartAFile,
        limits: this.opts.limits,
        parsedConType: parsed,
        preservePath: this.opts.preservePath
      };
      if (MultipartParser.detect.test(parsed[0])) {
        return new MultipartParser(this, cfg);
      }
      if (UrlencodedParser.detect.test(parsed[0])) {
        return new UrlencodedParser(this, cfg);
      }
      throw new Error("Unsupported Content-Type.");
    };
    Busboy.prototype._write = function(chunk, encoding, cb) {
      this._parser.write(chunk, cb);
    };
    module2.exports = Busboy;
    module2.exports.default = Busboy;
    module2.exports.Busboy = Busboy;
    module2.exports.Dicer = Dicer;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/constants.js"(exports2, module2) {
    "use strict";
    var { MessageChannel, receiveMessageOnPort } = require("worker_threads");
    var corsSafeListedMethods = ["GET", "HEAD", "POST"];
    var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
    var nullBodyStatus = [101, 204, 205, 304];
    var redirectStatus = [301, 302, 303, 307, 308];
    var redirectStatusSet = new Set(redirectStatus);
    var badPorts = [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6697",
      "10080"
    ];
    var badPortsSet = new Set(badPorts);
    var referrerPolicy = [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ];
    var referrerPolicySet = new Set(referrerPolicy);
    var requestRedirect = ["follow", "manual", "error"];
    var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
    var safeMethodsSet = new Set(safeMethods);
    var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
    var requestCredentials = ["omit", "same-origin", "include"];
    var requestCache = [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached"
    ];
    var requestBodyHeader = [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type",
      // See https://github.com/nodejs/undici/issues/2021
      // 'Content-Length' is a forbidden header name, which is typically
      // removed in the Headers implementation. However, undici doesn't
      // filter out headers, so we add it here.
      "content-length"
    ];
    var requestDuplex = [
      "half"
    ];
    var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
    var forbiddenMethodsSet = new Set(forbiddenMethods);
    var subresource = [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      ""
    ];
    var subresourceSet = new Set(subresource);
    var DOMException2 = globalThis.DOMException ?? (() => {
      try {
        atob("~");
      } catch (err) {
        return Object.getPrototypeOf(err).constructor;
      }
    })();
    var channel;
    var structuredClone = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
    // structuredClone was added in v17.0.0, but fetch supports v16.8
    function structuredClone2(value, options = void 0) {
      if (arguments.length === 0) {
        throw new TypeError("missing argument");
      }
      if (!channel) {
        channel = new MessageChannel();
      }
      channel.port1.unref();
      channel.port2.unref();
      channel.port1.postMessage(value, options?.transfer);
      return receiveMessageOnPort(channel.port2).message;
    };
    module2.exports = {
      DOMException: DOMException2,
      structuredClone,
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods,
      badPorts,
      requestDuplex,
      subresourceSet,
      badPortsSet,
      redirectStatusSet,
      corsSafeListedMethodsSet,
      safeMethodsSet,
      forbiddenMethodsSet,
      referrerPolicySet
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/global.js
var require_global = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/global.js"(exports2, module2) {
    "use strict";
    var globalOrigin = Symbol.for("undici.globalOrigin.1");
    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }
    function setGlobalOrigin(newOrigin) {
      if (newOrigin === void 0) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: void 0,
          writable: true,
          enumerable: false,
          configurable: false
        });
        return;
      }
      const parsedURL = new URL(newOrigin);
      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
      }
      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      getGlobalOrigin,
      setGlobalOrigin
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/util.js
var require_util2 = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/util.js"(exports2, module2) {
    "use strict";
    var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants2();
    var { getGlobalOrigin } = require_global();
    var { performance: performance2 } = require("perf_hooks");
    var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util();
    var assert = require("assert");
    var { isUint8Array } = require("util/types");
    var supportedHashes = [];
    var crypto;
    try {
      crypto = require("crypto");
      const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
      supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
    } catch {
    }
    function responseURL(response) {
      const urlList = response.urlList;
      const length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatusSet.has(response.status)) {
        return null;
      }
      let location = response.headersList.get("location");
      if (location !== null && isValidHeaderValue(location)) {
        location = new URL(location, responseURL(response));
      }
      if (location && !location.hash) {
        location.hash = requestFragment;
      }
      return location;
    }
    function requestCurrentURL(request) {
      return request.urlList[request.urlList.length - 1];
    }
    function requestBadPort(request) {
      const url = requestCurrentURL(request);
      if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
        return "blocked";
      }
      return "allowed";
    }
    function isErrorLike(object) {
      return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
    }
    function isValidReasonPhrase(statusText) {
      for (let i3 = 0; i3 < statusText.length; ++i3) {
        const c3 = statusText.charCodeAt(i3);
        if (!(c3 === 9 || // HTAB
        c3 >= 32 && c3 <= 126 || // SP / VCHAR
        c3 >= 128 && c3 <= 255)) {
          return false;
        }
      }
      return true;
    }
    function isTokenCharCode(c3) {
      switch (c3) {
        case 34:
        case 40:
        case 41:
        case 44:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 123:
        case 125:
          return false;
        default:
          return c3 >= 33 && c3 <= 126;
      }
    }
    function isValidHTTPToken(characters) {
      if (characters.length === 0) {
        return false;
      }
      for (let i3 = 0; i3 < characters.length; ++i3) {
        if (!isTokenCharCode(characters.charCodeAt(i3))) {
          return false;
        }
      }
      return true;
    }
    function isValidHeaderName(potentialValue) {
      return isValidHTTPToken(potentialValue);
    }
    function isValidHeaderValue(potentialValue) {
      if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) {
        return false;
      }
      if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
        return false;
      }
      return true;
    }
    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
      const { headersList } = actualResponse;
      const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
      let policy = "";
      if (policyHeader.length > 0) {
        for (let i3 = policyHeader.length; i3 !== 0; i3--) {
          const token = policyHeader[i3 - 1].trim();
          if (referrerPolicyTokens.has(token)) {
            policy = token;
            break;
          }
        }
      }
      if (policy !== "") {
        request.referrerPolicy = policy;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode;
      httpRequest.headersList.set("sec-fetch-mode", header);
    }
    function appendRequestOriginHeader(request) {
      let serializedOrigin = request.origin;
      if (request.responseTainting === "cors" || request.mode === "websocket") {
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      } else if (request.method !== "GET" && request.method !== "HEAD") {
        switch (request.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          case "same-origin":
            if (!sameOrigin(request, requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          default:
        }
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      }
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return performance2.now();
    }
    function createOpaqueTimingInfo(timingInfo) {
      return {
        startTime: timingInfo.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: timingInfo.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null
      };
    }
    function makePolicyContainer() {
      return {
        referrerPolicy: "strict-origin-when-cross-origin"
      };
    }
    function clonePolicyContainer(policyContainer) {
      return {
        referrerPolicy: policyContainer.referrerPolicy
      };
    }
    function determineRequestsReferrer(request) {
      const policy = request.referrerPolicy;
      assert(policy);
      let referrerSource = null;
      if (request.referrer === "client") {
        const globalOrigin = getGlobalOrigin();
        if (!globalOrigin || globalOrigin.origin === "null") {
          return "no-referrer";
        }
        referrerSource = new URL(globalOrigin);
      } else if (request.referrer instanceof URL) {
        referrerSource = request.referrer;
      }
      let referrerURL = stripURLForReferrer(referrerSource);
      const referrerOrigin = stripURLForReferrer(referrerSource, true);
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }
      const areSameOrigin = sameOrigin(request, referrerURL);
      const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
      switch (policy) {
        case "origin":
          return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
        case "unsafe-url":
          return referrerURL;
        case "same-origin":
          return areSameOrigin ? referrerOrigin : "no-referrer";
        case "origin-when-cross-origin":
          return areSameOrigin ? referrerURL : referrerOrigin;
        case "strict-origin-when-cross-origin": {
          const currentURL = requestCurrentURL(request);
          if (sameOrigin(referrerURL, currentURL)) {
            return referrerURL;
          }
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
        case "strict-origin":
        // eslint-disable-line
        /**
           * 1. If referrerURL is a potentially trustworthy URL and
           * requests current URL is not a potentially trustworthy URL,
           * then return no referrer.
           * 2. Return referrerOrigin
          */
        case "no-referrer-when-downgrade":
        // eslint-disable-line
        /**
         * 1. If referrerURL is a potentially trustworthy URL and
         * requests current URL is not a potentially trustworthy URL,
         * then return no referrer.
         * 2. Return referrerOrigin
        */
        default:
          return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
      }
    }
    function stripURLForReferrer(url, originOnly) {
      assert(url instanceof URL);
      if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
        return "no-referrer";
      }
      url.username = "";
      url.password = "";
      url.hash = "";
      if (originOnly) {
        url.pathname = "";
        url.search = "";
      }
      return url;
    }
    function isURLPotentiallyTrustworthy(url) {
      if (!(url instanceof URL)) {
        return false;
      }
      if (url.href === "about:blank" || url.href === "about:srcdoc") {
        return true;
      }
      if (url.protocol === "data:") return true;
      if (url.protocol === "file:") return true;
      return isOriginPotentiallyTrustworthy(url.origin);
      function isOriginPotentiallyTrustworthy(origin) {
        if (origin == null || origin === "null") return false;
        const originAsURL = new URL(origin);
        if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
          return true;
        }
        if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
          return true;
        }
        return false;
      }
    }
    function bytesMatch(bytes, metadataList) {
      if (crypto === void 0) {
        return true;
      }
      const parsedMetadata = parseMetadata(metadataList);
      if (parsedMetadata === "no metadata") {
        return true;
      }
      if (parsedMetadata.length === 0) {
        return true;
      }
      const strongest = getStrongestMetadata(parsedMetadata);
      const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
      for (const item of metadata) {
        const algorithm = item.algo;
        const expectedValue = item.hash;
        let actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
        if (actualValue[actualValue.length - 1] === "=") {
          if (actualValue[actualValue.length - 2] === "=") {
            actualValue = actualValue.slice(0, -2);
          } else {
            actualValue = actualValue.slice(0, -1);
          }
        }
        if (compareBase64Mixed(actualValue, expectedValue)) {
          return true;
        }
      }
      return false;
    }
    var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
    function parseMetadata(metadata) {
      const result = [];
      let empty = true;
      for (const token of metadata.split(" ")) {
        empty = false;
        const parsedToken = parseHashWithOptions.exec(token);
        if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) {
          continue;
        }
        const algorithm = parsedToken.groups.algo.toLowerCase();
        if (supportedHashes.includes(algorithm)) {
          result.push(parsedToken.groups);
        }
      }
      if (empty === true) {
        return "no metadata";
      }
      return result;
    }
    function getStrongestMetadata(metadataList) {
      let algorithm = metadataList[0].algo;
      if (algorithm[3] === "5") {
        return algorithm;
      }
      for (let i3 = 1; i3 < metadataList.length; ++i3) {
        const metadata = metadataList[i3];
        if (metadata.algo[3] === "5") {
          algorithm = "sha512";
          break;
        } else if (algorithm[3] === "3") {
          continue;
        } else if (metadata.algo[3] === "3") {
          algorithm = "sha384";
        }
      }
      return algorithm;
    }
    function filterMetadataListByAlgorithm(metadataList, algorithm) {
      if (metadataList.length === 1) {
        return metadataList;
      }
      let pos = 0;
      for (let i3 = 0; i3 < metadataList.length; ++i3) {
        if (metadataList[i3].algo === algorithm) {
          metadataList[pos++] = metadataList[i3];
        }
      }
      metadataList.length = pos;
      return metadataList;
    }
    function compareBase64Mixed(actualValue, expectedValue) {
      if (actualValue.length !== expectedValue.length) {
        return false;
      }
      for (let i3 = 0; i3 < actualValue.length; ++i3) {
        if (actualValue[i3] !== expectedValue[i3]) {
          if (actualValue[i3] === "+" && expectedValue[i3] === "-" || actualValue[i3] === "/" && expectedValue[i3] === "_") {
            continue;
          }
          return false;
        }
      }
      return true;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
    }
    function sameOrigin(A, B) {
      if (A.origin === B.origin && A.origin === "null") {
        return true;
      }
      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
        return true;
      }
      return false;
    }
    function createDeferredPromise() {
      let res;
      let rej;
      const promise = new Promise((resolve2, reject) => {
        res = resolve2;
        rej = reject;
      });
      return { promise, resolve: res, reject: rej };
    }
    function isAborted(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
    }
    var normalizeMethodRecord = {
      delete: "DELETE",
      DELETE: "DELETE",
      get: "GET",
      GET: "GET",
      head: "HEAD",
      HEAD: "HEAD",
      options: "OPTIONS",
      OPTIONS: "OPTIONS",
      post: "POST",
      POST: "POST",
      put: "PUT",
      PUT: "PUT"
    };
    Object.setPrototypeOf(normalizeMethodRecord, null);
    function normalizeMethod(method) {
      return normalizeMethodRecord[method.toLowerCase()] ?? method;
    }
    function serializeJavascriptValueToJSONString(value) {
      const result = JSON.stringify(value);
      if (result === void 0) {
        throw new TypeError("Value is not JSON serializable");
      }
      assert(typeof result === "string");
      return result;
    }
    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function makeIterator(iterator, name, kind) {
      const object = {
        index: 0,
        kind,
        target: iterator
      };
      const i3 = {
        next() {
          if (Object.getPrototypeOf(this) !== i3) {
            throw new TypeError(
              `'next' called on an object that does not implement interface ${name} Iterator.`
            );
          }
          const { index, kind: kind2, target } = object;
          const values = target();
          const len = values.length;
          if (index >= len) {
            return { value: void 0, done: true };
          }
          const pair = values[index];
          object.index = index + 1;
          return iteratorResult(pair, kind2);
        },
        // The class string of an iterator prototype object for a given interface is the
        // result of concatenating the identifier of the interface and the string " Iterator".
        [Symbol.toStringTag]: `${name} Iterator`
      };
      Object.setPrototypeOf(i3, esIteratorPrototype);
      return Object.setPrototypeOf({}, i3);
    }
    function iteratorResult(pair, kind) {
      let result;
      switch (kind) {
        case "key": {
          result = pair[0];
          break;
        }
        case "value": {
          result = pair[1];
          break;
        }
        case "key+value": {
          result = pair;
          break;
        }
      }
      return { value: result, done: false };
    }
    async function fullyReadBody(body, processBody, processBodyError) {
      const successSteps = processBody;
      const errorSteps = processBodyError;
      let reader;
      try {
        reader = body.stream.getReader();
      } catch (e2) {
        errorSteps(e2);
        return;
      }
      try {
        const result = await readAllBytes(reader);
        successSteps(result);
      } catch (e2) {
        errorSteps(e2);
      }
    }
    var ReadableStream = globalThis.ReadableStream;
    function isReadableStreamLike(stream) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      return stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
    }
    var MAXIMUM_ARGUMENT_LENGTH = 65535;
    function isomorphicDecode(input) {
      if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
        return String.fromCharCode(...input);
      }
      return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
    }
    function readableStreamClose(controller) {
      try {
        controller.close();
      } catch (err) {
        if (!err.message.includes("Controller is already closed")) {
          throw err;
        }
      }
    }
    function isomorphicEncode(input) {
      for (let i3 = 0; i3 < input.length; i3++) {
        assert(input.charCodeAt(i3) <= 255);
      }
      return input;
    }
    async function readAllBytes(reader) {
      const bytes = [];
      let byteLength = 0;
      while (true) {
        const { done, value: chunk } = await reader.read();
        if (done) {
          return Buffer.concat(bytes, byteLength);
        }
        if (!isUint8Array(chunk)) {
          throw new TypeError("Received non-Uint8Array chunk");
        }
        bytes.push(chunk);
        byteLength += chunk.length;
      }
    }
    function urlIsLocal(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "about:" || protocol === "blob:" || protocol === "data:";
    }
    function urlHasHttpsScheme(url) {
      if (typeof url === "string") {
        return url.startsWith("https:");
      }
      return url.protocol === "https:";
    }
    function urlIsHttpHttpsScheme(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "http:" || protocol === "https:";
    }
    var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
    module2.exports = {
      isAborted,
      isCancelled,
      createDeferredPromise,
      ReadableStreamFrom,
      toUSVString,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isBlobLike,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue,
      hasOwn,
      isErrorLike,
      fullyReadBody,
      bytesMatch,
      isReadableStreamLike,
      readableStreamClose,
      isomorphicEncode,
      isomorphicDecode,
      urlIsLocal,
      urlHasHttpsScheme,
      urlIsHttpHttpsScheme,
      readAllBytes,
      normalizeMethodRecord,
      parseMetadata
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kUrl: Symbol("url"),
      kHeaders: Symbol("headers"),
      kSignal: Symbol("signal"),
      kState: Symbol("state"),
      kGuard: Symbol("guard"),
      kRealm: Symbol("realm")
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/webidl.js"(exports2, module2) {
    "use strict";
    var { types } = require("util");
    var { hasOwn, toUSVString } = require_util2();
    var webidl = {};
    webidl.converters = {};
    webidl.util = {};
    webidl.errors = {};
    webidl.errors.exception = function(message) {
      return new TypeError(`${message.header}: ${message.message}`);
    };
    webidl.errors.conversionFailed = function(context) {
      const plural = context.types.length === 1 ? "" : " one of";
      const message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
      return webidl.errors.exception({
        header: context.prefix,
        message
      });
    };
    webidl.errors.invalidArgument = function(context) {
      return webidl.errors.exception({
        header: context.prefix,
        message: `"${context.value}" is an invalid ${context.type}.`
      });
    };
    webidl.brandCheck = function(V, I3, opts = void 0) {
      if (opts?.strict !== false && !(V instanceof I3)) {
        throw new TypeError("Illegal invocation");
      } else {
        return V?.[Symbol.toStringTag] === I3.prototype[Symbol.toStringTag];
      }
    };
    webidl.argumentLengthCheck = function({ length }, min, ctx) {
      if (length < min) {
        throw webidl.errors.exception({
          message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
          ...ctx
        });
      }
    };
    webidl.illegalConstructor = function() {
      throw webidl.errors.exception({
        header: "TypeError",
        message: "Illegal constructor"
      });
    };
    webidl.util.Type = function(V) {
      switch (typeof V) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "number":
          return "Number";
        case "bigint":
          return "BigInt";
        case "function":
        case "object": {
          if (V === null) {
            return "Null";
          }
          return "Object";
        }
      }
    };
    webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
      let upperBound;
      let lowerBound;
      if (bitLength === 64) {
        upperBound = Math.pow(2, 53) - 1;
        if (signedness === "unsigned") {
          lowerBound = 0;
        } else {
          lowerBound = Math.pow(-2, 53) + 1;
        }
      } else if (signedness === "unsigned") {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
      } else {
        lowerBound = Math.pow(-2, bitLength) - 1;
        upperBound = Math.pow(2, bitLength - 1) - 1;
      }
      let x3 = Number(V);
      if (x3 === 0) {
        x3 = 0;
      }
      if (opts.enforceRange === true) {
        if (Number.isNaN(x3) || x3 === Number.POSITIVE_INFINITY || x3 === Number.NEGATIVE_INFINITY) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Could not convert ${V} to an integer.`
          });
        }
        x3 = webidl.util.IntegerPart(x3);
        if (x3 < lowerBound || x3 > upperBound) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Value must be between ${lowerBound}-${upperBound}, got ${x3}.`
          });
        }
        return x3;
      }
      if (!Number.isNaN(x3) && opts.clamp === true) {
        x3 = Math.min(Math.max(x3, lowerBound), upperBound);
        if (Math.floor(x3) % 2 === 0) {
          x3 = Math.floor(x3);
        } else {
          x3 = Math.ceil(x3);
        }
        return x3;
      }
      if (Number.isNaN(x3) || x3 === 0 && Object.is(0, x3) || x3 === Number.POSITIVE_INFINITY || x3 === Number.NEGATIVE_INFINITY) {
        return 0;
      }
      x3 = webidl.util.IntegerPart(x3);
      x3 = x3 % Math.pow(2, bitLength);
      if (signedness === "signed" && x3 >= Math.pow(2, bitLength) - 1) {
        return x3 - Math.pow(2, bitLength);
      }
      return x3;
    };
    webidl.util.IntegerPart = function(n3) {
      const r3 = Math.floor(Math.abs(n3));
      if (n3 < 0) {
        return -1 * r3;
      }
      return r3;
    };
    webidl.sequenceConverter = function(converter) {
      return (V) => {
        if (webidl.util.Type(V) !== "Object") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: `Value of type ${webidl.util.Type(V)} is not an Object.`
          });
        }
        const method = V?.[Symbol.iterator]?.();
        const seq = [];
        if (method === void 0 || typeof method.next !== "function") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: "Object is not an iterator."
          });
        }
        while (true) {
          const { done, value } = method.next();
          if (done) {
            break;
          }
          seq.push(converter(value));
        }
        return seq;
      };
    };
    webidl.recordConverter = function(keyConverter, valueConverter) {
      return (O2) => {
        if (webidl.util.Type(O2) !== "Object") {
          throw webidl.errors.exception({
            header: "Record",
            message: `Value of type ${webidl.util.Type(O2)} is not an Object.`
          });
        }
        const result = {};
        if (!types.isProxy(O2)) {
          const keys2 = Object.keys(O2);
          for (const key of keys2) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O2[key]);
            result[typedKey] = typedValue;
          }
          return result;
        }
        const keys = Reflect.ownKeys(O2);
        for (const key of keys) {
          const desc = Reflect.getOwnPropertyDescriptor(O2, key);
          if (desc?.enumerable) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O2[key]);
            result[typedKey] = typedValue;
          }
        }
        return result;
      };
    };
    webidl.interfaceConverter = function(i3) {
      return (V, opts = {}) => {
        if (opts.strict !== false && !(V instanceof i3)) {
          throw webidl.errors.exception({
            header: i3.name,
            message: `Expected ${V} to be an instance of ${i3.name}.`
          });
        }
        return V;
      };
    };
    webidl.dictionaryConverter = function(converters) {
      return (dictionary) => {
        const type = webidl.util.Type(dictionary);
        const dict = {};
        if (type === "Null" || type === "Undefined") {
          return dict;
        } else if (type !== "Object") {
          throw webidl.errors.exception({
            header: "Dictionary",
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
          });
        }
        for (const options of converters) {
          const { key, defaultValue, required, converter } = options;
          if (required === true) {
            if (!hasOwn(dictionary, key)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `Missing required key "${key}".`
              });
            }
          }
          let value = dictionary[key];
          const hasDefault = hasOwn(options, "defaultValue");
          if (hasDefault && value !== null) {
            value = value ?? defaultValue;
          }
          if (required || hasDefault || value !== void 0) {
            value = converter(value);
            if (options.allowedValues && !options.allowedValues.includes(value)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
              });
            }
            dict[key] = value;
          }
        }
        return dict;
      };
    };
    webidl.nullableConverter = function(converter) {
      return (V) => {
        if (V === null) {
          return V;
        }
        return converter(V);
      };
    };
    webidl.converters.DOMString = function(V, opts = {}) {
      if (V === null && opts.legacyNullToEmptyString) {
        return "";
      }
      if (typeof V === "symbol") {
        throw new TypeError("Could not convert argument of type symbol to string.");
      }
      return String(V);
    };
    webidl.converters.ByteString = function(V) {
      const x3 = webidl.converters.DOMString(V);
      for (let index = 0; index < x3.length; index++) {
        if (x3.charCodeAt(index) > 255) {
          throw new TypeError(
            `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x3.charCodeAt(index)} which is greater than 255.`
          );
        }
      }
      return x3;
    };
    webidl.converters.USVString = toUSVString;
    webidl.converters.boolean = function(V) {
      const x3 = Boolean(V);
      return x3;
    };
    webidl.converters.any = function(V) {
      return V;
    };
    webidl.converters["long long"] = function(V) {
      const x3 = webidl.util.ConvertToInt(V, 64, "signed");
      return x3;
    };
    webidl.converters["unsigned long long"] = function(V) {
      const x3 = webidl.util.ConvertToInt(V, 64, "unsigned");
      return x3;
    };
    webidl.converters["unsigned long"] = function(V) {
      const x3 = webidl.util.ConvertToInt(V, 32, "unsigned");
      return x3;
    };
    webidl.converters["unsigned short"] = function(V, opts) {
      const x3 = webidl.util.ConvertToInt(V, 16, "unsigned", opts);
      return x3;
    };
    webidl.converters.ArrayBuffer = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
        throw webidl.errors.conversionFailed({
          prefix: `${V}`,
          argument: `${V}`,
          types: ["ArrayBuffer"]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.TypedArray = function(V, T3, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T3.name) {
        throw webidl.errors.conversionFailed({
          prefix: `${T3.name}`,
          argument: `${V}`,
          types: [T3.name]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.DataView = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
        throw webidl.errors.exception({
          header: "DataView",
          message: "Object is not a DataView."
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.BufferSource = function(V, opts = {}) {
      if (types.isAnyArrayBuffer(V)) {
        return webidl.converters.ArrayBuffer(V, opts);
      }
      if (types.isTypedArray(V)) {
        return webidl.converters.TypedArray(V, V.constructor);
      }
      if (types.isDataView(V)) {
        return webidl.converters.DataView(V, opts);
      }
      throw new TypeError(`Could not convert ${V} to a BufferSource.`);
    };
    webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
      webidl.converters.ByteString
    );
    webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
      webidl.converters["sequence<ByteString>"]
    );
    webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
      webidl.converters.ByteString,
      webidl.converters.ByteString
    );
    module2.exports = {
      webidl
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/dataURL.js"(exports2, module2) {
    var assert = require("assert");
    var { atob: atob2 } = require("buffer");
    var { isomorphicDecode } = require_util2();
    var encoder = new TextEncoder();
    var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
    var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
    var HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
    function dataURLProcessor(dataURL) {
      assert(dataURL.protocol === "data:");
      let input = URLSerializer(dataURL, true);
      input = input.slice(5);
      const position = { position: 0 };
      let mimeType = collectASequenceOfCodePointsFast(
        ",",
        input,
        position
      );
      const mimeTypeLength = mimeType.length;
      mimeType = removeASCIIWhitespace(mimeType, true, true);
      if (position.position >= input.length) {
        return "failure";
      }
      position.position++;
      const encodedBody = input.slice(mimeTypeLength + 1);
      let body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        const stringBody = isomorphicDecode(body);
        body = forgivingBase64(stringBody);
        if (body === "failure") {
          return "failure";
        }
        mimeType = mimeType.slice(0, -6);
        mimeType = mimeType.replace(/(\u0020)+$/, "");
        mimeType = mimeType.slice(0, -1);
      }
      if (mimeType.startsWith(";")) {
        mimeType = "text/plain" + mimeType;
      }
      let mimeTypeRecord = parseMIMEType(mimeType);
      if (mimeTypeRecord === "failure") {
        mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
      }
      return { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url, excludeFragment = false) {
      if (!excludeFragment) {
        return url.href;
      }
      const href = url.href;
      const hashLength = url.hash.length;
      return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
    }
    function collectASequenceOfCodePoints(condition, input, position) {
      let result = "";
      while (position.position < input.length && condition(input[position.position])) {
        result += input[position.position];
        position.position++;
      }
      return result;
    }
    function collectASequenceOfCodePointsFast(char, input, position) {
      const idx = input.indexOf(char, position.position);
      const start = position.position;
      if (idx === -1) {
        position.position = input.length;
        return input.slice(start);
      }
      position.position = idx;
      return input.slice(start, position.position);
    }
    function stringPercentDecode(input) {
      const bytes = encoder.encode(input);
      return percentDecode(bytes);
    }
    function percentDecode(input) {
      const output = [];
      for (let i3 = 0; i3 < input.length; i3++) {
        const byte = input[i3];
        if (byte !== 37) {
          output.push(byte);
        } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i3 + 1], input[i3 + 2]))) {
          output.push(37);
        } else {
          const nextTwoBytes = String.fromCharCode(input[i3 + 1], input[i3 + 2]);
          const bytePoint = Number.parseInt(nextTwoBytes, 16);
          output.push(bytePoint);
          i3 += 2;
        }
      }
      return Uint8Array.from(output);
    }
    function parseMIMEType(input) {
      input = removeHTTPWhitespace(input, true, true);
      const position = { position: 0 };
      const type = collectASequenceOfCodePointsFast(
        "/",
        input,
        position
      );
      if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
        return "failure";
      }
      if (position.position > input.length) {
        return "failure";
      }
      position.position++;
      let subtype = collectASequenceOfCodePointsFast(
        ";",
        input,
        position
      );
      subtype = removeHTTPWhitespace(subtype, false, true);
      if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
        return "failure";
      }
      const typeLowercase = type.toLowerCase();
      const subtypeLowercase = subtype.toLowerCase();
      const mimeType = {
        type: typeLowercase,
        subtype: subtypeLowercase,
        /** @type {Map<string, string>} */
        parameters: /* @__PURE__ */ new Map(),
        // https://mimesniff.spec.whatwg.org/#mime-type-essence
        essence: `${typeLowercase}/${subtypeLowercase}`
      };
      while (position.position < input.length) {
        position.position++;
        collectASequenceOfCodePoints(
          // https://fetch.spec.whatwg.org/#http-whitespace
          (char) => HTTP_WHITESPACE_REGEX.test(char),
          input,
          position
        );
        let parameterName = collectASequenceOfCodePoints(
          (char) => char !== ";" && char !== "=",
          input,
          position
        );
        parameterName = parameterName.toLowerCase();
        if (position.position < input.length) {
          if (input[position.position] === ";") {
            continue;
          }
          position.position++;
        }
        if (position.position > input.length) {
          break;
        }
        let parameterValue = null;
        if (input[position.position] === '"') {
          parameterValue = collectAnHTTPQuotedString(input, position, true);
          collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
        } else {
          parameterValue = collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
          parameterValue = removeHTTPWhitespace(parameterValue, false, true);
          if (parameterValue.length === 0) {
            continue;
          }
        }
        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
      if (data.length % 4 === 0) {
        data = data.replace(/=?=$/, "");
      }
      if (data.length % 4 === 1) {
        return "failure";
      }
      if (/[^+/0-9A-Za-z]/.test(data)) {
        return "failure";
      }
      const binary = atob2(data);
      const bytes = new Uint8Array(binary.length);
      for (let byte = 0; byte < binary.length; byte++) {
        bytes[byte] = binary.charCodeAt(byte);
      }
      return bytes;
    }
    function collectAnHTTPQuotedString(input, position, extractValue) {
      const positionStart = position.position;
      let value = "";
      assert(input[position.position] === '"');
      position.position++;
      while (true) {
        value += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== "\\",
          input,
          position
        );
        if (position.position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position.position];
        position.position++;
        if (quoteOrBackslash === "\\") {
          if (position.position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position.position];
          position.position++;
        } else {
          assert(quoteOrBackslash === '"');
          break;
        }
      }
      if (extractValue) {
        return value;
      }
      return input.slice(positionStart, position.position);
    }
    function serializeAMimeType(mimeType) {
      assert(mimeType !== "failure");
      const { parameters, essence } = mimeType;
      let serialization = essence;
      for (let [name, value] of parameters.entries()) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
          value = value.replace(/(\\|")/g, "\\$1");
          value = '"' + value;
          value += '"';
        }
        serialization += value;
      }
      return serialization;
    }
    function isHTTPWhiteSpace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === " ";
    }
    function removeHTTPWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++) ;
      }
      if (trailing) {
        for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--) ;
      }
      return str.slice(lead, trail + 1);
    }
    function isASCIIWhitespace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === "\f" || char === " ";
    }
    function removeASCIIWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++) ;
      }
      if (trailing) {
        for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--) ;
      }
      return str.slice(lead, trail + 1);
    }
    module2.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/file.js
var require_file = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/file.js"(exports2, module2) {
    "use strict";
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var { types } = require("util");
    var { kState } = require_symbols2();
    var { isBlobLike } = require_util2();
    var { webidl } = require_webidl();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var { kEnumerableProperty } = require_util();
    var encoder = new TextEncoder();
    var File2 = class _File extends Blob2 {
      constructor(fileBits, fileName, options = {}) {
        webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
        fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
        fileName = webidl.converters.USVString(fileName);
        options = webidl.converters.FilePropertyBag(options);
        const n3 = fileName;
        let t = options.type;
        let d;
        substep: {
          if (t) {
            t = parseMIMEType(t);
            if (t === "failure") {
              t = "";
              break substep;
            }
            t = serializeAMimeType(t).toLowerCase();
          }
          d = options.lastModified;
        }
        super(processBlobParts(fileBits, options), { type: t });
        this[kState] = {
          name: n3,
          lastModified: d,
          type: t
        };
      }
      get name() {
        webidl.brandCheck(this, _File);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _File);
        return this[kState].lastModified;
      }
      get type() {
        webidl.brandCheck(this, _File);
        return this[kState].type;
      }
    };
    var FileLike = class _FileLike {
      constructor(blobLike, fileName, options = {}) {
        const n3 = fileName;
        const t = options.type;
        const d = options.lastModified ?? Date.now();
        this[kState] = {
          blobLike,
          name: n3,
          type: t,
          lastModified: d
        };
      }
      stream(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.stream(...args);
      }
      arrayBuffer(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.arrayBuffer(...args);
      }
      slice(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.slice(...args);
      }
      text(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.text(...args);
      }
      get size() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.size;
      }
      get type() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.type;
      }
      get name() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    Object.defineProperties(File2.prototype, {
      [Symbol.toStringTag]: {
        value: "File",
        configurable: true
      },
      name: kEnumerableProperty,
      lastModified: kEnumerableProperty
    });
    webidl.converters.Blob = webidl.interfaceConverter(Blob2);
    webidl.converters.BlobPart = function(V, opts) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V, opts);
        }
      }
      return webidl.converters.USVString(V, opts);
    };
    webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(
      webidl.converters.BlobPart
    );
    webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
      {
        key: "lastModified",
        converter: webidl.converters["long long"],
        get defaultValue() {
          return Date.now();
        }
      },
      {
        key: "type",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "endings",
        converter: (value) => {
          value = webidl.converters.DOMString(value);
          value = value.toLowerCase();
          if (value !== "native") {
            value = "transparent";
          }
          return value;
        },
        defaultValue: "transparent"
      }
    ]);
    function processBlobParts(parts, options) {
      const bytes = [];
      for (const element of parts) {
        if (typeof element === "string") {
          let s = element;
          if (options.endings === "native") {
            s = convertLineEndingsNative(s);
          }
          bytes.push(encoder.encode(s));
        } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {
          if (!element.buffer) {
            bytes.push(new Uint8Array(element));
          } else {
            bytes.push(
              new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
            );
          }
        } else if (isBlobLike(element)) {
          bytes.push(element);
        }
      }
      return bytes;
    }
    function convertLineEndingsNative(s) {
      let nativeLineEnding = "\n";
      if (process.platform === "win32") {
        nativeLineEnding = "\r\n";
      }
      return s.replace(/\r?\n/g, nativeLineEnding);
    }
    function isFileLike(object) {
      return NativeFile && object instanceof NativeFile || object instanceof File2 || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
    }
    module2.exports = { File: File2, FileLike, isFileLike };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/formdata.js"(exports2, module2) {
    "use strict";
    var { isBlobLike, toUSVString, makeIterator } = require_util2();
    var { kState } = require_symbols2();
    var { File: UndiciFile, FileLike, isFileLike } = require_file();
    var { webidl } = require_webidl();
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var File2 = NativeFile ?? UndiciFile;
    var FormData = class _FormData {
      constructor(form) {
        if (form !== void 0) {
          throw webidl.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["undefined"]
          });
        }
        this[kState] = [];
      }
      append(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        this[kState].push(entry);
      }
      delete(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
        name = webidl.converters.USVString(name);
        this[kState] = this[kState].filter((entry) => entry.name !== name);
      }
      get(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
        name = webidl.converters.USVString(name);
        const idx = this[kState].findIndex((entry) => entry.name === name);
        if (idx === -1) {
          return null;
        }
        return this[kState][idx].value;
      }
      getAll(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
        name = webidl.converters.USVString(name);
        return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
      }
      has(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
        name = webidl.converters.USVString(name);
        return this[kState].findIndex((entry) => entry.name === name) !== -1;
      }
      set(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? toUSVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        const idx = this[kState].findIndex((entry2) => entry2.name === name);
        if (idx !== -1) {
          this[kState] = [
            ...this[kState].slice(0, idx),
            entry,
            ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
          ];
        } else {
          this[kState].push(entry);
        }
      }
      entries() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key+value"
        );
      }
      keys() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "value"
        );
      }
      /**
       * @param {(value: string, key: string, self: FormData) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
    };
    FormData.prototype[Symbol.iterator] = FormData.prototype.entries;
    Object.defineProperties(FormData.prototype, {
      [Symbol.toStringTag]: {
        value: "FormData",
        configurable: true
      }
    });
    function makeEntry(name, value, filename) {
      name = Buffer.from(name).toString("utf8");
      if (typeof value === "string") {
        value = Buffer.from(value).toString("utf8");
      } else {
        if (!isFileLike(value)) {
          value = value instanceof Blob2 ? new File2([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
        }
        if (filename !== void 0) {
          const options = {
            type: value.type,
            lastModified: value.lastModified
          };
          value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File2([value], filename, options) : new FileLike(value, filename, options);
        }
      }
      return { name, value };
    }
    module2.exports = { FormData };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/body.js
var require_body = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/body.js"(exports2, module2) {
    "use strict";
    var Busboy = require_main();
    var util = require_util();
    var {
      ReadableStreamFrom,
      isBlobLike,
      isReadableStreamLike,
      readableStreamClose,
      createDeferredPromise,
      fullyReadBody
    } = require_util2();
    var { FormData } = require_formdata();
    var { kState } = require_symbols2();
    var { webidl } = require_webidl();
    var { DOMException: DOMException2, structuredClone } = require_constants2();
    var { Blob: Blob2, File: NativeFile } = require("buffer");
    var { kBodyUsed } = require_symbols();
    var assert = require("assert");
    var { isErrored } = require_util();
    var { isUint8Array, isArrayBuffer } = require("util/types");
    var { File: UndiciFile } = require_file();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var random;
    try {
      const crypto = require("node:crypto");
      random = (max) => crypto.randomInt(0, max);
    } catch {
      random = (max) => Math.floor(Math.random(max));
    }
    var ReadableStream = globalThis.ReadableStream;
    var File2 = NativeFile ?? UndiciFile;
    var textEncoder = new TextEncoder();
    var textDecoder = new TextDecoder();
    function extractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      let stream = null;
      if (object instanceof ReadableStream) {
        stream = object;
      } else if (isBlobLike(object)) {
        stream = object.stream();
      } else {
        stream = new ReadableStream({
          async pull(controller) {
            controller.enqueue(
              typeof source === "string" ? textEncoder.encode(source) : source
            );
            queueMicrotask(() => readableStreamClose(controller));
          },
          start() {
          },
          type: void 0
        });
      }
      assert(isReadableStreamLike(stream));
      let action = null;
      let source = null;
      let length = null;
      let type = null;
      if (typeof object === "string") {
        source = object;
        type = "text/plain;charset=UTF-8";
      } else if (object instanceof URLSearchParams) {
        source = object.toString();
        type = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isArrayBuffer(object)) {
        source = new Uint8Array(object.slice());
      } else if (ArrayBuffer.isView(object)) {
        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
      } else if (util.isFormDataLike(object)) {
        const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, "0")}`;
        const prefix = `--${boundary}\r
Content-Disposition: form-data`;
        const escape2 = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
        const blobParts = [];
        const rn = new Uint8Array([13, 10]);
        length = 0;
        let hasUnknownSizeValue = false;
        for (const [name, value] of object) {
          if (typeof value === "string") {
            const chunk2 = textEncoder.encode(prefix + `; name="${escape2(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
            blobParts.push(chunk2);
            length += chunk2.byteLength;
          } else {
            const chunk2 = textEncoder.encode(`${prefix}; name="${escape2(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape2(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
            blobParts.push(chunk2, value, rn);
            if (typeof value.size === "number") {
              length += chunk2.byteLength + value.size + rn.byteLength;
            } else {
              hasUnknownSizeValue = true;
            }
          }
        }
        const chunk = textEncoder.encode(`--${boundary}--`);
        blobParts.push(chunk);
        length += chunk.byteLength;
        if (hasUnknownSizeValue) {
          length = null;
        }
        source = object;
        action = async function* () {
          for (const part of blobParts) {
            if (part.stream) {
              yield* part.stream();
            } else {
              yield part;
            }
          }
        };
        type = "multipart/form-data; boundary=" + boundary;
      } else if (isBlobLike(object)) {
        source = object;
        length = object.size;
        if (object.type) {
          type = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === "function") {
        if (keepalive) {
          throw new TypeError("keepalive");
        }
        if (util.isDisturbed(object) || object.locked) {
          throw new TypeError(
            "Response body object should not be disturbed or locked"
          );
        }
        stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
      }
      if (typeof source === "string" || util.isBuffer(source)) {
        length = Buffer.byteLength(source);
      }
      if (action != null) {
        let iterator;
        stream = new ReadableStream({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              if (!isErrored(stream)) {
                controller.enqueue(new Uint8Array(value));
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: void 0
        });
      }
      const body = { stream, source, length };
      return [body, type];
    }
    function safelyExtractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      if (object instanceof ReadableStream) {
        assert(!util.isDisturbed(object), "The body has already been consumed.");
        assert(!object.locked, "The stream is locked.");
      }
      return extractBody(object, keepalive);
    }
    function cloneBody(body) {
      const [out1, out2] = body.stream.tee();
      const out2Clone = structuredClone(out2, { transfer: [out2] });
      const [, finalClone] = out2Clone.tee();
      body.stream = out1;
      return {
        stream: finalClone,
        length: body.length,
        source: body.source
      };
    }
    async function* consumeBody(body) {
      if (body) {
        if (isUint8Array(body)) {
          yield body;
        } else {
          const stream = body.stream;
          if (util.isDisturbed(stream)) {
            throw new TypeError("The body has already been consumed.");
          }
          if (stream.locked) {
            throw new TypeError("The stream is locked.");
          }
          stream[kBodyUsed] = true;
          yield* stream;
        }
      }
    }
    function throwIfAborted(state) {
      if (state.aborted) {
        throw new DOMException2("The operation was aborted.", "AbortError");
      }
    }
    function bodyMixinMethods(instance) {
      const methods = {
        blob() {
          return specConsumeBody(this, (bytes) => {
            let mimeType = bodyMimeType(this);
            if (mimeType === "failure") {
              mimeType = "";
            } else if (mimeType) {
              mimeType = serializeAMimeType(mimeType);
            }
            return new Blob2([bytes], { type: mimeType });
          }, instance);
        },
        arrayBuffer() {
          return specConsumeBody(this, (bytes) => {
            return new Uint8Array(bytes).buffer;
          }, instance);
        },
        text() {
          return specConsumeBody(this, utf8DecodeBytes, instance);
        },
        json() {
          return specConsumeBody(this, parseJSONFromBytes, instance);
        },
        async formData() {
          webidl.brandCheck(this, instance);
          throwIfAborted(this[kState]);
          const contentType = this.headers.get("Content-Type");
          if (/multipart\/form-data/.test(contentType)) {
            const headers = {};
            for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;
            const responseFormData = new FormData();
            let busboy;
            try {
              busboy = new Busboy({
                headers,
                preservePath: true
              });
            } catch (err) {
              throw new DOMException2(`${err}`, "AbortError");
            }
            busboy.on("field", (name, value) => {
              responseFormData.append(name, value);
            });
            busboy.on("file", (name, value, filename, encoding, mimeType) => {
              const chunks = [];
              if (encoding === "base64" || encoding.toLowerCase() === "base64") {
                let base64chunk = "";
                value.on("data", (chunk) => {
                  base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                  const end = base64chunk.length - base64chunk.length % 4;
                  chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                  base64chunk = base64chunk.slice(end);
                });
                value.on("end", () => {
                  chunks.push(Buffer.from(base64chunk, "base64"));
                  responseFormData.append(name, new File2(chunks, filename, { type: mimeType }));
                });
              } else {
                value.on("data", (chunk) => {
                  chunks.push(chunk);
                });
                value.on("end", () => {
                  responseFormData.append(name, new File2(chunks, filename, { type: mimeType }));
                });
              }
            });
            const busboyResolve = new Promise((resolve2, reject) => {
              busboy.on("finish", resolve2);
              busboy.on("error", (err) => reject(new TypeError(err)));
            });
            if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk);
            busboy.end();
            await busboyResolve;
            return responseFormData;
          } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
            let entries;
            try {
              let text = "";
              const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                text += streamingDecoder.decode(chunk, { stream: true });
              }
              text += streamingDecoder.decode();
              entries = new URLSearchParams(text);
            } catch (err) {
              throw Object.assign(new TypeError(), { cause: err });
            }
            const formData = new FormData();
            for (const [name, value] of entries) {
              formData.append(name, value);
            }
            return formData;
          } else {
            await Promise.resolve();
            throwIfAborted(this[kState]);
            throw webidl.errors.exception({
              header: `${instance.name}.formData`,
              message: "Could not parse content as FormData."
            });
          }
        }
      };
      return methods;
    }
    function mixinBody(prototype) {
      Object.assign(prototype.prototype, bodyMixinMethods(prototype));
    }
    async function specConsumeBody(object, convertBytesToJSValue, instance) {
      webidl.brandCheck(object, instance);
      throwIfAborted(object[kState]);
      if (bodyUnusable(object[kState].body)) {
        throw new TypeError("Body is unusable");
      }
      const promise = createDeferredPromise();
      const errorSteps = (error2) => promise.reject(error2);
      const successSteps = (data) => {
        try {
          promise.resolve(convertBytesToJSValue(data));
        } catch (e2) {
          errorSteps(e2);
        }
      };
      if (object[kState].body == null) {
        successSteps(new Uint8Array());
        return promise.promise;
      }
      await fullyReadBody(object[kState].body, successSteps, errorSteps);
      return promise.promise;
    }
    function bodyUnusable(body) {
      return body != null && (body.stream.locked || util.isDisturbed(body.stream));
    }
    function utf8DecodeBytes(buffer) {
      if (buffer.length === 0) {
        return "";
      }
      if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
        buffer = buffer.subarray(3);
      }
      const output = textDecoder.decode(buffer);
      return output;
    }
    function parseJSONFromBytes(bytes) {
      return JSON.parse(utf8DecodeBytes(bytes));
    }
    function bodyMimeType(object) {
      const { headersList } = object[kState];
      const contentType = headersList.get("content-type");
      if (contentType === null) {
        return "failure";
      }
      return parseMIMEType(contentType);
    }
    module2.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/request.js
var require_request = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/request.js"(exports2, module2) {
    "use strict";
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors();
    var assert = require("assert");
    var { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols();
    var util = require_util();
    var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
    var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    var invalidPathRegex = /[^\u0021-\u00ff]/;
    var kHandler = Symbol("handler");
    var channels = {};
    var extractBody;
    try {
      const diagnosticsChannel = require("diagnostics_channel");
      channels.create = diagnosticsChannel.channel("undici:request:create");
      channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
      channels.headers = diagnosticsChannel.channel("undici:request:headers");
      channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
      channels.error = diagnosticsChannel.channel("undici:request:error");
    } catch {
      channels.create = { hasSubscribers: false };
      channels.bodySent = { hasSubscribers: false };
      channels.headers = { hasSubscribers: false };
      channels.trailers = { hasSubscribers: false };
      channels.error = { hasSubscribers: false };
    }
    var Request = class _Request {
      constructor(origin, {
        path: path2,
        method,
        body,
        headers,
        query,
        idempotent,
        blocking,
        upgrade,
        headersTimeout,
        bodyTimeout,
        reset,
        throwOnError,
        expectContinue
      }, handler) {
        if (typeof path2 !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (path2[0] !== "/" && !(path2.startsWith("http://") || path2.startsWith("https://")) && method !== "CONNECT") {
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        } else if (invalidPathRegex.exec(path2) !== null) {
          throw new InvalidArgumentError("invalid request path");
        }
        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        } else if (tokenRegExp.exec(method) === null) {
          throw new InvalidArgumentError("invalid request method");
        }
        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("invalid headersTimeout");
        }
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("invalid bodyTimeout");
        }
        if (reset != null && typeof reset !== "boolean") {
          throw new InvalidArgumentError("invalid reset");
        }
        if (expectContinue != null && typeof expectContinue !== "boolean") {
          throw new InvalidArgumentError("invalid expectContinue");
        }
        this.headersTimeout = headersTimeout;
        this.bodyTimeout = bodyTimeout;
        this.throwOnError = throwOnError === true;
        this.method = method;
        this.abort = null;
        if (body == null) {
          this.body = null;
        } else if (util.isStream(body)) {
          this.body = body;
          const rState = this.body._readableState;
          if (!rState || !rState.autoDestroy) {
            this.endHandler = function autoDestroy() {
              util.destroy(this);
            };
            this.body.on("end", this.endHandler);
          }
          this.errorHandler = (err) => {
            if (this.abort) {
              this.abort(err);
            } else {
              this.error = err;
            }
          };
          this.body.on("error", this.errorHandler);
        } else if (util.isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (ArrayBuffer.isView(body)) {
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
        } else if (body instanceof ArrayBuffer) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
          this.body = body;
        } else {
          throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = upgrade || null;
        this.path = query ? util.buildURL(path2, query) : path2;
        this.origin = origin;
        this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
        this.blocking = blocking == null ? false : blocking;
        this.reset = reset == null ? null : reset;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = "";
        this.expectContinue = expectContinue != null ? expectContinue : false;
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i3 = 0; i3 < headers.length; i3 += 2) {
            processHeader(this, headers[i3], headers[i3 + 1]);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i3 = 0; i3 < keys.length; i3++) {
            const key = keys[i3];
            processHeader(this, key, headers[key]);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        if (util.isFormDataLike(this.body)) {
          if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) {
            throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
          }
          if (!extractBody) {
            extractBody = require_body().extractBody;
          }
          const [bodyStream, contentType] = extractBody(body);
          if (this.contentType == null) {
            this.contentType = contentType;
            this.headers += `content-type: ${contentType}\r
`;
          }
          this.body = bodyStream.stream;
          this.contentLength = bodyStream.length;
        } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
          this.contentType = body.type;
          this.headers += `content-type: ${body.type}\r
`;
        }
        util.validateHandler(handler, method, upgrade);
        this.servername = util.getServerName(this.host);
        this[kHandler] = handler;
        if (channels.create.hasSubscribers) {
          channels.create.publish({ request: this });
        }
      }
      onBodySent(chunk) {
        if (this[kHandler].onBodySent) {
          try {
            return this[kHandler].onBodySent(chunk);
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers) {
          channels.bodySent.publish({ request: this });
        }
        if (this[kHandler].onRequestSent) {
          try {
            return this[kHandler].onRequestSent();
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onConnect(abort) {
        assert(!this.aborted);
        assert(!this.completed);
        if (this.error) {
          abort(this.error);
        } else {
          this.abort = abort;
          return this[kHandler].onConnect(abort);
        }
      }
      onHeaders(statusCode, headers, resume, statusText) {
        assert(!this.aborted);
        assert(!this.completed);
        if (channels.headers.hasSubscribers) {
          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        }
        try {
          return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
        } catch (err) {
          this.abort(err);
        }
      }
      onData(chunk) {
        assert(!this.aborted);
        assert(!this.completed);
        try {
          return this[kHandler].onData(chunk);
        } catch (err) {
          this.abort(err);
          return false;
        }
      }
      onUpgrade(statusCode, headers, socket) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        this.onFinally();
        assert(!this.aborted);
        this.completed = true;
        if (channels.trailers.hasSubscribers) {
          channels.trailers.publish({ request: this, trailers });
        }
        try {
          return this[kHandler].onComplete(trailers);
        } catch (err) {
          this.onError(err);
        }
      }
      onError(error2) {
        this.onFinally();
        if (channels.error.hasSubscribers) {
          channels.error.publish({ request: this, error: error2 });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[kHandler].onError(error2);
      }
      onFinally() {
        if (this.errorHandler) {
          this.body.off("error", this.errorHandler);
          this.errorHandler = null;
        }
        if (this.endHandler) {
          this.body.off("end", this.endHandler);
          this.endHandler = null;
        }
      }
      // TODO: adjust to support H2
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }
      static [kHTTP1BuildRequest](origin, opts, handler) {
        return new _Request(origin, opts, handler);
      }
      static [kHTTP2BuildRequest](origin, opts, handler) {
        const headers = opts.headers;
        opts = { ...opts, headers: null };
        const request = new _Request(origin, opts, handler);
        request.headers = {};
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i3 = 0; i3 < headers.length; i3 += 2) {
            processHeader(request, headers[i3], headers[i3 + 1], true);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i3 = 0; i3 < keys.length; i3++) {
            const key = keys[i3];
            processHeader(request, key, headers[key], true);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        return request;
      }
      static [kHTTP2CopyHeaders](raw) {
        const rawHeaders = raw.split("\r\n");
        const headers = {};
        for (const header of rawHeaders) {
          const [key, value] = header.split(": ");
          if (value == null || value.length === 0) continue;
          if (headers[key]) headers[key] += `,${value}`;
          else headers[key] = value;
        }
        return headers;
      }
    };
    function processHeaderValue(key, val, skipAppend) {
      if (val && typeof val === "object") {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      val = val != null ? `${val}` : "";
      if (headerCharRegex.exec(val) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      return skipAppend ? val : `${key}: ${val}\r
`;
    }
    function processHeader(request, key, val, skipAppend = false) {
      if (val && (typeof val === "object" && !Array.isArray(val))) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
        if (headerCharRegex.exec(val) !== null) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
        request.host = val;
      } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
        request.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
        request.contentType = val;
        if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
        else request.headers += processHeaderValue(key, val);
      } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
        throw new InvalidArgumentError("invalid transfer-encoding header");
      } else if (key.length === 10 && key.toLowerCase() === "connection") {
        const value = typeof val === "string" ? val.toLowerCase() : null;
        if (value !== "close" && value !== "keep-alive") {
          throw new InvalidArgumentError("invalid connection header");
        } else if (value === "close") {
          request.reset = true;
        }
      } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
        throw new InvalidArgumentError("invalid keep-alive header");
      } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
        throw new InvalidArgumentError("invalid upgrade header");
      } else if (key.length === 6 && key.toLowerCase() === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else if (tokenRegExp.exec(key) === null) {
        throw new InvalidArgumentError("invalid header key");
      } else {
        if (Array.isArray(val)) {
          for (let i3 = 0; i3 < val.length; i3++) {
            if (skipAppend) {
              if (request.headers[key]) request.headers[key] += `,${processHeaderValue(key, val[i3], skipAppend)}`;
              else request.headers[key] = processHeaderValue(key, val[i3], skipAppend);
            } else {
              request.headers += processHeaderValue(key, val[i3]);
            }
          }
        } else {
          if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
          else request.headers += processHeaderValue(key, val);
        }
      }
    }
    module2.exports = Request;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/dispatcher.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var Dispatcher = class extends EventEmitter {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
    };
    module2.exports = Dispatcher;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/dispatcher-base.js"(exports2, module2) {
    "use strict";
    var Dispatcher = require_dispatcher();
    var {
      ClientDestroyedError,
      ClientClosedError,
      InvalidArgumentError
    } = require_errors();
    var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
    var kDestroyed = Symbol("destroyed");
    var kClosed = Symbol("closed");
    var kOnDestroyed = Symbol("onDestroyed");
    var kOnClosed = Symbol("onClosed");
    var kInterceptedDispatch = Symbol("Intercepted Dispatch");
    var DispatcherBase = class extends Dispatcher {
      constructor() {
        super();
        this[kDestroyed] = false;
        this[kOnDestroyed] = null;
        this[kClosed] = false;
        this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      get interceptors() {
        return this[kInterceptors];
      }
      set interceptors(newInterceptors) {
        if (newInterceptors) {
          for (let i3 = newInterceptors.length - 1; i3 >= 0; i3--) {
            const interceptor = this[kInterceptors][i3];
            if (typeof interceptor !== "function") {
              throw new InvalidArgumentError("interceptor must be an function");
            }
          }
        }
        this[kInterceptors] = newInterceptors;
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve2, reject) => {
            this.close((err, data) => {
              return err ? reject(err) : resolve2(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        this[kClosed] = true;
        this[kOnClosed].push(callback);
        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i3 = 0; i3 < callbacks.length; i3++) {
            callbacks[i3](null, null);
          }
        };
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err, callback) {
        if (typeof err === "function") {
          callback = err;
          err = null;
        }
        if (callback === void 0) {
          return new Promise((resolve2, reject) => {
            this.destroy(err, (err2, data) => {
              return err2 ? (
                /* istanbul ignore next: should never error */
                reject(err2)
              ) : resolve2(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        this[kDestroyed] = true;
        this[kOnDestroyed] = this[kOnDestroyed] || [];
        this[kOnDestroyed].push(callback);
        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i3 = 0; i3 < callbacks.length; i3++) {
            callbacks[i3](null, null);
          }
        };
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      [kInterceptedDispatch](opts, handler) {
        if (!this[kInterceptors] || this[kInterceptors].length === 0) {
          this[kInterceptedDispatch] = this[kDispatch];
          return this[kDispatch](opts, handler);
        }
        let dispatch = this[kDispatch].bind(this);
        for (let i3 = this[kInterceptors].length - 1; i3 >= 0; i3--) {
          dispatch = this[kInterceptors][i3](dispatch);
        }
        this[kInterceptedDispatch] = dispatch;
        return dispatch(opts, handler);
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }
        try {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object.");
          }
          if (this[kDestroyed] || this[kOnDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          return this[kInterceptedDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }
          handler.onError(err);
          return false;
        }
      }
    };
    module2.exports = DispatcherBase;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/core/connect.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var assert = require("assert");
    var util = require_util();
    var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
    var tls;
    var SessionCache;
    if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
      SessionCache = class WeakSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
          this._sessionRegistry = new global.FinalizationRegistry((key) => {
            if (this._sessionCache.size < this._maxCachedSessions) {
              return;
            }
            const ref = this._sessionCache.get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this._sessionCache.delete(key);
            }
          });
        }
        get(sessionKey) {
          const ref = this._sessionCache.get(sessionKey);
          return ref ? ref.deref() : null;
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          this._sessionCache.set(sessionKey, new WeakRef(session));
          this._sessionRegistry.register(session, sessionKey);
        }
      };
    } else {
      SessionCache = class SimpleSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(sessionKey) {
          return this._sessionCache.get(sessionKey);
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          if (this._sessionCache.size >= this._maxCachedSessions) {
            const { value: oldestKey } = this._sessionCache.keys().next();
            this._sessionCache.delete(oldestKey);
          }
          this._sessionCache.set(sessionKey, session);
        }
      };
    }
    function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
        throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
      }
      const options = { path: socketPath, ...opts };
      const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
      timeout = timeout == null ? 1e4 : timeout;
      allowH2 = allowH2 != null ? allowH2 : false;
      return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
        let socket;
        if (protocol === "https:") {
          if (!tls) {
            tls = require("tls");
          }
          servername = servername || options.servername || util.getServerName(host) || null;
          const sessionKey = servername || hostname;
          const session = sessionCache.get(sessionKey) || null;
          assert(sessionKey);
          socket = tls.connect({
            highWaterMark: 16384,
            // TLS in node can't have bigger HWM anyway...
            ...options,
            servername,
            session,
            localAddress,
            // TODO(HTTP/2): Add support for h2c
            ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
            socket: httpSocket,
            // upgrade socket connection
            port: port || 443,
            host: hostname
          });
          socket.on("session", function(session2) {
            sessionCache.set(sessionKey, session2);
          });
        } else {
          assert(!httpSocket, "httpSocket can only be sent on TLS update");
          socket = net.connect({
            highWaterMark: 64 * 1024,
            // Same as nodejs fs streams.
            ...options,
            localAddress,
            port: port || 80,
            host: hostname
          });
        }
        if (options.keepAlive == null || options.keepAlive) {
          const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
          socket.setKeepAlive(true, keepAliveInitialDelay);
        }
        const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
        socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(null, this);
          }
        }).on("error", function(err) {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(err);
          }
        });
        return socket;
      };
    }
    function setupTimeout(onConnectTimeout2, timeout) {
      if (!timeout) {
        return () => {
        };
      }
      let s12 = null;
      let s22 = null;
      const timeoutId = setTimeout(() => {
        s12 = setImmediate(() => {
          if (process.platform === "win32") {
            s22 = setImmediate(() => onConnectTimeout2());
          } else {
            onConnectTimeout2();
          }
        });
      }, timeout);
      return () => {
        clearTimeout(timeoutId);
        clearImmediate(s12);
        clearImmediate(s22);
      };
    }
    function onConnectTimeout(socket) {
      util.destroy(socket, new ConnectTimeoutError());
    }
    module2.exports = buildConnector;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enumToMap = void 0;
    function enumToMap(obj) {
      const res = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (typeof value === "number") {
          res[key] = value;
        }
      });
      return res;
    }
    exports2.enumToMap = enumToMap;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/constants.js
var require_constants3 = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SPECIAL_HEADERS = exports2.HEADER_STATE = exports2.MINOR = exports2.MAJOR = exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS = exports2.TOKEN = exports2.STRICT_TOKEN = exports2.HEX = exports2.URL_CHAR = exports2.STRICT_URL_CHAR = exports2.USERINFO_CHARS = exports2.MARK = exports2.ALPHANUM = exports2.NUM = exports2.HEX_MAP = exports2.NUM_MAP = exports2.ALPHA = exports2.FINISH = exports2.H_METHOD_MAP = exports2.METHOD_MAP = exports2.METHODS_RTSP = exports2.METHODS_ICE = exports2.METHODS_HTTP = exports2.METHODS = exports2.LENIENT_FLAGS = exports2.FLAGS = exports2.TYPE = exports2.ERROR = void 0;
    var utils_1 = require_utils2();
    var ERROR;
    (function(ERROR2) {
      ERROR2[ERROR2["OK"] = 0] = "OK";
      ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
      ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
      ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
      ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
      ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
      ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
      ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
      ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
      ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
      ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
      ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
      ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
      ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
      ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
      ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
      ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
      ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
      ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
      ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
      ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
      ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
      ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
      ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
      ERROR2[ERROR2["USER"] = 24] = "USER";
    })(ERROR = exports2.ERROR || (exports2.ERROR = {}));
    var TYPE;
    (function(TYPE2) {
      TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
      TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
      TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
    })(TYPE = exports2.TYPE || (exports2.TYPE = {}));
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
      FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
      FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
      FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
      FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
      FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
      FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
      FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
      FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
    })(FLAGS = exports2.FLAGS || (exports2.FLAGS = {}));
    var LENIENT_FLAGS;
    (function(LENIENT_FLAGS2) {
      LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
      LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
      LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
    })(LENIENT_FLAGS = exports2.LENIENT_FLAGS || (exports2.LENIENT_FLAGS = {}));
    var METHODS;
    (function(METHODS2) {
      METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
      METHODS2[METHODS2["GET"] = 1] = "GET";
      METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
      METHODS2[METHODS2["POST"] = 3] = "POST";
      METHODS2[METHODS2["PUT"] = 4] = "PUT";
      METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
      METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
      METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
      METHODS2[METHODS2["COPY"] = 8] = "COPY";
      METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
      METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
      METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
      METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
      METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
      METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
      METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
      METHODS2[METHODS2["BIND"] = 16] = "BIND";
      METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
      METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
      METHODS2[METHODS2["ACL"] = 19] = "ACL";
      METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
      METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
      METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
      METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
      METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
      METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
      METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
      METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
      METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
      METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
      METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
      METHODS2[METHODS2["LINK"] = 31] = "LINK";
      METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
      METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
      METHODS2[METHODS2["PRI"] = 34] = "PRI";
      METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
      METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
      METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
      METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
      METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
      METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
      METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
      METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
      METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
      METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
      METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
    })(METHODS = exports2.METHODS || (exports2.METHODS = {}));
    exports2.METHODS_HTTP = [
      METHODS.DELETE,
      METHODS.GET,
      METHODS.HEAD,
      METHODS.POST,
      METHODS.PUT,
      METHODS.CONNECT,
      METHODS.OPTIONS,
      METHODS.TRACE,
      METHODS.COPY,
      METHODS.LOCK,
      METHODS.MKCOL,
      METHODS.MOVE,
      METHODS.PROPFIND,
      METHODS.PROPPATCH,
      METHODS.SEARCH,
      METHODS.UNLOCK,
      METHODS.BIND,
      METHODS.REBIND,
      METHODS.UNBIND,
      METHODS.ACL,
      METHODS.REPORT,
      METHODS.MKACTIVITY,
      METHODS.CHECKOUT,
      METHODS.MERGE,
      METHODS["M-SEARCH"],
      METHODS.NOTIFY,
      METHODS.SUBSCRIBE,
      METHODS.UNSUBSCRIBE,
      METHODS.PATCH,
      METHODS.PURGE,
      METHODS.MKCALENDAR,
      METHODS.LINK,
      METHODS.UNLINK,
      METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      METHODS.SOURCE
    ];
    exports2.METHODS_ICE = [
      METHODS.SOURCE
    ];
    exports2.METHODS_RTSP = [
      METHODS.OPTIONS,
      METHODS.DESCRIBE,
      METHODS.ANNOUNCE,
      METHODS.SETUP,
      METHODS.PLAY,
      METHODS.PAUSE,
      METHODS.TEARDOWN,
      METHODS.GET_PARAMETER,
      METHODS.SET_PARAMETER,
      METHODS.REDIRECT,
      METHODS.RECORD,
      METHODS.FLUSH,
      // For AirPlay
      METHODS.GET,
      METHODS.POST
    ];
    exports2.METHOD_MAP = utils_1.enumToMap(METHODS);
    exports2.H_METHOD_MAP = {};
    Object.keys(exports2.METHOD_MAP).forEach((key) => {
      if (/^H/.test(key)) {
        exports2.H_METHOD_MAP[key] = exports2.METHOD_MAP[key];
      }
    });
    var FINISH;
    (function(FINISH2) {
      FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
      FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
      FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
    })(FINISH = exports2.FINISH || (exports2.FINISH = {}));
    exports2.ALPHA = [];
    for (let i3 = "A".charCodeAt(0); i3 <= "Z".charCodeAt(0); i3++) {
      exports2.ALPHA.push(String.fromCharCode(i3));
      exports2.ALPHA.push(String.fromCharCode(i3 + 32));
    }
    exports2.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports2.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports2.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports2.ALPHANUM = exports2.ALPHA.concat(exports2.NUM);
    exports2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports2.USERINFO_CHARS = exports2.ALPHANUM.concat(exports2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports2.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.URL_CHAR = exports2.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let i3 = 128; i3 <= 255; i3++) {
      exports2.URL_CHAR.push(i3);
    }
    exports2.HEX = exports2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports2.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.TOKEN = exports2.STRICT_TOKEN.concat([" "]);
    exports2.HEADER_CHARS = ["	"];
    for (let i3 = 32; i3 <= 255; i3++) {
      if (i3 !== 127) {
        exports2.HEADER_CHARS.push(i3);
      }
    }
    exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS.filter((c3) => c3 !== 44);
    exports2.MAJOR = exports2.NUM_MAP;
    exports2.MINOR = exports2.MAJOR;
    var HEADER_STATE;
    (function(HEADER_STATE2) {
      HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
      HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
      HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
      HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(HEADER_STATE = exports2.HEADER_STATE || (exports2.HEADER_STATE = {}));
    exports2.SPECIAL_HEADERS = {
      "connection": HEADER_STATE.CONNECTION,
      "content-length": HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": HEADER_STATE.CONNECTION,
      "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": HEADER_STATE.UPGRADE
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/RedirectHandler.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var { kBodyUsed } = require_symbols();
    var assert = require("assert");
    var { InvalidArgumentError } = require_errors();
    var EE = require("events");
    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
    var kBody = Symbol("body");
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    var RedirectHandler = class {
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        util.validateHandler(handler, opts.method, opts.upgrade);
        this.dispatch = dispatch;
        this.location = null;
        this.abort = null;
        this.opts = { ...opts, maxRedirections: 0 };
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];
        if (util.isStream(this.opts.body)) {
          if (util.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function() {
              assert(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, "data", function() {
              this[kBodyUsed] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onConnect(abort) {
        this.abort = abort;
        this.handler.onConnect(abort, { history: this.history });
      }
      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
      onError(error2) {
        this.handler.onError(error2);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          return this.handler.onHeaders(statusCode, headers, resume, statusText);
        }
        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
        const path2 = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
        this.opts.path = path2;
        this.opts.origin = origin;
        this.opts.maxRedirections = 0;
        this.opts.query = null;
        if (statusCode === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          this.opts.body = null;
        }
      }
      onData(chunk) {
        if (this.location) {
        } else {
          return this.handler.onData(chunk);
        }
      }
      onComplete(trailers) {
        if (this.location) {
          this.location = null;
          this.abort = null;
          this.dispatch(this.opts, this);
        } else {
          this.handler.onComplete(trailers);
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) {
          this.handler.onBodySent(chunk);
        }
      }
    };
    function parseLocation(statusCode, headers) {
      if (redirectableStatusCodes.indexOf(statusCode) === -1) {
        return null;
      }
      for (let i3 = 0; i3 < headers.length; i3 += 2) {
        if (headers[i3].toString().toLowerCase() === "location") {
          return headers[i3 + 1];
        }
      }
    }
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      if (header.length === 4) {
        return util.headerNameToString(header) === "host";
      }
      if (removeContent && util.headerNameToString(header).startsWith("content-")) {
        return true;
      }
      if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
        const name = util.headerNameToString(header);
        return name === "authorization" || name === "cookie" || name === "proxy-authorization";
      }
      return false;
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i3 = 0; i3 < headers.length; i3 += 2) {
          if (!shouldRemoveHeader(headers[i3], removeContent, unknownOrigin)) {
            ret.push(headers[i3], headers[i3 + 1]);
          }
        }
      } else if (headers && typeof headers === "object") {
        for (const key of Object.keys(headers)) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, headers[key]);
          }
        }
      } else {
        assert(headers == null, "headers must be an object or an array");
      }
      return ret;
    }
    module2.exports = RedirectHandler;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/interceptor/redirectInterceptor.js"(exports2, module2) {
    "use strict";
    var RedirectHandler = require_RedirectHandler();
    function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { maxRedirections = defaultMaxRedirections } = opts;
          if (!maxRedirections) {
            return dispatch(opts, handler);
          }
          const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
          opts = { ...opts, maxRedirections: 0 };
          return dispatch(opts, redirectHandler);
        };
      };
    }
    module2.exports = createRedirectInterceptor;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/llhttp-wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/client.js
var require_client = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/client.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var net = require("net");
    var http = require("http");
    var { pipeline } = require("stream");
    var util = require_util();
    var timers = require_timers();
    var Request = require_request();
    var DispatcherBase = require_dispatcher_base();
    var {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      InvalidArgumentError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError,
      ResponseExceededMaxSizeError,
      ClientDestroyedError
    } = require_errors();
    var buildConnector = require_connect();
    var {
      kUrl,
      kReset,
      kServerName,
      kClient,
      kBusy,
      kParser,
      kConnect,
      kBlocking,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRedirections,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kInterceptors,
      kLocalAddress,
      kMaxResponseSize,
      kHTTPConnVersion,
      // HTTP2
      kHost,
      kHTTP2Session,
      kHTTP2SessionState,
      kHTTP2BuildRequest,
      kHTTP2CopyHeaders,
      kHTTP1BuildRequest
    } = require_symbols();
    var http2;
    try {
      http2 = require("http2");
    } catch {
      http2 = { constants: {} };
    }
    var {
      constants: {
        HTTP2_HEADER_AUTHORITY,
        HTTP2_HEADER_METHOD,
        HTTP2_HEADER_PATH,
        HTTP2_HEADER_SCHEME,
        HTTP2_HEADER_CONTENT_LENGTH,
        HTTP2_HEADER_EXPECT,
        HTTP2_HEADER_STATUS
      }
    } = http2;
    var h2ExperimentalWarned = false;
    var FastBuffer = Buffer[Symbol.species];
    var kClosedResolve = Symbol("kClosedResolve");
    var channels = {};
    try {
      const diagnosticsChannel = require("diagnostics_channel");
      channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
      channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
      channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
      channels.connected = diagnosticsChannel.channel("undici:client:connected");
    } catch {
      channels.sendHeaders = { hasSubscribers: false };
      channels.beforeConnect = { hasSubscribers: false };
      channels.connectError = { hasSubscribers: false };
      channels.connected = { hasSubscribers: false };
    }
    var Client = class extends DispatcherBase {
      /**
       *
       * @param {string|URL} url
       * @param {import('../types/client').Client.Options} options
       */
      constructor(url, {
        interceptors,
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        connectTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls,
        strictContentLength,
        maxCachedSessions,
        maxRedirections,
        connect: connect2,
        maxRequestsPerClient,
        localAddress,
        maxResponseSize,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        // h2
        allowH2,
        maxConcurrentStreams
      } = {}) {
        super();
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
          throw new InvalidArgumentError("invalid maxHeaderSize");
        }
        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
          throw new InvalidArgumentError("invalid connectTimeout");
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        }
        if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
          throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
        }
        if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
          throw new InvalidArgumentError("localAddress must be valid string IP address");
        }
        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
          throw new InvalidArgumentError("maxResponseSize must be a positive number");
        }
        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
          throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
        }
        if (allowH2 != null && typeof allowH2 !== "boolean") {
          throw new InvalidArgumentError("allowH2 must be a valid boolean value");
        }
        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
          throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
        }
        if (typeof connect2 !== "function") {
          connect2 = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect2
          });
        }
        this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
        this[kUrl] = util.parseOrigin(url);
        this[kConnector] = connect2;
        this[kSocket] = null;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kLocalAddress] = localAddress != null ? localAddress : null;
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
        this[kMaxRedirections] = maxRedirections;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
        this[kHTTPConnVersion] = "h1";
        this[kHTTP2Session] = null;
        this[kHTTP2SessionState] = !allowH2 ? null : {
          // streams: null, // Fixed queue of streams - For future support of `push`
          openStreams: 0,
          // Keep track of them to decide wether or not unref the session
          maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
          // Max peerConcurrentStreams for a Node h2 server
        };
        this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        resume(this, true);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
      }
      get [kBusy]() {
        const socket = this[kSocket];
        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
      }
      /* istanbul ignore: only used for test */
      [kConnect](cb) {
        connect(this);
        this.once("connect", cb);
      }
      [kDispatch](opts, handler) {
        const origin = opts.origin || this[kUrl].origin;
        const request = this[kHTTPConnVersion] === "h2" ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);
        this[kQueue].push(request);
        if (this[kResuming]) {
        } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
          this[kResuming] = 1;
          process.nextTick(resume, this);
        } else {
          resume(this, true);
        }
        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }
        return this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve2) => {
          if (!this[kSize]) {
            resolve2(null);
          } else {
            this[kClosedResolve] = resolve2;
          }
        });
      }
      async [kDestroy](err) {
        return new Promise((resolve2) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i3 = 0; i3 < requests.length; i3++) {
            const request = requests[i3];
            errorRequest(this, request, err);
          }
          const callback = () => {
            if (this[kClosedResolve]) {
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve2();
          };
          if (this[kHTTP2Session] != null) {
            util.destroy(this[kHTTP2Session], err);
            this[kHTTP2Session] = null;
            this[kHTTP2SessionState] = null;
          }
          if (!this[kSocket]) {
            queueMicrotask(callback);
          } else {
            util.destroy(this[kSocket].on("close", callback), err);
          }
          resume(this);
        });
      }
    };
    function onHttp2SessionError(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kSocket][kError] = err;
      onError(this[kClient], err);
    }
    function onHttp2FrameError(type, code, id) {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      if (id === 0) {
        this[kSocket][kError] = err;
        onError(this[kClient], err);
      }
    }
    function onHttp2SessionEnd() {
      util.destroy(this, new SocketError("other side closed"));
      util.destroy(this[kSocket], new SocketError("other side closed"));
    }
    function onHTTP2GoAway(code) {
      const client = this[kClient];
      const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
      client[kSocket] = null;
      client[kHTTP2Session] = null;
      if (client.destroyed) {
        assert(this[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i3 = 0; i3 < requests.length; i3++) {
          const request = requests[i3];
          errorRequest(this, request, err);
        }
      } else if (client[kRunning] > 0) {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit(
        "disconnect",
        client[kUrl],
        [client],
        err
      );
      resume(client);
    }
    var constants = require_constants3();
    var createRedirectInterceptor = require_redirectInterceptor();
    var EMPTY_BUF = Buffer.alloc(0);
    async function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
      let mod;
      try {
        mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
      } catch (e2) {
        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
      }
      return await WebAssembly.instantiate(mod, {
        env: {
          /* eslint-disable camelcase */
          wasm_on_url: (p3, at, len) => {
            return 0;
          },
          wasm_on_status: (p3, at, len) => {
            assert.strictEqual(currentParser.ptr, p3);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_begin: (p3) => {
            assert.strictEqual(currentParser.ptr, p3);
            return currentParser.onMessageBegin() || 0;
          },
          wasm_on_header_field: (p3, at, len) => {
            assert.strictEqual(currentParser.ptr, p3);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_header_value: (p3, at, len) => {
            assert.strictEqual(currentParser.ptr, p3);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_headers_complete: (p3, statusCode, upgrade, shouldKeepAlive) => {
            assert.strictEqual(currentParser.ptr, p3);
            return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
          },
          wasm_on_body: (p3, at, len) => {
            assert.strictEqual(currentParser.ptr, p3);
            const start = at - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_complete: (p3) => {
            assert.strictEqual(currentParser.ptr, p3);
            return currentParser.onMessageComplete() || 0;
          }
          /* eslint-enable camelcase */
        }
      });
    }
    var llhttpInstance = null;
    var llhttpPromise = lazyllhttp();
    llhttpPromise.catch();
    var currentParser = null;
    var currentBufferRef = null;
    var currentBufferSize = 0;
    var currentBufferPtr = null;
    var TIMEOUT_HEADERS = 1;
    var TIMEOUT_BODY = 2;
    var TIMEOUT_IDLE = 3;
    var Parser = class {
      constructor(client, socket, { exports: exports3 }) {
        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
        this.llhttp = exports3;
        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = null;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.keepAlive = "";
        this.contentLength = "";
        this.connection = "";
        this.maxResponseSize = client[kMaxResponseSize];
      }
      setTimeout(value, type) {
        this.timeoutType = type;
        if (value !== this.timeoutValue) {
          timers.clearTimeout(this.timeout);
          if (value) {
            this.timeout = timers.setTimeout(onParserTimeout, value, this);
            if (this.timeout.unref) {
              this.timeout.unref();
            }
          } else {
            this.timeout = null;
          }
          this.timeoutValue = value;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_resume(this.ptr);
        assert(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const chunk = this.socket.read();
          if (chunk === null) {
            break;
          }
          this.execute(chunk);
        }
      }
      execute(data) {
        assert(this.ptr != null);
        assert(currentParser == null);
        assert(!this.paused);
        const { socket, llhttp } = this;
        if (data.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(data.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }
        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
        try {
          let ret;
          try {
            currentBufferRef = data;
            currentParser = this;
            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }
          const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
          if (ret === constants.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(data.slice(offset));
          } else if (ret === constants.ERROR.PAUSED) {
            this.paused = true;
            socket.unshift(data.slice(offset));
          } else if (ret !== constants.ERROR.OK) {
            const ptr = llhttp.llhttp_get_error_reason(this.ptr);
            let message = "";
            if (ptr) {
              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
            }
            throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
          }
        } catch (err) {
          util.destroy(socket, err);
        }
      }
      destroy() {
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        timers.clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      onStatus(buf) {
        this.statusText = buf.toString();
      }
      onMessageBegin() {
        const { socket, client } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
      }
      onHeaderField(buf) {
        const len = this.headers.length;
        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        this.trackHeader(buf.length);
      }
      onHeaderValue(buf) {
        let len = this.headers.length;
        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        const key = this.headers[len - 2];
        if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
          this.keepAlive += buf.toString();
        } else if (key.length === 10 && key.toString().toLowerCase() === "connection") {
          this.connection += buf.toString();
        } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
          this.contentLength += buf.toString();
        }
        this.trackHeader(buf.length);
      }
      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util.destroy(this.socket, new HeadersOverflowError());
        }
      }
      onUpgrade(head) {
        const { upgrade, client, socket, headers, statusCode } = this;
        assert(upgrade);
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(!socket.destroyed);
        assert(socket === client[kSocket]);
        assert(!this.paused);
        assert(request.upgrade || request.method === "CONNECT");
        this.statusCode = null;
        this.statusText = "";
        this.shouldKeepAlive = null;
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        socket.unshift(head);
        socket[kParser].destroy();
        socket[kParser] = null;
        socket[kClient] = null;
        socket[kError] = null;
        socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
        client[kSocket] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util.destroy(socket, err);
        }
        resume(client);
      }
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        assert(!this.upgrade);
        assert(this.statusCode < 200);
        if (statusCode === 100) {
          util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
          return -1;
        }
        if (upgrade && !request.upgrade) {
          util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
          return -1;
        }
        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
        this.statusCode = statusCode;
        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
        request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
        if (this.statusCode >= 200) {
          const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (request.method === "CONNECT") {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        if (upgrade) {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (this.shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
        if (request.aborted) {
          return -1;
        }
        if (request.method === "HEAD") {
          return 1;
        }
        if (statusCode < 200) {
          return 1;
        }
        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          resume(client);
        }
        return pause ? constants.ERROR.PAUSED : 0;
      }
      onBody(buf) {
        const { client, socket, statusCode, maxResponseSize } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        assert(statusCode >= 200);
        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
          util.destroy(socket, new ResponseExceededMaxSizeError());
          return -1;
        }
        this.bytesRead += buf.length;
        if (request.onData(buf) === false) {
          return constants.ERROR.PAUSED;
        }
      }
      onMessageComplete() {
        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }
        if (upgrade) {
          return;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(statusCode >= 100);
        this.statusCode = null;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.keepAlive = "";
        this.connection = "";
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (statusCode < 200) {
          return;
        }
        if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
          util.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }
        request.onComplete(headers);
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          assert.strictEqual(client[kRunning], 0);
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (client[kPipelining] === 1) {
          setImmediate(resume, client);
        } else {
          resume(client);
        }
      }
    };
    function onParserTimeout(parser) {
      const { socket, timeoutType, client } = parser;
      if (timeoutType === TIMEOUT_HEADERS) {
        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
          assert(!parser.paused, "cannot be paused while waiting for headers");
          util.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!parser.paused) {
          util.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_IDLE) {
        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util.destroy(socket, new InformationalError("socket idle timeout"));
      }
    }
    function onSocketReadable() {
      const { [kParser]: parser } = this;
      if (parser) {
        parser.readMore();
      }
    }
    function onSocketError(err) {
      const { [kClient]: client, [kParser]: parser } = this;
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      if (client[kHTTPConnVersion] !== "h2") {
        if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      this[kError] = err;
      onError(this[kClient], err);
    }
    function onError(client, err) {
      if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
        assert(client[kPendingIdx] === client[kRunningIdx]);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i3 = 0; i3 < requests.length; i3++) {
          const request = requests[i3];
          errorRequest(client, request, err);
        }
        assert(client[kSize] === 0);
      }
    }
    function onSocketEnd() {
      const { [kParser]: parser, [kClient]: client } = this;
      if (client[kHTTPConnVersion] !== "h2") {
        if (parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }
    function onSocketClose() {
      const { [kClient]: client, [kParser]: parser } = this;
      if (client[kHTTPConnVersion] === "h1" && parser) {
        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
        }
        this[kParser].destroy();
        this[kParser] = null;
      }
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      client[kSocket] = null;
      if (client.destroyed) {
        assert(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i3 = 0; i3 < requests.length; i3++) {
          const request = requests[i3];
          errorRequest(client, request, err);
        }
      } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      resume(client);
    }
    async function connect(client) {
      assert(!client[kConnecting]);
      assert(!client[kSocket]);
      let { host, hostname, protocol, port } = client[kUrl];
      if (hostname[0] === "[") {
        const idx = hostname.indexOf("]");
        assert(idx !== -1);
        const ip = hostname.substring(1, idx);
        assert(net.isIP(ip));
        hostname = ip;
      }
      client[kConnecting] = true;
      if (channels.beforeConnect.hasSubscribers) {
        channels.beforeConnect.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector]
        });
      }
      try {
        const socket = await new Promise((resolve2, reject) => {
          client[kConnector]({
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          }, (err, socket2) => {
            if (err) {
              reject(err);
            } else {
              resolve2(socket2);
            }
          });
        });
        if (client.destroyed) {
          util.destroy(socket.on("error", () => {
          }), new ClientDestroyedError());
          return;
        }
        client[kConnecting] = false;
        assert(socket);
        const isH2 = socket.alpnProtocol === "h2";
        if (isH2) {
          if (!h2ExperimentalWarned) {
            h2ExperimentalWarned = true;
            process.emitWarning("H2 support is experimental, expect them to change at any time.", {
              code: "UNDICI-H2"
            });
          }
          const session = http2.connect(client[kUrl], {
            createConnection: () => socket,
            peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
          });
          client[kHTTPConnVersion] = "h2";
          session[kClient] = client;
          session[kSocket] = socket;
          session.on("error", onHttp2SessionError);
          session.on("frameError", onHttp2FrameError);
          session.on("end", onHttp2SessionEnd);
          session.on("goaway", onHTTP2GoAway);
          session.on("close", onSocketClose);
          session.unref();
          client[kHTTP2Session] = session;
          socket[kHTTP2Session] = session;
        } else {
          if (!llhttpInstance) {
            llhttpInstance = await llhttpPromise;
            llhttpPromise = null;
          }
          socket[kNoRef] = false;
          socket[kWriting] = false;
          socket[kReset] = false;
          socket[kBlocking] = false;
          socket[kParser] = new Parser(client, socket, llhttpInstance);
        }
        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket[kClient] = client;
        socket[kError] = null;
        socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
        client[kSocket] = socket;
        if (channels.connected.hasSubscribers) {
          channels.connected.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            socket
          });
        }
        client.emit("connect", client[kUrl], [client]);
      } catch (err) {
        if (client.destroyed) {
          return;
        }
        client[kConnecting] = false;
        if (channels.connectError.hasSubscribers) {
          channels.connectError.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            error: err
          });
        }
        if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          assert(client[kRunning] === 0);
          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
            const request = client[kQueue][client[kPendingIdx]++];
            errorRequest(client, request, err);
          }
        } else {
          onError(client, err);
        }
        client.emit("connectionError", client[kUrl], [client], err);
      }
      resume(client);
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain", client[kUrl], [client]);
    }
    function resume(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    function _resume(client, sync) {
      while (true) {
        if (client.destroyed) {
          assert(client[kPending] === 0);
          return;
        }
        if (client[kClosedResolve] && !client[kSize]) {
          client[kClosedResolve]();
          client[kClosedResolve] = null;
          return;
        }
        const socket = client[kSocket];
        if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
          if (client[kSize] === 0) {
            if (!socket[kNoRef] && socket.unref) {
              socket.unref();
              socket[kNoRef] = true;
            }
          } else if (socket[kNoRef] && socket.ref) {
            socket.ref();
            socket[kNoRef] = false;
          }
          if (client[kSize] === 0) {
            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
              socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
            }
          } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
              const request2 = client[kQueue][client[kRunningIdx]];
              const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
              socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
            }
          }
        }
        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            process.nextTick(emitDrain, client);
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (client[kPending] === 0) {
          return;
        }
        if (client[kRunning] >= (client[kPipelining] || 1)) {
          return;
        }
        const request = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
          if (client[kRunning] > 0) {
            return;
          }
          client[kServerName] = request.servername;
          if (socket && socket.servername !== request.servername) {
            util.destroy(socket, new InformationalError("servername changed"));
            return;
          }
        }
        if (client[kConnecting]) {
          return;
        }
        if (!socket && !client[kHTTP2Session]) {
          connect(client);
          return;
        }
        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return;
        }
        if (client[kRunning] > 0 && !request.idempotent) {
          return;
        }
        if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
          return;
        }
        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
          return;
        }
        if (!request.aborted && write(client, request)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function write(client, request) {
      if (client[kHTTPConnVersion] === "h2") {
        writeH2(client, client[kHTTP2Session], request);
        return;
      }
      const { body, method, path: path2, host, upgrade, headers, blocking, reset } = request;
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      const bodyLength = util.bodyLength(body);
      let contentLength = bodyLength;
      if (contentLength === null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      const socket = client[kSocket];
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
          util.destroy(socket, new InformationalError("aborted"));
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === "HEAD") {
        socket[kReset] = true;
      }
      if (upgrade || method === "CONNECT") {
        socket[kReset] = true;
      }
      if (reset != null) {
        socket[kReset] = reset;
      }
      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }
      if (blocking) {
        socket[kBlocking] = true;
      }
      let header = `${method} ${path2} HTTP/1.1\r
`;
      if (typeof host === "string") {
        header += `host: ${host}\r
`;
      } else {
        header += client[kHostHeader];
      }
      if (upgrade) {
        header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining] && !socket[kReset]) {
        header += "connection: keep-alive\r\n";
      } else {
        header += "connection: close\r\n";
      }
      if (headers) {
        header += headers;
      }
      if (channels.sendHeaders.hasSubscribers) {
        channels.sendHeaders.publish({ request, headers: header, socket });
      }
      if (!body || bodyLength === 0) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          assert(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "latin1");
        }
        request.onRequestSent();
      } else if (util.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(body);
        socket.uncork();
        request.onBodySent(body);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
        } else {
          writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
        }
      } else if (util.isStream(body)) {
        writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
      } else if (util.isIterable(body)) {
        writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
      } else {
        assert(false);
      }
      return true;
    }
    function writeH2(client, session, request) {
      const { body, method, path: path2, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
      let headers;
      if (typeof reqHeaders === "string") headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
      else headers = reqHeaders;
      if (upgrade) {
        errorRequest(client, request, new Error("Upgrade not supported for H2"));
        return false;
      }
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      let stream;
      const h2State = client[kHTTP2SessionState];
      headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
      headers[HTTP2_HEADER_METHOD] = method;
      if (method === "CONNECT") {
        session.ref();
        stream = session.request(headers, { endStream: false, signal });
        if (stream.id && !stream.pending) {
          request.onUpgrade(null, null, stream);
          ++h2State.openStreams;
        } else {
          stream.once("ready", () => {
            request.onUpgrade(null, null, stream);
            ++h2State.openStreams;
          });
        }
        stream.once("close", () => {
          h2State.openStreams -= 1;
          if (h2State.openStreams === 0) session.unref();
        });
        return true;
      }
      headers[HTTP2_HEADER_PATH] = path2;
      headers[HTTP2_HEADER_SCHEME] = "https";
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      let contentLength = util.bodyLength(body);
      if (contentLength == null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 || !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      if (contentLength != null) {
        assert(body, "no body must not have content length");
        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
      }
      session.ref();
      const shouldEndStream = method === "GET" || method === "HEAD";
      if (expectContinue) {
        headers[HTTP2_HEADER_EXPECT] = "100-continue";
        stream = session.request(headers, { endStream: shouldEndStream, signal });
        stream.once("continue", writeBodyH2);
      } else {
        stream = session.request(headers, {
          endStream: shouldEndStream,
          signal
        });
        writeBodyH2();
      }
      ++h2State.openStreams;
      stream.once("response", (headers2) => {
        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
        if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), "") === false) {
          stream.pause();
        }
      });
      stream.once("end", () => {
        request.onComplete([]);
      });
      stream.on("data", (chunk) => {
        if (request.onData(chunk) === false) {
          stream.pause();
        }
      });
      stream.once("close", () => {
        h2State.openStreams -= 1;
        if (h2State.openStreams === 0) {
          session.unref();
        }
      });
      stream.once("error", function(err) {
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });
      stream.once("frameError", (type, code) => {
        const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
        errorRequest(client, request, err);
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });
      return true;
      function writeBodyH2() {
        if (!body) {
          request.onRequestSent();
        } else if (util.isBuffer(body)) {
          assert(contentLength === body.byteLength, "buffer body must have content length");
          stream.cork();
          stream.write(body);
          stream.uncork();
          stream.end();
          request.onBodySent(body);
          request.onRequestSent();
        } else if (util.isBlobLike(body)) {
          if (typeof body.stream === "function") {
            writeIterable({
              client,
              request,
              contentLength,
              h2stream: stream,
              expectsPayload,
              body: body.stream(),
              socket: client[kSocket],
              header: ""
            });
          } else {
            writeBlob({
              body,
              client,
              request,
              contentLength,
              expectsPayload,
              h2stream: stream,
              header: "",
              socket: client[kSocket]
            });
          }
        } else if (util.isStream(body)) {
          writeStream({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            socket: client[kSocket],
            h2stream: stream,
            header: ""
          });
        } else if (util.isIterable(body)) {
          writeIterable({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            header: "",
            h2stream: stream,
            socket: client[kSocket]
          });
        } else {
          assert(false);
        }
      }
    }
    function writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      if (client[kHTTPConnVersion] === "h2") {
        let onPipeData = function(chunk) {
          request.onBodySent(chunk);
        };
        const pipe = pipeline(
          body,
          h2stream,
          (err) => {
            if (err) {
              util.destroy(body, err);
              util.destroy(h2stream, err);
            } else {
              request.onRequestSent();
            }
          }
        );
        pipe.on("data", onPipeData);
        pipe.once("end", () => {
          pipe.removeListener("data", onPipeData);
          util.destroy(pipe);
        });
        return;
      }
      let finished = false;
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      const onData = function(chunk) {
        if (finished) {
          return;
        }
        try {
          if (!writer.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util.destroy(this, err);
        }
      };
      const onDrain = function() {
        if (finished) {
          return;
        }
        if (body.resume) {
          body.resume();
        }
      };
      const onAbort = function() {
        if (finished) {
          return;
        }
        const err = new RequestAbortedError();
        queueMicrotask(() => onFinished(err));
      };
      const onFinished = function(err) {
        if (finished) {
          return;
        }
        finished = true;
        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
        socket.off("drain", onDrain).off("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
        if (!err) {
          try {
            writer.end();
          } catch (er) {
            err = er;
          }
        }
        writer.destroy(err);
        if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
          util.destroy(body, err);
        } else {
          util.destroy(body);
        }
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
      if (body.resume) {
        body.resume();
      }
      socket.on("drain", onDrain).on("error", onFinished);
    }
    async function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength === body.size, "blob body must have content length");
      const isH2 = client[kHTTPConnVersion] === "h2";
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        if (isH2) {
          h2stream.cork();
          h2stream.write(buffer);
          h2stream.uncork();
        } else {
          socket.cork();
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          socket.write(buffer);
          socket.uncork();
        }
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        resume(client);
      } catch (err) {
        util.destroy(isH2 ? h2stream : socket, err);
      }
    }
    async function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve2, reject) => {
        assert(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve2;
        }
      });
      if (client[kHTTPConnVersion] === "h2") {
        h2stream.on("close", onDrain).on("drain", onDrain);
        try {
          for await (const chunk of body) {
            if (socket[kError]) {
              throw socket[kError];
            }
            const res = h2stream.write(chunk);
            request.onBodySent(chunk);
            if (!res) {
              await waitForDrain();
            }
          }
        } catch (err) {
          h2stream.destroy(err);
        } finally {
          request.onRequestSent();
          h2stream.end();
          h2stream.off("close", onDrain).off("drain", onDrain);
        }
        return;
      }
      socket.on("close", onDrain).on("drain", onDrain);
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          if (!writer.write(chunk)) {
            await waitForDrain();
          }
        }
        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }
    var AsyncWriter = class {
      constructor({ socket, request, contentLength, client, expectsPayload, header }) {
        this.socket = socket;
        this.request = request;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;
        socket[kWriting] = true;
      }
      write(chunk) {
        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return false;
        }
        const len = Buffer.byteLength(chunk);
        if (!len) {
          return true;
        }
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        socket.cork();
        if (bytesWritten === 0) {
          if (!expectsPayload) {
            socket[kReset] = true;
          }
          if (contentLength === null) {
            socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
          } else {
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          }
        }
        if (contentLength === null) {
          socket.write(`\r
${len.toString(16)}\r
`, "latin1");
        }
        this.bytesWritten += len;
        const ret = socket.write(chunk);
        socket.uncork();
        request.onBodySent(chunk);
        if (!ret) {
          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
        }
        return ret;
      }
      end() {
        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
        request.onRequestSent();
        socket[kWriting] = false;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            socket.write(`${header}\r
`, "latin1");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "latin1");
        }
        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
        resume(client);
      }
      destroy(err) {
        const { socket, client } = this;
        socket[kWriting] = false;
        if (err) {
          assert(client[kRunning] <= 1, "pipeline should only contain this request");
          util.destroy(socket, err);
        }
      }
    };
    function errorRequest(client, request, err) {
      try {
        request.onError(err);
        assert(request.aborted);
      } catch (err2) {
        client.emit("error", err2);
      }
    }
    module2.exports = Client;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/node/fixed-queue.js"(exports2, module2) {
    "use strict";
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0)
          return null;
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    module2.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
        }
        return next;
      }
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool-stats.js"(exports2, module2) {
    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
    var kPool = Symbol("pool");
    var PoolStats = class {
      constructor(pool) {
        this[kPool] = pool;
      }
      get connected() {
        return this[kPool][kConnected];
      }
      get free() {
        return this[kPool][kFree];
      }
      get pending() {
        return this[kPool][kPending];
      }
      get queued() {
        return this[kPool][kQueued];
      }
      get running() {
        return this[kPool][kRunning];
      }
      get size() {
        return this[kPool][kSize];
      }
    };
    module2.exports = PoolStats;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool-base.js"(exports2, module2) {
    "use strict";
    var DispatcherBase = require_dispatcher_base();
    var FixedQueue = require_fixed_queue();
    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
    var PoolStats = require_pool_stats();
    var kClients = Symbol("clients");
    var kNeedDrain = Symbol("needDrain");
    var kQueue = Symbol("queue");
    var kClosedResolve = Symbol("closed resolve");
    var kOnDrain = Symbol("onDrain");
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kGetDispatcher = Symbol("get dispatcher");
    var kAddClient = Symbol("add client");
    var kRemoveClient = Symbol("remove client");
    var kStats = Symbol("stats");
    var PoolBase = class extends DispatcherBase {
      constructor() {
        super();
        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;
        const pool = this;
        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool[kQueue];
          let needDrain = false;
          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain;
          if (!this[kNeedDrain] && pool[kNeedDrain]) {
            pool[kNeedDrain] = false;
            pool.emit("drain", origin, [pool, ...targets]);
          }
          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c3) => c3.close())).then(pool[kClosedResolve]);
          }
        };
        this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit("disconnect", origin, [pool, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit("connectionError", origin, [pool, ...targets], err);
        };
        this[kStats] = new PoolStats(this);
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size } of this[kClients]) {
          ret += size;
        }
        return ret;
      }
      get stats() {
        return this[kStats];
      }
      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          return Promise.all(this[kClients].map((c3) => c3.close()));
        } else {
          return new Promise((resolve2) => {
            this[kClosedResolve] = resolve2;
          });
        }
      }
      async [kDestroy](err) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }
        return Promise.all(this[kClients].map((c3) => c3.destroy(err)));
      }
      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();
        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }
        return !this[kNeedDrain];
      }
      [kAddClient](client) {
        client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].push(client);
        if (this[kNeedDrain]) {
          process.nextTick(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }
        return this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          const idx = this[kClients].indexOf(client);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        });
        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
      }
    };
    module2.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool.js
var require_pool = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/pool.js"(exports2, module2) {
    "use strict";
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kGetDispatcher
    } = require_pool_base();
    var Client = require_client();
    var {
      InvalidArgumentError
    } = require_errors();
    var util = require_util();
    var { kUrl, kInterceptors } = require_symbols();
    var buildConnector = require_connect();
    var kOptions = Symbol("options");
    var kConnections = Symbol("connections");
    var kFactory = Symbol("factory");
    function defaultFactory(origin, opts) {
      return new Client(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, {
        connections,
        factory = defaultFactory,
        connect,
        connectTimeout,
        tls,
        maxCachedSessions,
        socketPath,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        allowH2,
        ...options
      } = {}) {
        super();
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError("invalid connections");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (typeof connect !== "function") {
          connect = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect
          });
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
        this[kConnections] = connections || null;
        this[kUrl] = util.parseOrigin(origin);
        this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kFactory] = factory;
        this.on("connectionError", (origin2, targets, error2) => {
          for (const target of targets) {
            const idx = this[kClients].indexOf(target);
            if (idx !== -1) {
              this[kClients].splice(idx, 1);
            }
          }
        });
      }
      [kGetDispatcher]() {
        let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
        if (dispatcher) {
          return dispatcher;
        }
        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
        }
        return dispatcher;
      }
    };
    module2.exports = Pool;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/balanced-pool.js"(exports2, module2) {
    "use strict";
    var {
      BalancedPoolMissingUpstreamError,
      InvalidArgumentError
    } = require_errors();
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    } = require_pool_base();
    var Pool = require_pool();
    var { kUrl, kInterceptors } = require_symbols();
    var { parseOrigin } = require_util();
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
    var kCurrentWeight = Symbol("kCurrentWeight");
    var kIndex = Symbol("kIndex");
    var kWeight = Symbol("kWeight");
    var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
    var kErrorPenalty = Symbol("kErrorPenalty");
    function getGreatestCommonDivisor(a, b3) {
      if (b3 === 0) return a;
      return getGreatestCommonDivisor(b3, a % b3);
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        super();
        this[kOptions] = opts;
        this[kIndex] = -1;
        this[kCurrentWeight] = 0;
        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
        this[kFactory] = factory;
        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
        this._updateBalancedPoolStats();
      }
      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
          return this;
        }
        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
        this[kAddClient](pool);
        pool.on("connect", () => {
          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
        });
        pool.on("connectionError", () => {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        });
        pool.on("disconnect", (...args) => {
          const err = args[2];
          if (err && err.code === "UND_ERR_SOCKET") {
            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          }
        });
        for (const client of this[kClients]) {
          client[kWeight] = this[kMaxWeightPerServer];
        }
        this._updateBalancedPoolStats();
        return this;
      }
      _updateBalancedPoolStats() {
        this[kGreatestCommonDivisor] = this[kClients].map((p3) => p3[kWeight]).reduce(getGreatestCommonDivisor, 0);
      }
      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
        if (pool) {
          this[kRemoveClient](pool);
        }
        return this;
      }
      get upstreams() {
        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p3) => p3[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }
        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
        if (!dispatcher) {
          return;
        }
        const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b3) => a && b3, true);
        if (allClientsBusy) {
          return;
        }
        let counter = 0;
        let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
        while (counter++ < this[kClients].length) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          const pool = this[kClients][this[kIndex]];
          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
            maxWeightIndex = this[kIndex];
          }
          if (this[kIndex] === 0) {
            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
            if (this[kCurrentWeight] <= 0) {
              this[kCurrentWeight] = this[kMaxWeightPerServer];
            }
          }
          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
            return pool;
          }
        }
        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
        this[kIndex] = maxWeightIndex;
        return this[kClients][maxWeightIndex];
      }
    };
    module2.exports = BalancedPool;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/compat/dispatcher-weakref.js"(exports2, module2) {
    "use strict";
    var { kConnected, kSize } = require_symbols();
    var CompatWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
      }
    };
    var CompatFinalizer = class {
      constructor(finalizer) {
        this.finalizer = finalizer;
      }
      register(dispatcher, key) {
        if (dispatcher.on) {
          dispatcher.on("disconnect", () => {
            if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
              this.finalizer(key);
            }
          });
        }
      }
    };
    module2.exports = function() {
      if (process.env.NODE_V8_COVERAGE) {
        return {
          WeakRef: CompatWeakRef,
          FinalizationRegistry: CompatFinalizer
        };
      }
      return {
        WeakRef: global.WeakRef || CompatWeakRef,
        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
      };
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/agent.js
var require_agent = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/agent.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError } = require_errors();
    var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
    var DispatcherBase = require_dispatcher_base();
    var Pool = require_pool();
    var Client = require_client();
    var util = require_util();
    var createRedirectInterceptor = require_redirectInterceptor();
    var { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()();
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kMaxRedirections = Symbol("maxRedirections");
    var kOnDrain = Symbol("onDrain");
    var kFactory = Symbol("factory");
    var kFinalizer = Symbol("finalizer");
    var kOptions = Symbol("options");
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
    }
    var Agent = class extends DispatcherBase {
      constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
        super();
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (connect && typeof connect !== "function") {
          connect = { ...connect };
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
        this[kOptions] = { ...util.deepClone(options), connect };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kMaxRedirections] = maxRedirections;
        this[kFactory] = factory;
        this[kClients] = /* @__PURE__ */ new Map();
        this[kFinalizer] = new FinalizationRegistry(
          /* istanbul ignore next: gc is undeterministic */
          (key) => {
            const ref = this[kClients].get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this[kClients].delete(key);
            }
          }
        );
        const agent = this;
        this[kOnDrain] = (origin, targets) => {
          agent.emit("drain", origin, [agent, ...targets]);
        };
        this[kOnConnect] = (origin, targets) => {
          agent.emit("connect", origin, [agent, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          agent.emit("disconnect", origin, [agent, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          agent.emit("connectionError", origin, [agent, ...targets], err);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            ret += client[kRunning];
          }
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
        }
        const ref = this[kClients].get(key);
        let dispatcher = ref ? ref.deref() : null;
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
          this[kClients].set(key, new WeakRef2(dispatcher));
          this[kFinalizer].register(dispatcher, key);
        }
        return dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        const closePromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            closePromises.push(client.close());
          }
        }
        await Promise.all(closePromises);
      }
      async [kDestroy](err) {
        const destroyPromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            destroyPromises.push(client.destroy(err));
          }
        }
        await Promise.all(destroyPromises);
      }
    };
    module2.exports = Agent;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/readable.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { Readable } = require("stream");
    var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors();
    var util = require_util();
    var { ReadableStreamFrom, toUSVString } = require_util();
    var Blob2;
    var kConsume = Symbol("kConsume");
    var kReading = Symbol("kReading");
    var kBody = Symbol("kBody");
    var kAbort = Symbol("abort");
    var kContentType = Symbol("kContentType");
    var noop = () => {
    };
    module2.exports = class BodyReadable extends Readable {
      constructor({
        resume,
        abort,
        contentType = "",
        highWaterMark = 64 * 1024
        // Same as nodejs fs streams.
      }) {
        super({
          autoDestroy: true,
          read: resume,
          highWaterMark
        });
        this._readableState.dataEmitted = false;
        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBody] = null;
        this[kContentType] = contentType;
        this[kReading] = false;
      }
      destroy(err) {
        if (this.destroyed) {
          return this;
        }
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        if (err) {
          this[kAbort]();
        }
        return super.destroy(err);
      }
      emit(ev, ...args) {
        if (ev === "data") {
          this._readableState.dataEmitted = true;
        } else if (ev === "error") {
          this._readableState.errorEmitted = true;
        }
        return super.emit(ev, ...args);
      }
      on(ev, ...args) {
        if (ev === "data" || ev === "readable") {
          this[kReading] = true;
        }
        return super.on(ev, ...args);
      }
      addListener(ev, ...args) {
        return this.on(ev, ...args);
      }
      off(ev, ...args) {
        const ret = super.off(ev, ...args);
        if (ev === "data" || ev === "readable") {
          this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
        }
        return ret;
      }
      removeListener(ev, ...args) {
        return this.off(ev, ...args);
      }
      push(chunk) {
        if (this[kConsume] && chunk !== null && this.readableLength === 0) {
          consumePush(this[kConsume], chunk);
          return this[kReading] ? super.push(chunk) : true;
        }
        return super.push(chunk);
      }
      // https://fetch.spec.whatwg.org/#dom-body-text
      async text() {
        return consume(this, "text");
      }
      // https://fetch.spec.whatwg.org/#dom-body-json
      async json() {
        return consume(this, "json");
      }
      // https://fetch.spec.whatwg.org/#dom-body-blob
      async blob() {
        return consume(this, "blob");
      }
      // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
      async arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      // https://fetch.spec.whatwg.org/#dom-body-formdata
      async formData() {
        throw new NotSupportedError();
      }
      // https://fetch.spec.whatwg.org/#dom-body-bodyused
      get bodyUsed() {
        return util.isDisturbed(this);
      }
      // https://fetch.spec.whatwg.org/#dom-body-body
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            this[kBody].getReader();
            assert(this[kBody].locked);
          }
        }
        return this[kBody];
      }
      dump(opts) {
        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
        const signal = opts && opts.signal;
        if (signal) {
          try {
            if (typeof signal !== "object" || !("aborted" in signal)) {
              throw new InvalidArgumentError("signal must be an AbortSignal");
            }
            util.throwIfAborted(signal);
          } catch (err) {
            return Promise.reject(err);
          }
        }
        if (this.closed) {
          return Promise.resolve(null);
        }
        return new Promise((resolve2, reject) => {
          const signalListenerCleanup = signal ? util.addAbortListener(signal, () => {
            this.destroy();
          }) : noop;
          this.on("close", function() {
            signalListenerCleanup();
            if (signal && signal.aborted) {
              reject(signal.reason || Object.assign(new Error("The operation was aborted"), { name: "AbortError" }));
            } else {
              resolve2(null);
            }
          }).on("error", noop).on("data", function(chunk) {
            limit -= chunk.length;
            if (limit <= 0) {
              this.destroy();
            }
          }).resume();
        });
      }
    };
    function isLocked(self2) {
      return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
    }
    function isUnusable(self2) {
      return util.isDisturbed(self2) || isLocked(self2);
    }
    async function consume(stream, type) {
      if (isUnusable(stream)) {
        throw new TypeError("unusable");
      }
      assert(!stream[kConsume]);
      return new Promise((resolve2, reject) => {
        stream[kConsume] = {
          type,
          stream,
          resolve: resolve2,
          reject,
          length: 0,
          body: []
        };
        stream.on("error", function(err) {
          consumeFinish(this[kConsume], err);
        }).on("close", function() {
          if (this[kConsume].body !== null) {
            consumeFinish(this[kConsume], new RequestAbortedError());
          }
        });
        process.nextTick(consumeStart, stream[kConsume]);
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null) {
        return;
      }
      const { _readableState: state } = consume2.stream;
      for (const chunk of state.buffer) {
        consumePush(consume2, chunk);
      }
      if (state.endEmitted) {
        consumeEnd(this[kConsume]);
      } else {
        consume2.stream.on("end", function() {
          consumeEnd(this[kConsume]);
        });
      }
      consume2.stream.resume();
      while (consume2.stream.read() != null) {
      }
    }
    function consumeEnd(consume2) {
      const { type, body, resolve: resolve2, stream, length } = consume2;
      try {
        if (type === "text") {
          resolve2(toUSVString(Buffer.concat(body)));
        } else if (type === "json") {
          resolve2(JSON.parse(Buffer.concat(body)));
        } else if (type === "arrayBuffer") {
          const dst = new Uint8Array(length);
          let pos = 0;
          for (const buf of body) {
            dst.set(buf, pos);
            pos += buf.byteLength;
          }
          resolve2(dst.buffer);
        } else if (type === "blob") {
          if (!Blob2) {
            Blob2 = require("buffer").Blob;
          }
          resolve2(new Blob2(body, { type: stream[kContentType] }));
        }
        consumeFinish(consume2);
      } catch (err) {
        stream.destroy(err);
      }
    }
    function consumePush(consume2, chunk) {
      consume2.length += chunk.length;
      consume2.body.push(chunk);
    }
    function consumeFinish(consume2, err) {
      if (consume2.body === null) {
        return;
      }
      if (err) {
        consume2.reject(err);
      } else {
        consume2.resolve();
      }
      consume2.type = null;
      consume2.stream = null;
      consume2.resolve = null;
      consume2.reject = null;
      consume2.length = 0;
      consume2.body = null;
    }
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/util.js
var require_util3 = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/util.js"(exports2, module2) {
    var assert = require("assert");
    var {
      ResponseStatusCodeError
    } = require_errors();
    var { toUSVString } = require_util();
    async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
      assert(body);
      let chunks = [];
      let limit = 0;
      for await (const chunk of body) {
        chunks.push(chunk);
        limit += chunk.length;
        if (limit > 128 * 1024) {
          chunks = null;
          break;
        }
      }
      if (statusCode === 204 || !contentType || !chunks) {
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
        return;
      }
      try {
        if (contentType.startsWith("application/json")) {
          const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
        if (contentType.startsWith("text/")) {
          const payload = toUSVString(Buffer.concat(chunks));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
      } catch (err) {
      }
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
    }
    module2.exports = { getResolveErrorBodyCallback };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/abort-signal.js"(exports2, module2) {
    var { addAbortListener } = require_util();
    var { RequestAbortedError } = require_errors();
    var kListener = Symbol("kListener");
    var kSignal = Symbol("kSignal");
    function abort(self2) {
      if (self2.abort) {
        self2.abort();
      } else {
        self2.onError(new RequestAbortedError());
      }
    }
    function addSignal(self2, signal) {
      self2[kSignal] = null;
      self2[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self2);
        return;
      }
      self2[kSignal] = signal;
      self2[kListener] = () => {
        abort(self2);
      };
      addAbortListener(self2[kSignal], self2[kListener]);
    }
    function removeSignal(self2) {
      if (!self2[kSignal]) {
        return;
      }
      if ("removeEventListener" in self2[kSignal]) {
        self2[kSignal].removeEventListener("abort", self2[kListener]);
      } else {
        self2[kSignal].removeListener("abort", self2[kListener]);
      }
      self2[kSignal] = null;
      self2[kListener] = null;
    }
    module2.exports = {
      addSignal,
      removeSignal
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-request.js"(exports2, module2) {
    "use strict";
    var Readable = require_readable();
    var {
      InvalidArgumentError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { getResolveErrorBodyCallback } = require_util3();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var RequestHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
            throw new InvalidArgumentError("invalid highWaterMark");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_REQUEST");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError;
        this.highWaterMark = highWaterMark;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        const body = new Readable({ resume, abort, contentType, highWaterMark });
        this.callback = null;
        this.res = body;
        if (callback !== null) {
          if (this.throwOnError && statusCode >= 400) {
            this.runInAsyncScope(
              getResolveErrorBodyCallback,
              null,
              { callback, body, contentType, statusCode, statusMessage, headers }
            );
          } else {
            this.runInAsyncScope(callback, null, null, {
              statusCode,
              headers,
              trailers: this.trailers,
              opaque,
              body,
              context
            });
          }
        }
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        util.parseHeaders(trailers, this.trailers);
        res.push(null);
      }
      onError(err) {
        const { res, callback, body, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (res) {
          this.res = null;
          queueMicrotask(() => {
            util.destroy(res, err);
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function request(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve2, reject) => {
          request.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve2(data);
          });
        });
      }
      try {
        this.dispatch(opts, new RequestHandler(opts, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = request;
    module2.exports.RequestHandler = RequestHandler;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-stream.js"(exports2, module2) {
    "use strict";
    var { finished, PassThrough } = require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { getResolveErrorBodyCallback } = require_util3();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var StreamHandler = class extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_STREAM");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError || false;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { factory, opaque, context, callback, responseHeaders } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.factory = null;
        let res;
        if (this.throwOnError && statusCode >= 400) {
          const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
          const contentType = parsedHeaders["content-type"];
          res = new PassThrough();
          this.callback = null;
          this.runInAsyncScope(
            getResolveErrorBodyCallback,
            null,
            { callback, body: res, contentType, statusCode, statusMessage, headers }
          );
        } else {
          if (factory === null) {
            return;
          }
          res = this.runInAsyncScope(factory, null, {
            statusCode,
            headers,
            opaque,
            context
          });
          if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
            throw new InvalidReturnValueError("expected Writable");
          }
          finished(res, { readable: false }, (err) => {
            const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
            this.res = null;
            if (err || !res2.readable) {
              util.destroy(res2, err);
            }
            this.callback = null;
            this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
            if (err) {
              abort();
            }
          });
        }
        res.on("drain", resume);
        this.res = res;
        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
        return needDrain !== true;
      }
      onData(chunk) {
        const { res } = this;
        return res ? res.write(chunk) : true;
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        if (!res) {
          return;
        }
        this.trailers = util.parseHeaders(trailers);
        res.end();
      }
      onError(err) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function stream(opts, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve2, reject) => {
          stream.call(this, opts, factory, (err, data) => {
            return err ? reject(err) : resolve2(data);
          });
        });
      }
      try {
        this.dispatch(opts, new StreamHandler(opts, factory, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = stream;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-pipeline.js"(exports2, module2) {
    "use strict";
    var {
      Readable,
      Duplex,
      PassThrough
    } = require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require("assert");
    var kResume = Symbol("resume");
    var PipelineRequest = class extends Readable {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume } = this;
        if (resume) {
          this[kResume] = null;
          resume();
        }
      }
      _destroy(err, callback) {
        this._read();
        callback(err);
      }
    };
    var PipelineResponse = class extends Readable {
      constructor(resume) {
        super({ autoDestroy: true });
        this[kResume] = resume;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        callback(err);
      }
    };
    var PipelineHandler = class extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }
        const { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_PIPELINE");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;
        this.req = new PipelineRequest().on("error", util.nop);
        this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body && body.resume) {
              body.resume();
            }
          },
          write: (chunk, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (abort && err) {
              abort();
            }
            util.destroy(body, err);
            util.destroy(req, err);
            util.destroy(res, err);
            removeSignal(this);
            callback(err);
          }
        }).on("prefinish", () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        const { ret, res } = this;
        assert(!res, "pipeline cannot be retried");
        if (ret.destroyed) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume) {
        const { opaque, handler, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume);
        let body;
        try {
          this.handler = null;
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context
          });
        } catch (err) {
          this.res.on("error", util.nop);
          throw err;
        }
        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }
        body.on("data", (chunk) => {
          const { ret, body: body2 } = this;
          if (!ret.push(chunk) && body2.pause) {
            body2.pause();
          }
        }).on("error", (err) => {
          const { ret } = this;
          util.destroy(ret, err);
        }).on("end", () => {
          const { ret } = this;
          ret.push(null);
        }).on("close", () => {
          const { ret } = this;
          if (!ret._readableState.ended) {
            util.destroy(ret, new RequestAbortedError());
          }
        });
        this.body = body;
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err) {
        const { ret } = this;
        this.handler = null;
        util.destroy(ret, err);
      }
    };
    function pipeline(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }
    module2.exports = pipeline;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-upgrade.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var { AsyncResource } = require("async_hooks");
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require("assert");
    var UpgradeHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        assert.strictEqual(statusCode, 101);
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve2, reject) => {
          upgrade.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve2(data);
          });
        });
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        this.dispatch({
          ...opts,
          method: opts.method || "GET",
          upgrade: opts.protocol || "Websocket"
        }, upgradeHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = upgrade;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/api-connect.js"(exports2, module2) {
    "use strict";
    var { AsyncResource } = require("async_hooks");
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        removeSignal(this);
        this.callback = null;
        let headers = rawHeaders;
        if (headers != null) {
          headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        }
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function connect(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve2, reject) => {
          connect.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve2(data);
          });
        });
      }
      try {
        const connectHandler = new ConnectHandler(opts, callback);
        this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = connect;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/index.js
var require_api = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/api/index.js"(exports2, module2) {
    "use strict";
    module2.exports.request = require_api_request();
    module2.exports.stream = require_api_stream();
    module2.exports.pipeline = require_api_pipeline();
    module2.exports.upgrade = require_api_upgrade();
    module2.exports.connect = require_api_connect();
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-errors.js"(exports2, module2) {
    "use strict";
    var { UndiciError } = require_errors();
    var MockNotMatchedError = class _MockNotMatchedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _MockNotMatchedError);
        this.name = "MockNotMatchedError";
        this.message = message || "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    };
    module2.exports = {
      MockNotMatchedError
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kAgent: Symbol("agent"),
      kOptions: Symbol("options"),
      kFactory: Symbol("factory"),
      kDispatches: Symbol("dispatches"),
      kDispatchKey: Symbol("dispatch key"),
      kDefaultHeaders: Symbol("default headers"),
      kDefaultTrailers: Symbol("default trailers"),
      kContentLength: Symbol("content length"),
      kMockAgent: Symbol("mock agent"),
      kMockAgentSet: Symbol("mock agent set"),
      kMockAgentGet: Symbol("mock agent get"),
      kMockDispatch: Symbol("mock dispatch"),
      kClose: Symbol("close"),
      kOriginalClose: Symbol("original agent close"),
      kOrigin: Symbol("origin"),
      kIsMockActive: Symbol("is mock active"),
      kNetConnect: Symbol("net connect"),
      kGetNetConnect: Symbol("get net connect"),
      kConnected: Symbol("connected")
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-utils.js"(exports2, module2) {
    "use strict";
    var { MockNotMatchedError } = require_mock_errors();
    var {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kGetNetConnect
    } = require_mock_symbols();
    var { buildURL, nop } = require_util();
    var { STATUS_CODES } = require("http");
    var {
      types: {
        isPromise
      }
    } = require("util");
    function matchValue(match, value) {
      if (typeof match === "string") {
        return match === value;
      }
      if (match instanceof RegExp) {
        return match.test(value);
      }
      if (typeof match === "function") {
        return match(value) === true;
      }
      return false;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => {
          return [headerName.toLocaleLowerCase(), headerValue];
        })
      );
    }
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i3 = 0; i3 < headers.length; i3 += 2) {
          if (headers[i3].toLocaleLowerCase() === key.toLocaleLowerCase()) {
            return headers[i3 + 1];
          }
        }
        return void 0;
      } else if (typeof headers.get === "function") {
        return headers.get(key);
      } else {
        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
      }
    }
    function buildHeadersFromArray(headers) {
      const clone = headers.slice();
      const entries = [];
      for (let index = 0; index < clone.length; index += 2) {
        entries.push([clone[index], clone[index + 1]]);
      }
      return Object.fromEntries(entries);
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers === "function") {
        if (Array.isArray(headers)) {
          headers = buildHeadersFromArray(headers);
        }
        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch2.headers === "undefined") {
        return true;
      }
      if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
        return false;
      }
      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
        const headerValue = getHeaderByName(headers, matchHeaderName);
        if (!matchValue(matchHeaderValue, headerValue)) {
          return false;
        }
      }
      return true;
    }
    function safeUrl(path2) {
      if (typeof path2 !== "string") {
        return path2;
      }
      const pathSegments = path2.split("?");
      if (pathSegments.length !== 2) {
        return path2;
      }
      const qp = new URLSearchParams(pathSegments.pop());
      qp.sort();
      return [...pathSegments, qp.toString()].join("?");
    }
    function matchKey(mockDispatch2, { path: path2, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch2.path, path2);
      const methodMatch = matchValue(mockDispatch2.method, method);
      const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
      const headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (typeof data === "object") {
        return JSON.stringify(data);
      } else {
        return data.toString();
      }
    }
    function getMockDispatch(mockDispatches, key) {
      const basePath = key.query ? buildURL(key.path, key.query) : key.path;
      const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path2 }) => matchValue(safeUrl(path2), resolvedPath));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
      }
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data) {
      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
      const replyData = typeof data === "function" ? { callback: data } : { ...data };
      const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }
    function buildKey(opts) {
      const { path: path2, method, body, headers, query } = opts;
      return {
        path: path2,
        method,
        body,
        headers,
        query
      };
    }
    function generateKeyValues(data) {
      return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
        ...keyValuePairs,
        Buffer.from(`${key}`),
        Array.isArray(value) ? value.map((x3) => Buffer.from(`${x3}`)) : Buffer.from(`${value}`)
      ], []);
    }
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || "unknown";
    }
    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString("utf8");
    }
    function mockDispatch(opts, handler) {
      const key = buildKey(opts);
      const mockDispatch2 = getMockDispatch(this[kDispatches], key);
      mockDispatch2.timesInvoked++;
      if (mockDispatch2.data.callback) {
        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
      }
      const { data: { statusCode, data, headers, trailers, error: error2 }, delay, persist } = mockDispatch2;
      const { timesInvoked, times } = mockDispatch2;
      mockDispatch2.consumed = !persist && timesInvoked >= times;
      mockDispatch2.pending = timesInvoked < times;
      if (error2 !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error2);
        return true;
      }
      if (typeof delay === "number" && delay > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay);
      } else {
        handleReply(this[kDispatches]);
      }
      function handleReply(mockDispatches, _data = data) {
        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
        const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
        if (isPromise(body)) {
          body.then((newData) => handleReply(mockDispatches, newData));
          return;
        }
        const responseData = getResponseData(body);
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);
        handler.abort = nop;
        handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
        handler.onData(Buffer.from(responseData));
        handler.onComplete(responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }
      function resume() {
      }
      return true;
    }
    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];
      return function dispatch(opts, handler) {
        if (agent.isMockActive) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error2) {
            if (error2 instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
              }
            } else {
              throw error2;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }
    function checkNetConnect(netConnect, origin) {
      const url = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
        return true;
      }
      return false;
    }
    function buildMockOptions(opts) {
      if (opts) {
        const { agent, ...mockOptions } = opts;
        return mockOptions;
      }
    }
    module2.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildMockOptions,
      getHeaderByName
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-interceptor.js"(exports2, module2) {
    "use strict";
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch
    } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors();
    var { buildURL } = require_util();
    var MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      /**
       * Delay a reply by a set amount in ms.
       */
      delay(waitInMs) {
        if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
          throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        }
        this[kMockDispatch].delay = waitInMs;
        return this;
      }
      /**
       * For a defined reply, never mark as consumed.
       */
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }
      /**
       * Allow one to define a reply for a set amount of matching requests.
       */
      times(repeatTimes) {
        if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
          throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        }
        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    };
    var MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object");
        }
        if (typeof opts.path === "undefined") {
          throw new InvalidArgumentError("opts.path must be defined");
        }
        if (typeof opts.method === "undefined") {
          opts.method = "GET";
        }
        if (typeof opts.path === "string") {
          if (opts.query) {
            opts.path = buildURL(opts.path, opts.query);
          } else {
            const parsedURL = new URL(opts.path, "data://");
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        }
        if (typeof opts.method === "string") {
          opts.method = opts.method.toUpperCase();
        }
        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }
      createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(statusCode, data, responseOptions) {
        if (typeof statusCode === "undefined") {
          throw new InvalidArgumentError("statusCode must be defined");
        }
        if (typeof data === "undefined") {
          throw new InvalidArgumentError("data must be defined");
        }
        if (typeof responseOptions !== "object") {
          throw new InvalidArgumentError("responseOptions must be an object");
        }
      }
      /**
       * Mock an undici request with a defined reply.
       */
      reply(replyData) {
        if (typeof replyData === "function") {
          const wrappedDefaultsCallback = (opts) => {
            const resolvedData = replyData(opts);
            if (typeof resolvedData !== "object") {
              throw new InvalidArgumentError("reply options callback must return an object");
            }
            const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
            this.validateReplyParameters(statusCode2, data2, responseOptions2);
            return {
              ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
            };
          };
          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
          return new MockScope(newMockDispatch2);
        }
        const [statusCode, data = "", responseOptions = {}] = [...arguments];
        this.validateReplyParameters(statusCode, data, responseOptions);
        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
        return new MockScope(newMockDispatch);
      }
      /**
       * Mock an undici request with a defined error.
       */
      replyWithError(error2) {
        if (typeof error2 === "undefined") {
          throw new InvalidArgumentError("error must be defined");
        }
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error: error2 });
        return new MockScope(newMockDispatch);
      }
      /**
       * Set default reply headers on the interceptor for subsequent replies
       */
      defaultReplyHeaders(headers) {
        if (typeof headers === "undefined") {
          throw new InvalidArgumentError("headers must be defined");
        }
        this[kDefaultHeaders] = headers;
        return this;
      }
      /**
       * Set default reply trailers on the interceptor for subsequent replies
       */
      defaultReplyTrailers(trailers) {
        if (typeof trailers === "undefined") {
          throw new InvalidArgumentError("trailers must be defined");
        }
        this[kDefaultTrailers] = trailers;
        return this;
      }
      /**
       * Set reply content length header for replies on the interceptor
       */
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    };
    module2.exports.MockInterceptor = MockInterceptor;
    module2.exports.MockScope = MockScope;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-client.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("util");
    var Client = require_client();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockClient = class extends Client {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockClient;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-pool.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("util");
    var Pool = require_pool();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockPool = class extends Pool {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockPool;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/pluralizer.js"(exports2, module2) {
    "use strict";
    var singulars = {
      pronoun: "it",
      is: "is",
      was: "was",
      this: "this"
    };
    var plurals = {
      pronoun: "they",
      is: "are",
      was: "were",
      this: "these"
    };
    module2.exports = class Pluralizer {
      constructor(singular, plural) {
        this.singular = singular;
        this.plural = plural;
      }
      pluralize(count) {
        const one = count === 1;
        const keys = one ? singulars : plurals;
        const noun = one ? this.singular : this.plural;
        return { ...keys, count, noun };
      }
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports2, module2) {
    "use strict";
    var { Transform } = require("stream");
    var { Console } = require("console");
    module2.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk, _enc, cb) {
            cb(null, chunk);
          }
        });
        this.logger = new Console({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI
          }
        });
      }
      format(pendingInterceptors) {
        const withPrettyHeaders = pendingInterceptors.map(
          ({ method, path: path2, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
            Method: method,
            Origin: origin,
            Path: path2,
            "Status code": statusCode,
            Persistent: persist ? "\u2705" : "\u274C",
            Invocations: timesInvoked,
            Remaining: persist ? Infinity : times - timesInvoked
          })
        );
        this.logger.table(withPrettyHeaders);
        return this.transform.read().toString();
      }
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/mock/mock-agent.js"(exports2, module2) {
    "use strict";
    var { kClients } = require_symbols();
    var Agent = require_agent();
    var {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory
    } = require_mock_symbols();
    var MockClient = require_mock_client();
    var MockPool = require_mock_pool();
    var { matchValue, buildMockOptions } = require_mock_utils();
    var { InvalidArgumentError, UndiciError } = require_errors();
    var Dispatcher = require_dispatcher();
    var Pluralizer = require_pluralizer();
    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
    var FakeWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value;
      }
    };
    var MockAgent = class extends Dispatcher {
      constructor(opts) {
        super(opts);
        this[kNetConnect] = true;
        this[kIsMockActive] = true;
        if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        const agent = opts && opts.agent ? opts.agent : new Agent(opts);
        this[kAgent] = agent;
        this[kClients] = agent[kClients];
        this[kOptions] = buildMockOptions(opts);
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        if (!dispatcher) {
          dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
        }
        return dispatcher;
      }
      dispatch(opts, handler) {
        this.get(opts.origin);
        return this[kAgent].dispatch(opts, handler);
      }
      async close() {
        await this[kAgent].close();
        this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = false;
      }
      activate() {
        this[kIsMockActive] = true;
      }
      enableNetConnect(matcher) {
        if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === "undefined") {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
      }
      disableNetConnect() {
        this[kNetConnect] = false;
      }
      // This is required to bypass issues caused by using global symbols - see:
      // https://github.com/nodejs/undici/issues/1447
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, new FakeWeakRef(dispatcher));
      }
      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        const ref = this[kClients].get(origin);
        if (ref) {
          return ref.deref();
        }
        if (typeof origin !== "string") {
          const dispatcher = this[kFactory]("http://localhost:9999");
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }
        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
          const nonExplicitDispatcher = nonExplicitRef.deref();
          if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
            return dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        const mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
        const pending = this.pendingInterceptors();
        if (pending.length === 0) {
          return;
        }
        const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
        throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
      }
    };
    module2.exports = MockAgent;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/proxy-agent.js"(exports2, module2) {
    "use strict";
    var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
    var { URL: URL2 } = require("url");
    var Agent = require_agent();
    var Pool = require_pool();
    var DispatcherBase = require_dispatcher_base();
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var buildConnector = require_connect();
    var kAgent = Symbol("proxy agent");
    var kClient = Symbol("proxy client");
    var kProxyHeaders = Symbol("proxy headers");
    var kRequestTls = Symbol("request tls settings");
    var kProxyTls = Symbol("proxy tls settings");
    var kConnectEndpoint = Symbol("connect endpoint function");
    function defaultProtocolPort(protocol) {
      return protocol === "https:" ? 443 : 80;
    }
    function buildProxyOptions(opts) {
      if (typeof opts === "string") {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }
      return {
        uri: opts.uri,
        protocol: opts.protocol || "https"
      };
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        super(opts);
        this[kProxy] = buildProxyOptions(opts);
        this[kAgent] = new Agent(opts);
        this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
        if (typeof opts === "string") {
          opts = { uri: opts };
        }
        if (!opts || !opts.uri) {
          throw new InvalidArgumentError("Proxy opts.uri is mandatory");
        }
        const { clientFactory = defaultFactory } = opts;
        if (typeof clientFactory !== "function") {
          throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
        }
        this[kRequestTls] = opts.requestTls;
        this[kProxyTls] = opts.proxyTls;
        this[kProxyHeaders] = opts.headers || {};
        const resolvedUrl = new URL2(opts.uri);
        const { origin, port, host, username, password } = resolvedUrl;
        if (opts.auth && opts.token) {
          throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
        } else if (opts.auth) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
        } else if (opts.token) {
          this[kProxyHeaders]["proxy-authorization"] = opts.token;
        } else if (username && password) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
        }
        const connect = buildConnector({ ...opts.proxyTls });
        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
        this[kClient] = clientFactory(resolvedUrl, { connect });
        this[kAgent] = new Agent({
          ...opts,
          connect: async (opts2, callback) => {
            let requestedHost = opts2.host;
            if (!opts2.port) {
              requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
            }
            try {
              const { socket, statusCode } = await this[kClient].connect({
                origin,
                port,
                path: requestedHost,
                signal: opts2.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host
                }
              });
              if (statusCode !== 200) {
                socket.on("error", () => {
                }).destroy();
                callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
              }
              if (opts2.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              if (this[kRequestTls]) {
                servername = this[kRequestTls].servername;
              } else {
                servername = opts2.servername;
              }
              this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
            } catch (err) {
              callback(err);
            }
          }
        });
      }
      dispatch(opts, handler) {
        const { host } = new URL2(opts.origin);
        const headers = buildHeaders(opts.headers);
        throwIfProxyAuthIsSent(headers);
        return this[kAgent].dispatch(
          {
            ...opts,
            headers: {
              ...headers,
              host
            }
          },
          handler
        );
      }
      async [kClose]() {
        await this[kAgent].close();
        await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy();
        await this[kClient].destroy();
      }
    };
    function buildHeaders(headers) {
      if (Array.isArray(headers)) {
        const headersPair = {};
        for (let i3 = 0; i3 < headers.length; i3 += 2) {
          headersPair[headers[i3]] = headers[i3 + 1];
        }
        return headersPair;
      }
      return headers;
    }
    function throwIfProxyAuthIsSent(headers) {
      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
      if (existProxyAuth) {
        throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
    }
    module2.exports = ProxyAgent;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/RetryHandler.js"(exports2, module2) {
    var assert = require("assert");
    var { kRetryHandlerDefaultRetry } = require_symbols();
    var { RequestRetryError } = require_errors();
    var { isDisturbed, parseHeaders, parseRangeHeader } = require_util();
    function calculateRetryAfterHeader(retryAfter) {
      const current = Date.now();
      const diff = new Date(retryAfter).getTime() - current;
      return diff;
    }
    var RetryHandler = class _RetryHandler {
      constructor(opts, handlers) {
        const { retryOptions, ...dispatchOpts } = opts;
        const {
          // Retry scoped
          retry: retryFn,
          maxRetries,
          maxTimeout,
          minTimeout,
          timeoutFactor,
          // Response scoped
          methods,
          errorCodes,
          retryAfter,
          statusCodes
        } = retryOptions ?? {};
        this.dispatch = handlers.dispatch;
        this.handler = handlers.handler;
        this.opts = dispatchOpts;
        this.abort = null;
        this.aborted = false;
        this.retryOpts = {
          retry: retryFn ?? _RetryHandler[kRetryHandlerDefaultRetry],
          retryAfter: retryAfter ?? true,
          maxTimeout: maxTimeout ?? 30 * 1e3,
          // 30s,
          timeout: minTimeout ?? 500,
          // .5s
          timeoutFactor: timeoutFactor ?? 2,
          maxRetries: maxRetries ?? 5,
          // What errors we should retry
          methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
          // Indicates which errors to retry
          statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
          // List of errors to retry
          errorCodes: errorCodes ?? [
            "ECONNRESET",
            "ECONNREFUSED",
            "ENOTFOUND",
            "ENETDOWN",
            "ENETUNREACH",
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "EPIPE"
          ]
        };
        this.retryCount = 0;
        this.start = 0;
        this.end = null;
        this.etag = null;
        this.resume = null;
        this.handler.onConnect((reason) => {
          this.aborted = true;
          if (this.abort) {
            this.abort(reason);
          } else {
            this.reason = reason;
          }
        });
      }
      onRequestSent() {
        if (this.handler.onRequestSent) {
          this.handler.onRequestSent();
        }
      }
      onUpgrade(statusCode, headers, socket) {
        if (this.handler.onUpgrade) {
          this.handler.onUpgrade(statusCode, headers, socket);
        }
      }
      onConnect(abort) {
        if (this.aborted) {
          abort(this.reason);
        } else {
          this.abort = abort;
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
      }
      static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
        const { statusCode, code, headers } = err;
        const { method, retryOptions } = opts;
        const {
          maxRetries,
          timeout,
          maxTimeout,
          timeoutFactor,
          statusCodes,
          errorCodes,
          methods
        } = retryOptions;
        let { counter, currentTimeout } = state;
        currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;
        if (code && code !== "UND_ERR_REQ_RETRY" && code !== "UND_ERR_SOCKET" && !errorCodes.includes(code)) {
          cb(err);
          return;
        }
        if (Array.isArray(methods) && !methods.includes(method)) {
          cb(err);
          return;
        }
        if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
          cb(err);
          return;
        }
        if (counter > maxRetries) {
          cb(err);
          return;
        }
        let retryAfterHeader = headers != null && headers["retry-after"];
        if (retryAfterHeader) {
          retryAfterHeader = Number(retryAfterHeader);
          retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
        }
        const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
        state.currentTimeout = retryTimeout;
        setTimeout(() => cb(null), retryTimeout);
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const headers = parseHeaders(rawHeaders);
        this.retryCount += 1;
        if (statusCode >= 300) {
          this.abort(
            new RequestRetryError("Request failed", statusCode, {
              headers,
              count: this.retryCount
            })
          );
          return false;
        }
        if (this.resume != null) {
          this.resume = null;
          if (statusCode !== 206) {
            return true;
          }
          const contentRange = parseRangeHeader(headers["content-range"]);
          if (!contentRange) {
            this.abort(
              new RequestRetryError("Content-Range mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            );
            return false;
          }
          if (this.etag != null && this.etag !== headers.etag) {
            this.abort(
              new RequestRetryError("ETag mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            );
            return false;
          }
          const { start, size, end = size } = contentRange;
          assert(this.start === start, "content-range mismatch");
          assert(this.end == null || this.end === end, "content-range mismatch");
          this.resume = resume;
          return true;
        }
        if (this.end == null) {
          if (statusCode === 206) {
            const range = parseRangeHeader(headers["content-range"]);
            if (range == null) {
              return this.handler.onHeaders(
                statusCode,
                rawHeaders,
                resume,
                statusMessage
              );
            }
            const { start, size, end = size } = range;
            assert(
              start != null && Number.isFinite(start) && this.start !== start,
              "content-range mismatch"
            );
            assert(Number.isFinite(start));
            assert(
              end != null && Number.isFinite(end) && this.end !== end,
              "invalid content-length"
            );
            this.start = start;
            this.end = end;
          }
          if (this.end == null) {
            const contentLength = headers["content-length"];
            this.end = contentLength != null ? Number(contentLength) : null;
          }
          assert(Number.isFinite(this.start));
          assert(
            this.end == null || Number.isFinite(this.end),
            "invalid content-length"
          );
          this.resume = resume;
          this.etag = headers.etag != null ? headers.etag : null;
          return this.handler.onHeaders(
            statusCode,
            rawHeaders,
            resume,
            statusMessage
          );
        }
        const err = new RequestRetryError("Request failed", statusCode, {
          headers,
          count: this.retryCount
        });
        this.abort(err);
        return false;
      }
      onData(chunk) {
        this.start += chunk.length;
        return this.handler.onData(chunk);
      }
      onComplete(rawTrailers) {
        this.retryCount = 0;
        return this.handler.onComplete(rawTrailers);
      }
      onError(err) {
        if (this.aborted || isDisturbed(this.opts.body)) {
          return this.handler.onError(err);
        }
        this.retryOpts.retry(
          err,
          {
            state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
            opts: { retryOptions: this.retryOpts, ...this.opts }
          },
          onRetry.bind(this)
        );
        function onRetry(err2) {
          if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
            return this.handler.onError(err2);
          }
          if (this.start !== 0) {
            this.opts = {
              ...this.opts,
              headers: {
                ...this.opts.headers,
                range: `bytes=${this.start}-${this.end ?? ""}`
              }
            };
          }
          try {
            this.dispatch(this.opts, this);
          } catch (err3) {
            this.handler.onError(err3);
          }
        }
      }
    };
    module2.exports = RetryHandler;
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/global.js
var require_global2 = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/global.js"(exports2, module2) {
    "use strict";
    var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
    var { InvalidArgumentError } = require_errors();
    var Agent = require_agent();
    if (getGlobalDispatcher() === void 0) {
      setGlobalDispatcher(new Agent());
    }
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }
    module2.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/handler/DecoratorHandler.js"(exports2, module2) {
    "use strict";
    module2.exports = class DecoratorHandler {
      constructor(handler) {
        this.handler = handler;
      }
      onConnect(...args) {
        return this.handler.onConnect(...args);
      }
      onError(...args) {
        return this.handler.onError(...args);
      }
      onUpgrade(...args) {
        return this.handler.onUpgrade(...args);
      }
      onHeaders(...args) {
        return this.handler.onHeaders(...args);
      }
      onData(...args) {
        return this.handler.onData(...args);
      }
      onComplete(...args) {
        return this.handler.onComplete(...args);
      }
      onBodySent(...args) {
        return this.handler.onBodySent(...args);
      }
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/headers.js"(exports2, module2) {
    "use strict";
    var { kHeadersList, kConstruct } = require_symbols();
    var { kGuard } = require_symbols2();
    var { kEnumerableProperty } = require_util();
    var {
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue
    } = require_util2();
    var util = require("util");
    var { webidl } = require_webidl();
    var assert = require("assert");
    var kHeadersMap = Symbol("headers map");
    var kHeadersSortedMap = Symbol("headers map sorted");
    function isHTTPWhiteSpaceCharCode(code) {
      return code === 10 || code === 13 || code === 9 || code === 32;
    }
    function headerValueNormalize(potentialValue) {
      let i3 = 0;
      let j3 = potentialValue.length;
      while (j3 > i3 && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j3 - 1))) --j3;
      while (j3 > i3 && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i3))) ++i3;
      return i3 === 0 && j3 === potentialValue.length ? potentialValue : potentialValue.substring(i3, j3);
    }
    function fill(headers, object) {
      if (Array.isArray(object)) {
        for (let i3 = 0; i3 < object.length; ++i3) {
          const header = object[i3];
          if (header.length !== 2) {
            throw webidl.errors.exception({
              header: "Headers constructor",
              message: `expected name/value pair to be length 2, found ${header.length}.`
            });
          }
          appendHeader(headers, header[0], header[1]);
        }
      } else if (typeof object === "object" && object !== null) {
        const keys = Object.keys(object);
        for (let i3 = 0; i3 < keys.length; ++i3) {
          appendHeader(headers, keys[i3], object[keys[i3]]);
        }
      } else {
        throw webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
        });
      }
    }
    function appendHeader(headers, name, value) {
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value,
          type: "header value"
        });
      }
      if (headers[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (headers[kGuard] === "request-no-cors") {
      }
      return headers[kHeadersList].append(name, value);
    }
    var HeadersList = class _HeadersList {
      /** @type {[string, string][]|null} */
      cookies = null;
      constructor(init) {
        if (init instanceof _HeadersList) {
          this[kHeadersMap] = new Map(init[kHeadersMap]);
          this[kHeadersSortedMap] = init[kHeadersSortedMap];
          this.cookies = init.cookies === null ? null : [...init.cookies];
        } else {
          this[kHeadersMap] = new Map(init);
          this[kHeadersSortedMap] = null;
        }
      }
      // https://fetch.spec.whatwg.org/#header-list-contains
      contains(name) {
        name = name.toLowerCase();
        return this[kHeadersMap].has(name);
      }
      clear() {
        this[kHeadersMap].clear();
        this[kHeadersSortedMap] = null;
        this.cookies = null;
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-append
      append(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        const exists = this[kHeadersMap].get(lowercaseName);
        if (exists) {
          const delimiter = lowercaseName === "cookie" ? "; " : ", ";
          this[kHeadersMap].set(lowercaseName, {
            name: exists.name,
            value: `${exists.value}${delimiter}${value}`
          });
        } else {
          this[kHeadersMap].set(lowercaseName, { name, value });
        }
        if (lowercaseName === "set-cookie") {
          this.cookies ??= [];
          this.cookies.push(value);
        }
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-set
      set(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        if (lowercaseName === "set-cookie") {
          this.cookies = [value];
        }
        this[kHeadersMap].set(lowercaseName, { name, value });
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-delete
      delete(name) {
        this[kHeadersSortedMap] = null;
        name = name.toLowerCase();
        if (name === "set-cookie") {
          this.cookies = null;
        }
        this[kHeadersMap].delete(name);
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-get
      get(name) {
        const value = this[kHeadersMap].get(name.toLowerCase());
        return value === void 0 ? null : value.value;
      }
      *[Symbol.iterator]() {
        for (const [name, { value }] of this[kHeadersMap]) {
          yield [name, value];
        }
      }
      get entries() {
        const headers = {};
        if (this[kHeadersMap].size) {
          for (const { name, value } of this[kHeadersMap].values()) {
            headers[name] = value;
          }
        }
        return headers;
      }
    };
    var Headers = class _Headers {
      constructor(init = void 0) {
        if (init === kConstruct) {
          return;
        }
        this[kHeadersList] = new HeadersList();
        this[kGuard] = "none";
        if (init !== void 0) {
          init = webidl.converters.HeadersInit(init);
          fill(this, init);
        }
      }
      // https://fetch.spec.whatwg.org/#dom-headers-append
      append(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        return appendHeader(this, name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-delete
      delete(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.delete",
            value: name,
            type: "header name"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        if (!this[kHeadersList].contains(name)) {
          return;
        }
        this[kHeadersList].delete(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-get
      get(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.get",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].get(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-has
      has(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.has",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].contains(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-set
      set(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value,
            type: "header value"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        this[kHeadersList].set(name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
      getSetCookie() {
        webidl.brandCheck(this, _Headers);
        const list = this[kHeadersList].cookies;
        if (list) {
          return [...list];
        }
        return [];
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
      get [kHeadersSortedMap]() {
        if (this[kHeadersList][kHeadersSortedMap]) {
          return this[kHeadersList][kHeadersSortedMap];
        }
        const headers = [];
        const names = [...this[kHeadersList]].sort((a, b3) => a[0] < b3[0] ? -1 : 1);
        const cookies = this[kHeadersList].cookies;
        for (let i3 = 0; i3 < names.length; ++i3) {
          const [name, value] = names[i3];
          if (name === "set-cookie") {
            for (let j3 = 0; j3 < cookies.length; ++j3) {
              headers.push([name, cookies[j3]]);
            }
          } else {
            assert(value !== null);
            headers.push([name, value]);
          }
        }
        this[kHeadersList][kHeadersSortedMap] = headers;
        return headers;
      }
      keys() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "value"
        );
      }
      entries() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key+value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key+value"
        );
      }
      /**
       * @param {(value: string, key: string, self: Headers) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        webidl.brandCheck(this, _Headers);
        return this[kHeadersList];
      }
    };
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    Object.defineProperties(Headers.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      getSetCookie: kEnumerableProperty,
      keys: kEnumerableProperty,
      values: kEnumerableProperty,
      entries: kEnumerableProperty,
      forEach: kEnumerableProperty,
      [Symbol.iterator]: { enumerable: false },
      [Symbol.toStringTag]: {
        value: "Headers",
        configurable: true
      },
      [util.inspect.custom]: {
        enumerable: false
      }
    });
    webidl.converters.HeadersInit = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (V[Symbol.iterator]) {
          return webidl.converters["sequence<sequence<ByteString>>"](V);
        }
        return webidl.converters["record<ByteString, ByteString>"](V);
      }
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    };
    module2.exports = {
      fill,
      Headers,
      HeadersList
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/response.js
var require_response = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/response.js"(exports2, module2) {
    "use strict";
    var { Headers, HeadersList, fill } = require_headers();
    var { extractBody, cloneBody, mixinBody } = require_body();
    var util = require_util();
    var { kEnumerableProperty } = util;
    var {
      isValidReasonPhrase,
      isCancelled,
      isAborted,
      isBlobLike,
      serializeJavascriptValueToJSONString,
      isErrorLike,
      isomorphicEncode
    } = require_util2();
    var {
      redirectStatusSet,
      nullBodyStatus,
      DOMException: DOMException2
    } = require_constants2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { FormData } = require_formdata();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList, kConstruct } = require_symbols();
    var assert = require("assert");
    var { types } = require("util");
    var ReadableStream = globalThis.ReadableStream || require("stream/web").ReadableStream;
    var textEncoder = new TextEncoder("utf-8");
    var Response = class _Response {
      // Creates network error Response.
      static error() {
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kState] = makeNetworkError();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response-json
      static json(data, init = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
        if (init !== null) {
          init = webidl.converters.ResponseInit(init);
        }
        const bytes = textEncoder.encode(
          serializeJavascriptValueToJSONString(data)
        );
        const body = extractBody(bytes);
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "response";
        responseObject[kHeaders][kRealm] = relevantRealm;
        initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
        return responseObject;
      }
      // Creates a redirect Response that redirects to url with status status.
      static redirect(url, status = 302) {
        const relevantRealm = { settingsObject: {} };
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
        url = webidl.converters.USVString(url);
        status = webidl.converters["unsigned short"](status);
        let parsedURL;
        try {
          parsedURL = new URL(url, getGlobalOrigin());
        } catch (err) {
          throw Object.assign(new TypeError("Failed to parse URL from " + url), {
            cause: err
          });
        }
        if (!redirectStatusSet.has(status)) {
          throw new RangeError("Invalid status code " + status);
        }
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        responseObject[kState].status = status;
        const value = isomorphicEncode(URLSerializer(parsedURL));
        responseObject[kState].headersList.append("location", value);
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response
      constructor(body = null, init = {}) {
        if (body !== null) {
          body = webidl.converters.BodyInit(body);
        }
        init = webidl.converters.ResponseInit(init);
        this[kRealm] = { settingsObject: {} };
        this[kState] = makeResponse({});
        this[kHeaders] = new Headers(kConstruct);
        this[kHeaders][kGuard] = "response";
        this[kHeaders][kHeadersList] = this[kState].headersList;
        this[kHeaders][kRealm] = this[kRealm];
        let bodyWithType = null;
        if (body != null) {
          const [extractedBody, type] = extractBody(body);
          bodyWithType = { body: extractedBody, type };
        }
        initializeResponse(this, init, bodyWithType);
      }
      // Returns responses type, e.g., "cors".
      get type() {
        webidl.brandCheck(this, _Response);
        return this[kState].type;
      }
      // Returns responses URL, if it has one; otherwise the empty string.
      get url() {
        webidl.brandCheck(this, _Response);
        const urlList = this[kState].urlList;
        const url = urlList[urlList.length - 1] ?? null;
        if (url === null) {
          return "";
        }
        return URLSerializer(url, true);
      }
      // Returns whether response was obtained through a redirect.
      get redirected() {
        webidl.brandCheck(this, _Response);
        return this[kState].urlList.length > 1;
      }
      // Returns responses status.
      get status() {
        webidl.brandCheck(this, _Response);
        return this[kState].status;
      }
      // Returns whether responses status is an ok status.
      get ok() {
        webidl.brandCheck(this, _Response);
        return this[kState].status >= 200 && this[kState].status <= 299;
      }
      // Returns responses status message.
      get statusText() {
        webidl.brandCheck(this, _Response);
        return this[kState].statusText;
      }
      // Returns responses headers as Headers.
      get headers() {
        webidl.brandCheck(this, _Response);
        return this[kHeaders];
      }
      get body() {
        webidl.brandCheck(this, _Response);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Response);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      // Returns a clone of response.
      clone() {
        webidl.brandCheck(this, _Response);
        if (this.bodyUsed || this.body && this.body.locked) {
          throw webidl.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed."
          });
        }
        const clonedResponse = cloneResponse(this[kState]);
        const clonedResponseObject = new _Response();
        clonedResponseObject[kState] = clonedResponse;
        clonedResponseObject[kRealm] = this[kRealm];
        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        return clonedResponseObject;
      }
    };
    mixinBody(Response);
    Object.defineProperties(Response.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Response",
        configurable: true
      }
    });
    Object.defineProperties(Response, {
      json: kEnumerableProperty,
      redirect: kEnumerableProperty,
      error: kEnumerableProperty
    });
    function cloneResponse(response) {
      if (response.internalResponse) {
        return filterResponse(
          cloneResponse(response.internalResponse),
          response.type
        );
      }
      const newResponse = makeResponse({ ...response, body: null });
      if (response.body != null) {
        newResponse.body = cloneBody(response.body);
      }
      return newResponse;
    }
    function makeResponse(init) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),
        urlList: init.urlList ? [...init.urlList] : []
      };
    }
    function makeNetworkError(reason) {
      const isError = isErrorLike(reason);
      return makeResponse({
        type: "error",
        status: 0,
        error: isError ? reason : new Error(reason ? String(reason) : reason),
        aborted: reason && reason.name === "AbortError"
      });
    }
    function makeFilteredResponse(response, state) {
      state = {
        internalResponse: response,
        ...state
      };
      return new Proxy(response, {
        get(target, p3) {
          return p3 in state ? state[p3] : target[p3];
        },
        set(target, p3, value) {
          assert(!(p3 in state));
          target[p3] = value;
          return true;
        }
      });
    }
    function filterResponse(response, type) {
      if (type === "basic") {
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: response.headersList
        });
      } else if (type === "cors") {
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: response.headersList
        });
      } else if (type === "opaque") {
        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null
        });
      } else if (type === "opaqueredirect") {
        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: [],
          body: null
        });
      } else {
        assert(false);
      }
    }
    function makeAppropriateNetworkError(fetchParams, err = null) {
      assert(isCancelled(fetchParams));
      return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException2("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException2("Request was cancelled."), { cause: err }));
    }
    function initializeResponse(response, init, body) {
      if (init.status !== null && (init.status < 200 || init.status > 599)) {
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      }
      if ("statusText" in init && init.statusText != null) {
        if (!isValidReasonPhrase(String(init.statusText))) {
          throw new TypeError("Invalid statusText");
        }
      }
      if ("status" in init && init.status != null) {
        response[kState].status = init.status;
      }
      if ("statusText" in init && init.statusText != null) {
        response[kState].statusText = init.statusText;
      }
      if ("headers" in init && init.headers != null) {
        fill(response[kHeaders], init.headers);
      }
      if (body) {
        if (nullBodyStatus.includes(response.status)) {
          throw webidl.errors.exception({
            header: "Response constructor",
            message: "Invalid response status code " + response.status
          });
        }
        response[kState].body = body.body;
        if (body.type != null && !response[kState].headersList.contains("Content-Type")) {
          response[kState].headersList.append("content-type", body.type);
        }
      }
    }
    webidl.converters.ReadableStream = webidl.interfaceConverter(
      ReadableStream
    );
    webidl.converters.FormData = webidl.interfaceConverter(
      FormData
    );
    webidl.converters.URLSearchParams = webidl.interfaceConverter(
      URLSearchParams
    );
    webidl.converters.XMLHttpRequestBodyInit = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
        return webidl.converters.BufferSource(V);
      }
      if (util.isFormDataLike(V)) {
        return webidl.converters.FormData(V, { strict: false });
      }
      if (V instanceof URLSearchParams) {
        return webidl.converters.URLSearchParams(V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.BodyInit = function(V) {
      if (V instanceof ReadableStream) {
        return webidl.converters.ReadableStream(V);
      }
      if (V?.[Symbol.asyncIterator]) {
        return V;
      }
      return webidl.converters.XMLHttpRequestBodyInit(V);
    };
    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: "status",
        converter: webidl.converters["unsigned short"],
        defaultValue: 200
      },
      {
        key: "statusText",
        converter: webidl.converters.ByteString,
        defaultValue: ""
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      }
    ]);
    module2.exports = {
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response,
      cloneResponse
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/request.js"(exports2, module2) {
    "use strict";
    var { extractBody, mixinBody, cloneBody } = require_body();
    var { Headers, fill: fillHeaders, HeadersList } = require_headers();
    var { FinalizationRegistry } = require_dispatcher_weakref()();
    var util = require_util();
    var {
      isValidHTTPToken,
      sameOrigin,
      normalizeMethod,
      makePolicyContainer,
      normalizeMethodRecord
    } = require_util2();
    var {
      forbiddenMethodsSet,
      corsSafeListedMethodsSet,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      requestDuplex
    } = require_constants2();
    var { kEnumerableProperty } = util;
    var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList, kConstruct } = require_symbols();
    var assert = require("assert");
    var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = require("events");
    var TransformStream = globalThis.TransformStream;
    var kAbortController = Symbol("abortController");
    var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    });
    var Request = class _Request {
      // https://fetch.spec.whatwg.org/#dom-request
      constructor(input, init = {}) {
        if (input === kConstruct) {
          return;
        }
        webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
        input = webidl.converters.RequestInfo(input);
        init = webidl.converters.RequestInit(init);
        this[kRealm] = {
          settingsObject: {
            baseUrl: getGlobalOrigin(),
            get origin() {
              return this.baseUrl?.origin;
            },
            policyContainer: makePolicyContainer()
          }
        };
        let request = null;
        let fallbackMode = null;
        const baseUrl = this[kRealm].settingsObject.baseUrl;
        let signal = null;
        if (typeof input === "string") {
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input, { cause: err });
          }
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " + input
            );
          }
          request = makeRequest({ urlList: [parsedURL] });
          fallbackMode = "cors";
        } else {
          assert(input instanceof _Request);
          request = input[kState];
          signal = input[kSignal];
        }
        const origin = this[kRealm].settingsObject.origin;
        let window = "client";
        if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
          window = request.window;
        }
        if (init.window != null) {
          throw new TypeError(`'window' option '${window}' must be null`);
        }
        if ("window" in init) {
          window = "no-window";
        }
        request = makeRequest({
          // URL requests URL.
          // undici implementation note: this is set as the first item in request's urlList in makeRequest
          // method requests method.
          method: request.method,
          // header list A copy of requests header list.
          // undici implementation note: headersList is cloned in makeRequest
          headersList: request.headersList,
          // unsafe-request flag Set.
          unsafeRequest: request.unsafeRequest,
          // client Thiss relevant settings object.
          client: this[kRealm].settingsObject,
          // window window.
          window,
          // priority requests priority.
          priority: request.priority,
          // origin requests origin. The propagation of the origin is only significant for navigation requests
          // being handled by a service worker. In this scenario a request can have an origin that is different
          // from the current client.
          origin: request.origin,
          // referrer requests referrer.
          referrer: request.referrer,
          // referrer policy requests referrer policy.
          referrerPolicy: request.referrerPolicy,
          // mode requests mode.
          mode: request.mode,
          // credentials mode requests credentials mode.
          credentials: request.credentials,
          // cache mode requests cache mode.
          cache: request.cache,
          // redirect mode requests redirect mode.
          redirect: request.redirect,
          // integrity metadata requests integrity metadata.
          integrity: request.integrity,
          // keepalive requests keepalive.
          keepalive: request.keepalive,
          // reload-navigation flag requests reload-navigation flag.
          reloadNavigation: request.reloadNavigation,
          // history-navigation flag requests history-navigation flag.
          historyNavigation: request.historyNavigation,
          // URL list A clone of requests URL list.
          urlList: [...request.urlList]
        });
        const initHasKey = Object.keys(init).length !== 0;
        if (initHasKey) {
          if (request.mode === "navigate") {
            request.mode = "same-origin";
          }
          request.reloadNavigation = false;
          request.historyNavigation = false;
          request.origin = "client";
          request.referrer = "client";
          request.referrerPolicy = "";
          request.url = request.urlList[request.urlList.length - 1];
          request.urlList = [request.url];
        }
        if (init.referrer !== void 0) {
          const referrer = init.referrer;
          if (referrer === "") {
            request.referrer = "no-referrer";
          } else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
            }
            if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) {
              request.referrer = "client";
            } else {
              request.referrer = parsedReferrer;
            }
          }
        }
        if (init.referrerPolicy !== void 0) {
          request.referrerPolicy = init.referrerPolicy;
        }
        let mode;
        if (init.mode !== void 0) {
          mode = init.mode;
        } else {
          mode = fallbackMode;
        }
        if (mode === "navigate") {
          throw webidl.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate."
          });
        }
        if (mode != null) {
          request.mode = mode;
        }
        if (init.credentials !== void 0) {
          request.credentials = init.credentials;
        }
        if (init.cache !== void 0) {
          request.cache = init.cache;
        }
        if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode"
          );
        }
        if (init.redirect !== void 0) {
          request.redirect = init.redirect;
        }
        if (init.integrity != null) {
          request.integrity = String(init.integrity);
        }
        if (init.keepalive !== void 0) {
          request.keepalive = Boolean(init.keepalive);
        }
        if (init.method !== void 0) {
          let method = init.method;
          if (!isValidHTTPToken(method)) {
            throw new TypeError(`'${method}' is not a valid HTTP method.`);
          }
          if (forbiddenMethodsSet.has(method.toUpperCase())) {
            throw new TypeError(`'${method}' HTTP method is unsupported.`);
          }
          method = normalizeMethodRecord[method] ?? normalizeMethod(method);
          request.method = method;
        }
        if (init.signal !== void 0) {
          signal = init.signal;
        }
        this[kState] = request;
        const ac = new AbortController();
        this[kSignal] = ac.signal;
        this[kSignal][kRealm] = this[kRealm];
        if (signal != null) {
          if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
            throw new TypeError(
              "Failed to construct 'Request': member signal is not of type AbortSignal."
            );
          }
          if (signal.aborted) {
            ac.abort(signal.reason);
          } else {
            this[kAbortController] = ac;
            const acRef = new WeakRef(ac);
            const abort = function() {
              const ac2 = acRef.deref();
              if (ac2 !== void 0) {
                ac2.abort(this.reason);
              }
            };
            try {
              if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
                setMaxListeners(100, signal);
              } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
                setMaxListeners(100, signal);
              }
            } catch {
            }
            util.addAbortListener(signal, abort);
            requestFinalizer.register(ac, { signal, abort });
          }
        }
        this[kHeaders] = new Headers(kConstruct);
        this[kHeaders][kHeadersList] = request.headersList;
        this[kHeaders][kGuard] = "request";
        this[kHeaders][kRealm] = this[kRealm];
        if (mode === "no-cors") {
          if (!corsSafeListedMethodsSet.has(request.method)) {
            throw new TypeError(
              `'${request.method} is unsupported in no-cors mode.`
            );
          }
          this[kHeaders][kGuard] = "request-no-cors";
        }
        if (initHasKey) {
          const headersList = this[kHeaders][kHeadersList];
          const headers = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
          headersList.clear();
          if (headers instanceof HeadersList) {
            for (const [key, val] of headers) {
              headersList.append(key, val);
            }
            headersList.cookies = headers.cookies;
          } else {
            fillHeaders(this[kHeaders], headers);
          }
        }
        const inputBody = input instanceof _Request ? input[kState].body : null;
        if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }
        let initBody = null;
        if (init.body != null) {
          const [extractedBody, contentType] = extractBody(
            init.body,
            request.keepalive
          );
          initBody = extractedBody;
          if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) {
            this[kHeaders].append("content-type", contentType);
          }
        }
        const inputOrInitBody = initBody ?? inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (initBody != null && init.duplex == null) {
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          }
          if (request.mode !== "same-origin" && request.mode !== "cors") {
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
            );
          }
          request.useCORSPreflightFlag = true;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used."
            );
          }
          if (!TransformStream) {
            TransformStream = require("stream/web").TransformStream;
          }
          const identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this[kState].body = finalBody;
      }
      // Returns requests HTTP method, which is "GET" by default.
      get method() {
        webidl.brandCheck(this, _Request);
        return this[kState].method;
      }
      // Returns the URL of request as a string.
      get url() {
        webidl.brandCheck(this, _Request);
        return URLSerializer(this[kState].url);
      }
      // Returns a Headers object consisting of the headers associated with request.
      // Note that headers added in the network layer by the user agent will not
      // be accounted for in this object, e.g., the "Host" header.
      get headers() {
        webidl.brandCheck(this, _Request);
        return this[kHeaders];
      }
      // Returns the kind of resource requested by request, e.g., "document"
      // or "script".
      get destination() {
        webidl.brandCheck(this, _Request);
        return this[kState].destination;
      }
      // Returns the referrer of request. Its value can be a same-origin URL if
      // explicitly set in init, the empty string to indicate no referrer, and
      // "about:client" when defaulting to the globals default. This is used
      // during fetching to determine the value of the `Referer` header of the
      // request being made.
      get referrer() {
        webidl.brandCheck(this, _Request);
        if (this[kState].referrer === "no-referrer") {
          return "";
        }
        if (this[kState].referrer === "client") {
          return "about:client";
        }
        return this[kState].referrer.toString();
      }
      // Returns the referrer policy associated with request.
      // This is used during fetching to compute the value of the requests
      // referrer.
      get referrerPolicy() {
        webidl.brandCheck(this, _Request);
        return this[kState].referrerPolicy;
      }
      // Returns the mode associated with request, which is a string indicating
      // whether the request will use CORS, or will be restricted to same-origin
      // URLs.
      get mode() {
        webidl.brandCheck(this, _Request);
        return this[kState].mode;
      }
      // Returns the credentials mode associated with request,
      // which is a string indicating whether credentials will be sent with the
      // request always, never, or only when sent to a same-origin URL.
      get credentials() {
        return this[kState].credentials;
      }
      // Returns the cache mode associated with request,
      // which is a string indicating how the request will
      // interact with the browsers cache when fetching.
      get cache() {
        webidl.brandCheck(this, _Request);
        return this[kState].cache;
      }
      // Returns the redirect mode associated with request,
      // which is a string indicating how redirects for the
      // request will be handled during fetching. A request
      // will follow redirects by default.
      get redirect() {
        webidl.brandCheck(this, _Request);
        return this[kState].redirect;
      }
      // Returns requests subresource integrity metadata, which is a
      // cryptographic hash of the resource being fetched. Its value
      // consists of multiple hashes separated by whitespace. [SRI]
      get integrity() {
        webidl.brandCheck(this, _Request);
        return this[kState].integrity;
      }
      // Returns a boolean indicating whether or not request can outlive the
      // global in which it was created.
      get keepalive() {
        webidl.brandCheck(this, _Request);
        return this[kState].keepalive;
      }
      // Returns a boolean indicating whether or not request is for a reload
      // navigation.
      get isReloadNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].reloadNavigation;
      }
      // Returns a boolean indicating whether or not request is for a history
      // navigation (a.k.a. back-foward navigation).
      get isHistoryNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].historyNavigation;
      }
      // Returns the signal associated with request, which is an AbortSignal
      // object indicating whether or not request has been aborted, and its
      // abort event handler.
      get signal() {
        webidl.brandCheck(this, _Request);
        return this[kSignal];
      }
      get body() {
        webidl.brandCheck(this, _Request);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Request);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      get duplex() {
        webidl.brandCheck(this, _Request);
        return "half";
      }
      // Returns a clone of request.
      clone() {
        webidl.brandCheck(this, _Request);
        if (this.bodyUsed || this.body?.locked) {
          throw new TypeError("unusable");
        }
        const clonedRequest = cloneRequest(this[kState]);
        const clonedRequestObject = new _Request(kConstruct);
        clonedRequestObject[kState] = clonedRequest;
        clonedRequestObject[kRealm] = this[kRealm];
        clonedRequestObject[kHeaders] = new Headers(kConstruct);
        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        const ac = new AbortController();
        if (this.signal.aborted) {
          ac.abort(this.signal.reason);
        } else {
          util.addAbortListener(
            this.signal,
            () => {
              ac.abort(this.signal.reason);
            }
          );
        }
        clonedRequestObject[kSignal] = ac.signal;
        return clonedRequestObject;
      }
    };
    mixinBody(Request);
    function makeRequest(init) {
      const request = {
        method: "GET",
        localURLsOnly: false,
        unsafeRequest: false,
        body: null,
        client: null,
        reservedClient: null,
        replacesClientId: "",
        window: "client",
        keepalive: false,
        serviceWorkers: "all",
        initiator: "",
        destination: "",
        priority: null,
        origin: "client",
        policyContainer: "client",
        referrer: "client",
        referrerPolicy: "",
        mode: "no-cors",
        useCORSPreflightFlag: false,
        credentials: "same-origin",
        useCredentials: false,
        cache: "default",
        redirect: "follow",
        integrity: "",
        cryptoGraphicsNonceMetadata: "",
        parserMetadata: "",
        reloadNavigation: false,
        historyNavigation: false,
        userActivation: false,
        taintedOrigin: false,
        redirectCount: 0,
        responseTainting: "basic",
        preventNoCacheCacheControlHeaderModification: false,
        done: false,
        timingAllowFailed: false,
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
      };
      request.url = request.urlList[0];
      return request;
    }
    function cloneRequest(request) {
      const newRequest = makeRequest({ ...request, body: null });
      if (request.body != null) {
        newRequest.body = cloneBody(request.body);
      }
      return newRequest;
    }
    Object.defineProperties(Request.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty,
      duplex: kEnumerableProperty,
      destination: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      isHistoryNavigation: kEnumerableProperty,
      isReloadNavigation: kEnumerableProperty,
      keepalive: kEnumerableProperty,
      integrity: kEnumerableProperty,
      cache: kEnumerableProperty,
      credentials: kEnumerableProperty,
      attribute: kEnumerableProperty,
      referrerPolicy: kEnumerableProperty,
      referrer: kEnumerableProperty,
      mode: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Request",
        configurable: true
      }
    });
    webidl.converters.Request = webidl.interfaceConverter(
      Request
    );
    webidl.converters.RequestInfo = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (V instanceof Request) {
        return webidl.converters.Request(V);
      }
      return webidl.converters.USVString(V);
    };
    webidl.converters.AbortSignal = webidl.interfaceConverter(
      AbortSignal
    );
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: "method",
        converter: webidl.converters.ByteString
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      },
      {
        key: "body",
        converter: webidl.nullableConverter(
          webidl.converters.BodyInit
        )
      },
      {
        key: "referrer",
        converter: webidl.converters.USVString
      },
      {
        key: "referrerPolicy",
        converter: webidl.converters.DOMString,
        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
        allowedValues: referrerPolicy
      },
      {
        key: "mode",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#concept-request-mode
        allowedValues: requestMode
      },
      {
        key: "credentials",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcredentials
        allowedValues: requestCredentials
      },
      {
        key: "cache",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcache
        allowedValues: requestCache
      },
      {
        key: "redirect",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestredirect
        allowedValues: requestRedirect
      },
      {
        key: "integrity",
        converter: webidl.converters.DOMString
      },
      {
        key: "keepalive",
        converter: webidl.converters.boolean
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(
          (signal) => webidl.converters.AbortSignal(
            signal,
            { strict: false }
          )
        )
      },
      {
        key: "window",
        converter: webidl.converters.any
      },
      {
        key: "duplex",
        converter: webidl.converters.DOMString,
        allowedValues: requestDuplex
      }
    ]);
    module2.exports = { Request, makeRequest };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fetch/index.js"(exports2, module2) {
    "use strict";
    var {
      Response,
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse
    } = require_response();
    var { Headers } = require_headers();
    var { Request, makeRequest } = require_request2();
    var zlib = require("zlib");
    var {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      isBlobLike,
      sameOrigin,
      isCancelled,
      isAborted,
      isErrorLike,
      fullyReadBody,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlIsHttpHttpsScheme,
      urlHasHttpsScheme
    } = require_util2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var assert = require("assert");
    var { safelyExtractBody } = require_body();
    var {
      redirectStatusSet,
      nullBodyStatus,
      safeMethodsSet,
      requestBodyHeader,
      subresourceSet,
      DOMException: DOMException2
    } = require_constants2();
    var { kHeadersList } = require_symbols();
    var EE = require("events");
    var { Readable, pipeline } = require("stream");
    var { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util();
    var { dataURLProcessor, serializeAMimeType } = require_dataURL();
    var { TransformStream } = require("stream/web");
    var { getGlobalDispatcher } = require_global2();
    var { webidl } = require_webidl();
    var { STATUS_CODES } = require("http");
    var GET_OR_HEAD = ["GET", "HEAD"];
    var resolveObjectURL;
    var ReadableStream = globalThis.ReadableStream;
    var Fetch = class extends EE {
      constructor(dispatcher) {
        super();
        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
        this.setMaxListeners(21);
      }
      terminate(reason) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "terminated";
        this.connection?.destroy(reason);
        this.emit("terminated", reason);
      }
      // https://fetch.spec.whatwg.org/#fetch-controller-abort
      abort(error2) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "aborted";
        if (!error2) {
          error2 = new DOMException2("The operation was aborted.", "AbortError");
        }
        this.serializedAbortReason = error2;
        this.connection?.destroy(error2);
        this.emit("terminated", error2);
      }
    };
    function fetch(input, init = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
      const p3 = createDeferredPromise();
      let requestObject;
      try {
        requestObject = new Request(input, init);
      } catch (e2) {
        p3.reject(e2);
        return p3.promise;
      }
      const request = requestObject[kState];
      if (requestObject.signal.aborted) {
        abortFetch(p3, request, null, requestObject.signal.reason);
        return p3.promise;
      }
      const globalObject = request.client.globalObject;
      if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
        request.serviceWorkers = "none";
      }
      let responseObject = null;
      const relevantRealm = null;
      let locallyAborted = false;
      let controller = null;
      addAbortListener(
        requestObject.signal,
        () => {
          locallyAborted = true;
          assert(controller != null);
          controller.abort(requestObject.signal.reason);
          abortFetch(p3, request, responseObject, requestObject.signal.reason);
        }
      );
      const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
      const processResponse = (response) => {
        if (locallyAborted) {
          return Promise.resolve();
        }
        if (response.aborted) {
          abortFetch(p3, request, responseObject, controller.serializedAbortReason);
          return Promise.resolve();
        }
        if (response.type === "error") {
          p3.reject(
            Object.assign(new TypeError("fetch failed"), { cause: response.error })
          );
          return Promise.resolve();
        }
        responseObject = new Response();
        responseObject[kState] = response;
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        p3.resolve(responseObject);
      };
      controller = fetching({
        request,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: init.dispatcher ?? getGlobalDispatcher()
        // undici
      });
      return p3.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = "other") {
      if (response.type === "error" && response.aborted) {
        return;
      }
      if (!response.urlList?.length) {
        return;
      }
      const originalURL = response.urlList[0];
      let timingInfo = response.timingInfo;
      let cacheState = response.cacheState;
      if (!urlIsHttpHttpsScheme(originalURL)) {
        return;
      }
      if (timingInfo === null) {
        return;
      }
      if (!response.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime
        });
        cacheState = "";
      }
      timingInfo.endTime = coarsenedSharedCurrentTime();
      response.timingInfo = timingInfo;
      markResourceTiming(
        timingInfo,
        originalURL,
        initiatorType,
        globalThis,
        cacheState
      );
    }
    function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
      if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {
        performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
      }
    }
    function abortFetch(p3, request, responseObject, error2) {
      if (!error2) {
        error2 = new DOMException2("The operation was aborted.", "AbortError");
      }
      p3.reject(error2);
      if (request.body != null && isReadable(request.body?.stream)) {
        request.body.stream.cancel(error2).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
      if (responseObject == null) {
        return;
      }
      const response = responseObject[kState];
      if (response.body != null && isReadable(response.body?.stream)) {
        response.body.stream.cancel(error2).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
    }
    function fetching({
      request,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher
      // undici
    }) {
      let taskDestination = null;
      let crossOriginIsolatedCapability = false;
      if (request.client != null) {
        taskDestination = request.client.globalObject;
        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
      }
      const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
      const timingInfo = createOpaqueTimingInfo({
        startTime: currenTime
      });
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability
      };
      assert(!request.body || request.body.stream);
      if (request.window === "client") {
        request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
      }
      if (request.origin === "client") {
        request.origin = request.client?.origin;
      }
      if (request.policyContainer === "client") {
        if (request.client != null) {
          request.policyContainer = clonePolicyContainer(
            request.client.policyContainer
          );
        } else {
          request.policyContainer = makePolicyContainer();
        }
      }
      if (!request.headersList.contains("accept")) {
        const value = "*/*";
        request.headersList.append("accept", value);
      }
      if (!request.headersList.contains("accept-language")) {
        request.headersList.append("accept-language", "*");
      }
      if (request.priority === null) {
      }
      if (subresourceSet.has(request.destination)) {
      }
      mainFetch(fetchParams).catch((err) => {
        fetchParams.controller.terminate(err);
      });
      return fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive = false) {
      const request = fetchParams.request;
      let response = null;
      if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
        response = makeNetworkError("local URLs only");
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
      if (requestBadPort(request) === "blocked") {
        response = makeNetworkError("bad port");
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = request.policyContainer.referrerPolicy;
      }
      if (request.referrer !== "no-referrer") {
        request.referrer = determineRequestsReferrer(request);
      }
      if (response === null) {
        response = await (async () => {
          const currentURL = requestCurrentURL(request);
          if (
            // - requests current URLs origin is same origin with requests origin,
            //   and requests response tainting is "basic"
            sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || // requests current URLs scheme is "data"
            currentURL.protocol === "data:" || // - requests mode is "navigate" or "websocket"
            (request.mode === "navigate" || request.mode === "websocket")
          ) {
            request.responseTainting = "basic";
            return await schemeFetch(fetchParams);
          }
          if (request.mode === "same-origin") {
            return makeNetworkError('request mode cannot be "same-origin"');
          }
          if (request.mode === "no-cors") {
            if (request.redirect !== "follow") {
              return makeNetworkError(
                'redirect mode cannot be "follow" for "no-cors" request'
              );
            }
            request.responseTainting = "opaque";
            return await schemeFetch(fetchParams);
          }
          if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
            return makeNetworkError("URL scheme must be a HTTP(S) scheme");
          }
          request.responseTainting = "cors";
          return await httpFetch(fetchParams);
        })();
      }
      if (recursive) {
        return response;
      }
      if (response.status !== 0 && !response.internalResponse) {
        if (request.responseTainting === "cors") {
        }
        if (request.responseTainting === "basic") {
          response = filterResponse(response, "basic");
        } else if (request.responseTainting === "cors") {
          response = filterResponse(response, "cors");
        } else if (request.responseTainting === "opaque") {
          response = filterResponse(response, "opaque");
        } else {
          assert(false);
        }
      }
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request.urlList);
      }
      if (!request.timingAllowFailed) {
        response.timingAllowPassed = true;
      }
      if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range")) {
        response = internalResponse = makeNetworkError();
      }
      if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }
        const processBody = (bytes) => {
          if (!bytesMatch(bytes, request.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          response.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response);
        };
        await fullyReadBody(response.body, processBody, processBodyError);
      } else {
        fetchFinale(fetchParams, response);
      }
    }
    function schemeFetch(fetchParams) {
      if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
        return Promise.resolve(makeAppropriateNetworkError(fetchParams));
      }
      const { request } = fetchParams;
      const { protocol: scheme } = requestCurrentURL(request);
      switch (scheme) {
        case "about:": {
          return Promise.resolve(makeNetworkError("about scheme is not supported"));
        }
        case "blob:": {
          if (!resolveObjectURL) {
            resolveObjectURL = require("buffer").resolveObjectURL;
          }
          const blobURLEntry = requestCurrentURL(request);
          if (blobURLEntry.search.length !== 0) {
            return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
          }
          const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
          if (request.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
            return Promise.resolve(makeNetworkError("invalid method"));
          }
          const bodyWithType = safelyExtractBody(blobURLEntryObject);
          const body = bodyWithType[0];
          const length = isomorphicEncode(`${body.length}`);
          const type = bodyWithType[1] ?? "";
          const response = makeResponse({
            statusText: "OK",
            headersList: [
              ["content-length", { name: "Content-Length", value: length }],
              ["content-type", { name: "Content-Type", value: type }]
            ]
          });
          response.body = body;
          return Promise.resolve(response);
        }
        case "data:": {
          const currentURL = requestCurrentURL(request);
          const dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          const mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return Promise.resolve(makeResponse({
            statusText: "OK",
            headersList: [
              ["content-type", { name: "Content-Type", value: mimeType }]
            ],
            body: safelyExtractBody(dataURLStruct.body)[0]
          }));
        }
        case "file:": {
          return Promise.resolve(makeNetworkError("not implemented... yet..."));
        }
        case "http:":
        case "https:": {
          return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        }
        default: {
          return Promise.resolve(makeNetworkError("unknown scheme"));
        }
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = true;
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }
    function fetchFinale(fetchParams, response) {
      if (response.type === "error") {
        response.urlList = [fetchParams.request.urlList[0]];
        response.timingInfo = createOpaqueTimingInfo({
          startTime: fetchParams.timingInfo.startTime
        });
      }
      const processResponseEndOfBody = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
        }
      };
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => fetchParams.processResponse(response));
      }
      if (response.body == null) {
        processResponseEndOfBody();
      } else {
        const identityTransformAlgorithm = (chunk, controller) => {
          controller.enqueue(chunk);
        };
        const transformStream = new TransformStream({
          start() {
          },
          transform: identityTransformAlgorithm,
          flush: processResponseEndOfBody
        }, {
          size() {
            return 1;
          }
        }, {
          size() {
            return 1;
          }
        });
        response.body = { stream: response.body.stream.pipeThrough(transformStream) };
      }
      if (fetchParams.processResponseConsumeBody != null) {
        const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
        const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
        if (response.body == null) {
          queueMicrotask(() => processBody(null));
        } else {
          return fullyReadBody(response.body, processBody, processBodyError);
        }
        return Promise.resolve();
      }
    }
    async function httpFetch(fetchParams) {
      const request = fetchParams.request;
      let response = null;
      let actualResponse = null;
      const timingInfo = fetchParams.timingInfo;
      if (request.serviceWorkers === "all") {
      }
      if (response === null) {
        if (request.redirect === "follow") {
          request.serviceWorkers = "none";
        }
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
        if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
          return makeNetworkError("cors failure");
        }
        if (TAOCheck(request, response) === "failure") {
          request.timingAllowFailed = true;
        }
      }
      if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
        request.origin,
        request.client,
        request.destination,
        actualResponse
      ) === "blocked") {
        return makeNetworkError("blocked");
      }
      if (redirectStatusSet.has(actualResponse.status)) {
        if (request.redirect !== "manual") {
          fetchParams.controller.connection.destroy();
        }
        if (request.redirect === "error") {
          response = makeNetworkError("unexpected redirect");
        } else if (request.redirect === "manual") {
          response = actualResponse;
        } else if (request.redirect === "follow") {
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert(false);
        }
      }
      response.timingInfo = timingInfo;
      return response;
    }
    function httpRedirectFetch(fetchParams, response) {
      const request = fetchParams.request;
      const actualResponse = response.internalResponse ? response.internalResponse : response;
      let locationURL;
      try {
        locationURL = responseLocationURL(
          actualResponse,
          requestCurrentURL(request).hash
        );
        if (locationURL == null) {
          return response;
        }
      } catch (err) {
        return Promise.resolve(makeNetworkError(err));
      }
      if (!urlIsHttpHttpsScheme(locationURL)) {
        return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
      }
      if (request.redirectCount === 20) {
        return Promise.resolve(makeNetworkError("redirect count exceeded"));
      }
      request.redirectCount += 1;
      if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
      }
      if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
        return Promise.resolve(makeNetworkError(
          'URL cannot contain credentials for request mode "cors"'
        ));
      }
      if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
        return Promise.resolve(makeNetworkError());
      }
      if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
        request.method = "GET";
        request.body = null;
        for (const headerName of requestBodyHeader) {
          request.headersList.delete(headerName);
        }
      }
      if (!sameOrigin(requestCurrentURL(request), locationURL)) {
        request.headersList.delete("authorization");
        request.headersList.delete("proxy-authorization", true);
        request.headersList.delete("cookie");
        request.headersList.delete("host");
      }
      if (request.body != null) {
        assert(request.body.source != null);
        request.body = safelyExtractBody(request.body.source)[0];
      }
      const timingInfo = fetchParams.timingInfo;
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }
      request.urlList.push(locationURL);
      setRequestReferrerPolicyOnRedirect(request, actualResponse);
      return mainFetch(fetchParams, true);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
      const request = fetchParams.request;
      let httpFetchParams = null;
      let httpRequest = null;
      let response = null;
      const httpCache = null;
      const revalidatingFlag = false;
      if (request.window === "no-window" && request.redirect === "error") {
        httpFetchParams = fetchParams;
        httpRequest = request;
      } else {
        httpRequest = makeRequest(request);
        httpFetchParams = { ...fetchParams };
        httpFetchParams.request = httpRequest;
      }
      const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
      const contentLength = httpRequest.body ? httpRequest.body.length : null;
      let contentLengthHeaderValue = null;
      if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
        contentLengthHeaderValue = "0";
      }
      if (contentLength != null) {
        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
      }
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append("content-length", contentLengthHeaderValue);
      }
      if (contentLength != null && httpRequest.keepalive) {
      }
      if (httpRequest.referrer instanceof URL) {
        httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
      }
      appendRequestOriginHeader(httpRequest);
      appendFetchMetadata(httpRequest);
      if (!httpRequest.headersList.contains("user-agent")) {
        httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
      }
      if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) {
        httpRequest.headersList.append("cache-control", "max-age=0");
      }
      if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
        if (!httpRequest.headersList.contains("pragma")) {
          httpRequest.headersList.append("pragma", "no-cache");
        }
        if (!httpRequest.headersList.contains("cache-control")) {
          httpRequest.headersList.append("cache-control", "no-cache");
        }
      }
      if (httpRequest.headersList.contains("range")) {
        httpRequest.headersList.append("accept-encoding", "identity");
      }
      if (!httpRequest.headersList.contains("accept-encoding")) {
        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
          httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
        } else {
          httpRequest.headersList.append("accept-encoding", "gzip, deflate");
        }
      }
      httpRequest.headersList.delete("host");
      if (includeCredentials) {
      }
      if (httpCache == null) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
      }
      if (response == null) {
        if (httpRequest.mode === "only-if-cached") {
          return makeNetworkError("only if cached");
        }
        const forwardResponse = await httpNetworkFetch(
          httpFetchParams,
          includeCredentials,
          isNewConnectionFetch
        );
        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
        }
        if (revalidatingFlag && forwardResponse.status === 304) {
        }
        if (response == null) {
          response = forwardResponse;
        }
      }
      response.urlList = [...httpRequest.urlList];
      if (httpRequest.headersList.contains("range")) {
        response.rangeRequested = true;
      }
      response.requestIncludesCredentials = includeCredentials;
      if (response.status === 407) {
        if (request.window === "no-window") {
          return makeNetworkError();
        }
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError("proxy authentication required");
      }
      if (
        // responses status is 421
        response.status === 421 && // isNewConnectionFetch is false
        !isNewConnectionFetch && // requests body is null, or requests body is non-null and requests bodys source is non-null
        (request.body == null || request.body.source != null)
      ) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        fetchParams.controller.connection.destroy();
        response = await httpNetworkOrCacheFetch(
          fetchParams,
          isAuthenticationFetch,
          true
        );
      }
      if (isAuthenticationFetch) {
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
      assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err) {
          if (!this.destroyed) {
            this.destroyed = true;
            this.abort?.(err ?? new DOMException2("The operation was aborted.", "AbortError"));
          }
        }
      };
      const request = fetchParams.request;
      let response = null;
      const timingInfo = fetchParams.timingInfo;
      const httpCache = null;
      if (httpCache == null) {
        request.cache = "no-store";
      }
      const newConnection = forceNewConnection ? "yes" : "no";
      if (request.mode === "websocket") {
      } else {
      }
      let requestBody = null;
      if (request.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request.body != null) {
        const processBodyChunk = async function* (bytes) {
          if (isCancelled(fetchParams)) {
            return;
          }
          yield bytes;
          fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
        };
        const processEndOfBody = () => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };
        const processBodyError = (e2) => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (e2.name === "AbortError") {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e2);
          }
        };
        requestBody = async function* () {
          try {
            for await (const bytes of request.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        }();
      }
      try {
        const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
        if (socket) {
          response = makeResponse({ status, statusText, headersList, socket });
        } else {
          const iterator = body[Symbol.asyncIterator]();
          fetchParams.controller.next = () => iterator.next();
          response = makeResponse({ status, statusText, headersList });
        }
      } catch (err) {
        if (err.name === "AbortError") {
          fetchParams.controller.connection.destroy();
          return makeAppropriateNetworkError(fetchParams, err);
        }
        return makeNetworkError(err);
      }
      const pullAlgorithm = () => {
        fetchParams.controller.resume();
      };
      const cancelAlgorithm = (reason) => {
        fetchParams.controller.abort(reason);
      };
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      const stream = new ReadableStream(
        {
          async start(controller) {
            fetchParams.controller.controller = controller;
          },
          async pull(controller) {
            await pullAlgorithm(controller);
          },
          async cancel(reason) {
            await cancelAlgorithm(reason);
          }
        },
        {
          highWaterMark: 0,
          size() {
            return 1;
          }
        }
      );
      response.body = { stream };
      fetchParams.controller.on("terminated", onAborted);
      fetchParams.controller.resume = async () => {
        while (true) {
          let bytes;
          let isFailure;
          try {
            const { done, value } = await fetchParams.controller.next();
            if (isAborted(fetchParams)) {
              break;
            }
            bytes = done ? void 0 : value;
          } catch (err) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              bytes = void 0;
            } else {
              bytes = err;
              isFailure = true;
            }
          }
          if (bytes === void 0) {
            readableStreamClose(fetchParams.controller.controller);
            finalizeResponse(fetchParams, response);
            return;
          }
          timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
          if (isFailure) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
          if (isErrored(stream)) {
            fetchParams.controller.terminate();
            return;
          }
          if (!fetchParams.controller.controller.desiredSize) {
            return;
          }
        }
      };
      function onAborted(reason) {
        if (isAborted(fetchParams)) {
          response.aborted = true;
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(
              fetchParams.controller.serializedAbortReason
            );
          }
        } else {
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(new TypeError("terminated", {
              cause: isErrorLike(reason) ? reason : void 0
            }));
          }
        }
        fetchParams.controller.connection.destroy();
      }
      return response;
      async function dispatch({ body }) {
        const url = requestCurrentURL(request);
        const agent = fetchParams.controller.dispatcher;
        return new Promise((resolve2, reject) => agent.dispatch(
          {
            path: url.pathname + url.search,
            origin: url.origin,
            method: request.method,
            body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
            headers: request.headersList.entries,
            maxRedirections: 0,
            upgrade: request.mode === "websocket" ? "websocket" : void 0
          },
          {
            body: null,
            abort: null,
            onConnect(abort) {
              const { connection } = fetchParams.controller;
              if (connection.destroyed) {
                abort(new DOMException2("The operation was aborted.", "AbortError"));
              } else {
                fetchParams.controller.on("terminated", abort);
                this.abort = connection.abort = abort;
              }
            },
            onHeaders(status, headersList, resume, statusText) {
              if (status < 200) {
                return;
              }
              let codings = [];
              let location = "";
              const headers = new Headers();
              if (Array.isArray(headersList)) {
                for (let n3 = 0; n3 < headersList.length; n3 += 2) {
                  const key = headersList[n3 + 0].toString("latin1");
                  const val = headersList[n3 + 1].toString("latin1");
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x3) => x3.trim());
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers[kHeadersList].append(key, val);
                }
              } else {
                const keys = Object.keys(headersList);
                for (const key of keys) {
                  const val = headersList[key];
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x3) => x3.trim()).reverse();
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers[kHeadersList].append(key, val);
                }
              }
              this.body = new Readable({ read: resume });
              const decoders = [];
              const willFollow = request.redirect === "follow" && location && redirectStatusSet.has(status);
              if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
                for (const coding of codings) {
                  if (coding === "x-gzip" || coding === "gzip") {
                    decoders.push(zlib.createGunzip({
                      // Be less strict when decoding compressed responses, since sometimes
                      // servers send slightly invalid responses that are still accepted
                      // by common browsers.
                      // Always using Z_SYNC_FLUSH is what cURL does.
                      flush: zlib.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib.constants.Z_SYNC_FLUSH
                    }));
                  } else if (coding === "deflate") {
                    decoders.push(zlib.createInflate());
                  } else if (coding === "br") {
                    decoders.push(zlib.createBrotliDecompress());
                  } else {
                    decoders.length = 0;
                    break;
                  }
                }
              }
              resolve2({
                status,
                statusText,
                headersList: headers[kHeadersList],
                body: decoders.length ? pipeline(this.body, ...decoders, () => {
                }) : this.body.on("error", () => {
                })
              });
              return true;
            },
            onData(chunk) {
              if (fetchParams.controller.dump) {
                return;
              }
              const bytes = chunk;
              timingInfo.encodedBodySize += bytes.byteLength;
              return this.body.push(bytes);
            },
            onComplete() {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              fetchParams.controller.ended = true;
              this.body.push(null);
            },
            onError(error2) {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              this.body?.destroy(error2);
              fetchParams.controller.terminate(error2);
              reject(error2);
            },
            onUpgrade(status, headersList, socket) {
              if (status !== 101) {
                return;
              }
              const headers = new Headers();
              for (let n3 = 0; n3 < headersList.length; n3 += 2) {
                const key = headersList[n3 + 0].toString("latin1");
                const val = headersList[n3 + 1].toString("latin1");
                headers[kHeadersList].append(key, val);
              }
              resolve2({
                status,
                statusText: STATUS_CODES[status],
                headersList: headers[kHeadersList],
                socket
              });
              return true;
            }
          }
        ));
      }
    }
    module2.exports = {
      fetch,
      Fetch,
      fetching,
      finalizeAndReportTiming
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/symbols.js
var require_symbols3 = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kState: Symbol("FileReader state"),
      kResult: Symbol("FileReader result"),
      kError: Symbol("FileReader error"),
      kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
      kEvents: Symbol("FileReader events"),
      kAborted: Symbol("FileReader aborted")
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/progressevent.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var kState = Symbol("ProgressEvent state");
    var ProgressEvent = class _ProgressEvent extends Event {
      constructor(type, eventInitDict = {}) {
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
        super(type, eventInitDict);
        this[kState] = {
          lengthComputable: eventInitDict.lengthComputable,
          loaded: eventInitDict.loaded,
          total: eventInitDict.total
        };
      }
      get lengthComputable() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].lengthComputable;
      }
      get loaded() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].loaded;
      }
      get total() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].total;
      }
    };
    webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
      {
        key: "lengthComputable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "loaded",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "total",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ]);
    module2.exports = {
      ProgressEvent
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/encoding.js"(exports2, module2) {
    "use strict";
    function getEncoding(label) {
      if (!label) {
        return "failure";
      }
      switch (label.trim().toLowerCase()) {
        case "unicode-1-1-utf-8":
        case "unicode11utf8":
        case "unicode20utf8":
        case "utf-8":
        case "utf8":
        case "x-unicode20utf8":
          return "UTF-8";
        case "866":
        case "cp866":
        case "csibm866":
        case "ibm866":
          return "IBM866";
        case "csisolatin2":
        case "iso-8859-2":
        case "iso-ir-101":
        case "iso8859-2":
        case "iso88592":
        case "iso_8859-2":
        case "iso_8859-2:1987":
        case "l2":
        case "latin2":
          return "ISO-8859-2";
        case "csisolatin3":
        case "iso-8859-3":
        case "iso-ir-109":
        case "iso8859-3":
        case "iso88593":
        case "iso_8859-3":
        case "iso_8859-3:1988":
        case "l3":
        case "latin3":
          return "ISO-8859-3";
        case "csisolatin4":
        case "iso-8859-4":
        case "iso-ir-110":
        case "iso8859-4":
        case "iso88594":
        case "iso_8859-4":
        case "iso_8859-4:1988":
        case "l4":
        case "latin4":
          return "ISO-8859-4";
        case "csisolatincyrillic":
        case "cyrillic":
        case "iso-8859-5":
        case "iso-ir-144":
        case "iso8859-5":
        case "iso88595":
        case "iso_8859-5":
        case "iso_8859-5:1988":
          return "ISO-8859-5";
        case "arabic":
        case "asmo-708":
        case "csiso88596e":
        case "csiso88596i":
        case "csisolatinarabic":
        case "ecma-114":
        case "iso-8859-6":
        case "iso-8859-6-e":
        case "iso-8859-6-i":
        case "iso-ir-127":
        case "iso8859-6":
        case "iso88596":
        case "iso_8859-6":
        case "iso_8859-6:1987":
          return "ISO-8859-6";
        case "csisolatingreek":
        case "ecma-118":
        case "elot_928":
        case "greek":
        case "greek8":
        case "iso-8859-7":
        case "iso-ir-126":
        case "iso8859-7":
        case "iso88597":
        case "iso_8859-7":
        case "iso_8859-7:1987":
        case "sun_eu_greek":
          return "ISO-8859-7";
        case "csiso88598e":
        case "csisolatinhebrew":
        case "hebrew":
        case "iso-8859-8":
        case "iso-8859-8-e":
        case "iso-ir-138":
        case "iso8859-8":
        case "iso88598":
        case "iso_8859-8":
        case "iso_8859-8:1988":
        case "visual":
          return "ISO-8859-8";
        case "csiso88598i":
        case "iso-8859-8-i":
        case "logical":
          return "ISO-8859-8-I";
        case "csisolatin6":
        case "iso-8859-10":
        case "iso-ir-157":
        case "iso8859-10":
        case "iso885910":
        case "l6":
        case "latin6":
          return "ISO-8859-10";
        case "iso-8859-13":
        case "iso8859-13":
        case "iso885913":
          return "ISO-8859-13";
        case "iso-8859-14":
        case "iso8859-14":
        case "iso885914":
          return "ISO-8859-14";
        case "csisolatin9":
        case "iso-8859-15":
        case "iso8859-15":
        case "iso885915":
        case "iso_8859-15":
        case "l9":
          return "ISO-8859-15";
        case "iso-8859-16":
          return "ISO-8859-16";
        case "cskoi8r":
        case "koi":
        case "koi8":
        case "koi8-r":
        case "koi8_r":
          return "KOI8-R";
        case "koi8-ru":
        case "koi8-u":
          return "KOI8-U";
        case "csmacintosh":
        case "mac":
        case "macintosh":
        case "x-mac-roman":
          return "macintosh";
        case "iso-8859-11":
        case "iso8859-11":
        case "iso885911":
        case "tis-620":
        case "windows-874":
          return "windows-874";
        case "cp1250":
        case "windows-1250":
        case "x-cp1250":
          return "windows-1250";
        case "cp1251":
        case "windows-1251":
        case "x-cp1251":
          return "windows-1251";
        case "ansi_x3.4-1968":
        case "ascii":
        case "cp1252":
        case "cp819":
        case "csisolatin1":
        case "ibm819":
        case "iso-8859-1":
        case "iso-ir-100":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "iso_8859-1:1987":
        case "l1":
        case "latin1":
        case "us-ascii":
        case "windows-1252":
        case "x-cp1252":
          return "windows-1252";
        case "cp1253":
        case "windows-1253":
        case "x-cp1253":
          return "windows-1253";
        case "cp1254":
        case "csisolatin5":
        case "iso-8859-9":
        case "iso-ir-148":
        case "iso8859-9":
        case "iso88599":
        case "iso_8859-9":
        case "iso_8859-9:1989":
        case "l5":
        case "latin5":
        case "windows-1254":
        case "x-cp1254":
          return "windows-1254";
        case "cp1255":
        case "windows-1255":
        case "x-cp1255":
          return "windows-1255";
        case "cp1256":
        case "windows-1256":
        case "x-cp1256":
          return "windows-1256";
        case "cp1257":
        case "windows-1257":
        case "x-cp1257":
          return "windows-1257";
        case "cp1258":
        case "windows-1258":
        case "x-cp1258":
          return "windows-1258";
        case "x-mac-cyrillic":
        case "x-mac-ukrainian":
          return "x-mac-cyrillic";
        case "chinese":
        case "csgb2312":
        case "csiso58gb231280":
        case "gb2312":
        case "gb_2312":
        case "gb_2312-80":
        case "gbk":
        case "iso-ir-58":
        case "x-gbk":
          return "GBK";
        case "gb18030":
          return "gb18030";
        case "big5":
        case "big5-hkscs":
        case "cn-big5":
        case "csbig5":
        case "x-x-big5":
          return "Big5";
        case "cseucpkdfmtjapanese":
        case "euc-jp":
        case "x-euc-jp":
          return "EUC-JP";
        case "csiso2022jp":
        case "iso-2022-jp":
          return "ISO-2022-JP";
        case "csshiftjis":
        case "ms932":
        case "ms_kanji":
        case "shift-jis":
        case "shift_jis":
        case "sjis":
        case "windows-31j":
        case "x-sjis":
          return "Shift_JIS";
        case "cseuckr":
        case "csksc56011987":
        case "euc-kr":
        case "iso-ir-149":
        case "korean":
        case "ks_c_5601-1987":
        case "ks_c_5601-1989":
        case "ksc5601":
        case "ksc_5601":
        case "windows-949":
          return "EUC-KR";
        case "csiso2022kr":
        case "hz-gb-2312":
        case "iso-2022-cn":
        case "iso-2022-cn-ext":
        case "iso-2022-kr":
        case "replacement":
          return "replacement";
        case "unicodefffe":
        case "utf-16be":
          return "UTF-16BE";
        case "csunicode":
        case "iso-10646-ucs-2":
        case "ucs-2":
        case "unicode":
        case "unicodefeff":
        case "utf-16":
        case "utf-16le":
          return "UTF-16LE";
        case "x-user-defined":
          return "x-user-defined";
        default:
          return "failure";
      }
    }
    module2.exports = {
      getEncoding
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/util.js
var require_util4 = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/util.js"(exports2, module2) {
    "use strict";
    var {
      kState,
      kError,
      kResult,
      kAborted,
      kLastProgressEventFired
    } = require_symbols3();
    var { ProgressEvent } = require_progressevent();
    var { getEncoding } = require_encoding();
    var { DOMException: DOMException2 } = require_constants2();
    var { serializeAMimeType, parseMIMEType } = require_dataURL();
    var { types } = require("util");
    var { StringDecoder } = require("string_decoder");
    var { btoa } = require("buffer");
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    function readOperation(fr, blob, type, encodingName) {
      if (fr[kState] === "loading") {
        throw new DOMException2("Invalid state", "InvalidStateError");
      }
      fr[kState] = "loading";
      fr[kResult] = null;
      fr[kError] = null;
      const stream = blob.stream();
      const reader = stream.getReader();
      const bytes = [];
      let chunkPromise = reader.read();
      let isFirstChunk = true;
      (async () => {
        while (!fr[kAborted]) {
          try {
            const { done, value } = await chunkPromise;
            if (isFirstChunk && !fr[kAborted]) {
              queueMicrotask(() => {
                fireAProgressEvent("loadstart", fr);
              });
            }
            isFirstChunk = false;
            if (!done && types.isUint8Array(value)) {
              bytes.push(value);
              if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
                fr[kLastProgressEventFired] = Date.now();
                queueMicrotask(() => {
                  fireAProgressEvent("progress", fr);
                });
              }
              chunkPromise = reader.read();
            } else if (done) {
              queueMicrotask(() => {
                fr[kState] = "done";
                try {
                  const result = packageData(bytes, type, blob.type, encodingName);
                  if (fr[kAborted]) {
                    return;
                  }
                  fr[kResult] = result;
                  fireAProgressEvent("load", fr);
                } catch (error2) {
                  fr[kError] = error2;
                  fireAProgressEvent("error", fr);
                }
                if (fr[kState] !== "loading") {
                  fireAProgressEvent("loadend", fr);
                }
              });
              break;
            }
          } catch (error2) {
            if (fr[kAborted]) {
              return;
            }
            queueMicrotask(() => {
              fr[kState] = "done";
              fr[kError] = error2;
              fireAProgressEvent("error", fr);
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        }
      })();
    }
    function fireAProgressEvent(e2, reader) {
      const event = new ProgressEvent(e2, {
        bubbles: false,
        cancelable: false
      });
      reader.dispatchEvent(event);
    }
    function packageData(bytes, type, mimeType, encodingName) {
      switch (type) {
        case "DataURL": {
          let dataURL = "data:";
          const parsed = parseMIMEType(mimeType || "application/octet-stream");
          if (parsed !== "failure") {
            dataURL += serializeAMimeType(parsed);
          }
          dataURL += ";base64,";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            dataURL += btoa(decoder.write(chunk));
          }
          dataURL += btoa(decoder.end());
          return dataURL;
        }
        case "Text": {
          let encoding = "failure";
          if (encodingName) {
            encoding = getEncoding(encodingName);
          }
          if (encoding === "failure" && mimeType) {
            const type2 = parseMIMEType(mimeType);
            if (type2 !== "failure") {
              encoding = getEncoding(type2.parameters.get("charset"));
            }
          }
          if (encoding === "failure") {
            encoding = "UTF-8";
          }
          return decode(bytes, encoding);
        }
        case "ArrayBuffer": {
          const sequence = combineByteSequences(bytes);
          return sequence.buffer;
        }
        case "BinaryString": {
          let binaryString = "";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            binaryString += decoder.write(chunk);
          }
          binaryString += decoder.end();
          return binaryString;
        }
      }
    }
    function decode(ioQueue, encoding) {
      const bytes = combineByteSequences(ioQueue);
      const BOMEncoding = BOMSniffing(bytes);
      let slice = 0;
      if (BOMEncoding !== null) {
        encoding = BOMEncoding;
        slice = BOMEncoding === "UTF-8" ? 3 : 2;
      }
      const sliced = bytes.slice(slice);
      return new TextDecoder(encoding).decode(sliced);
    }
    function BOMSniffing(ioQueue) {
      const [a, b3, c3] = ioQueue;
      if (a === 239 && b3 === 187 && c3 === 191) {
        return "UTF-8";
      } else if (a === 254 && b3 === 255) {
        return "UTF-16BE";
      } else if (a === 255 && b3 === 254) {
        return "UTF-16LE";
      }
      return null;
    }
    function combineByteSequences(sequences) {
      const size = sequences.reduce((a, b3) => {
        return a + b3.byteLength;
      }, 0);
      let offset = 0;
      return sequences.reduce((a, b3) => {
        a.set(b3, offset);
        offset += b3.byteLength;
        return a;
      }, new Uint8Array(size));
    }
    module2.exports = {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/fileapi/filereader.js"(exports2, module2) {
    "use strict";
    var {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    } = require_util4();
    var {
      kState,
      kError,
      kResult,
      kEvents,
      kAborted
    } = require_symbols3();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var FileReader = class _FileReader extends EventTarget {
      constructor() {
        super();
        this[kState] = "empty";
        this[kResult] = null;
        this[kError] = null;
        this[kEvents] = {
          loadend: null,
          error: null,
          abort: null,
          load: null,
          progress: null,
          loadstart: null
        };
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
       * @param {import('buffer').Blob} blob
       */
      readAsArrayBuffer(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "ArrayBuffer");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsBinaryString
       * @param {import('buffer').Blob} blob
       */
      readAsBinaryString(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "BinaryString");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsDataText
       * @param {import('buffer').Blob} blob
       * @param {string?} encoding
       */
      readAsText(blob, encoding = void 0) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
        blob = webidl.converters.Blob(blob, { strict: false });
        if (encoding !== void 0) {
          encoding = webidl.converters.DOMString(encoding);
        }
        readOperation(this, blob, "Text", encoding);
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
       * @param {import('buffer').Blob} blob
       */
      readAsDataURL(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "DataURL");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-abort
       */
      abort() {
        if (this[kState] === "empty" || this[kState] === "done") {
          this[kResult] = null;
          return;
        }
        if (this[kState] === "loading") {
          this[kState] = "done";
          this[kResult] = null;
        }
        this[kAborted] = true;
        fireAProgressEvent("abort", this);
        if (this[kState] !== "loading") {
          fireAProgressEvent("loadend", this);
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
       */
      get readyState() {
        webidl.brandCheck(this, _FileReader);
        switch (this[kState]) {
          case "empty":
            return this.EMPTY;
          case "loading":
            return this.LOADING;
          case "done":
            return this.DONE;
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-result
       */
      get result() {
        webidl.brandCheck(this, _FileReader);
        return this[kResult];
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-error
       */
      get error() {
        webidl.brandCheck(this, _FileReader);
        return this[kError];
      }
      get onloadend() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadend;
      }
      set onloadend(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadend) {
          this.removeEventListener("loadend", this[kEvents].loadend);
        }
        if (typeof fn === "function") {
          this[kEvents].loadend = fn;
          this.addEventListener("loadend", fn);
        } else {
          this[kEvents].loadend = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].error) {
          this.removeEventListener("error", this[kEvents].error);
        }
        if (typeof fn === "function") {
          this[kEvents].error = fn;
          this.addEventListener("error", fn);
        } else {
          this[kEvents].error = null;
        }
      }
      get onloadstart() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadstart;
      }
      set onloadstart(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadstart) {
          this.removeEventListener("loadstart", this[kEvents].loadstart);
        }
        if (typeof fn === "function") {
          this[kEvents].loadstart = fn;
          this.addEventListener("loadstart", fn);
        } else {
          this[kEvents].loadstart = null;
        }
      }
      get onprogress() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].progress;
      }
      set onprogress(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].progress) {
          this.removeEventListener("progress", this[kEvents].progress);
        }
        if (typeof fn === "function") {
          this[kEvents].progress = fn;
          this.addEventListener("progress", fn);
        } else {
          this[kEvents].progress = null;
        }
      }
      get onload() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].load;
      }
      set onload(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].load) {
          this.removeEventListener("load", this[kEvents].load);
        }
        if (typeof fn === "function") {
          this[kEvents].load = fn;
          this.addEventListener("load", fn);
        } else {
          this[kEvents].load = null;
        }
      }
      get onabort() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].abort;
      }
      set onabort(fn) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].abort) {
          this.removeEventListener("abort", this[kEvents].abort);
        }
        if (typeof fn === "function") {
          this[kEvents].abort = fn;
          this.addEventListener("abort", fn);
        } else {
          this[kEvents].abort = null;
        }
      }
    };
    FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
    FileReader.LOADING = FileReader.prototype.LOADING = 1;
    FileReader.DONE = FileReader.prototype.DONE = 2;
    Object.defineProperties(FileReader.prototype, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors,
      readAsArrayBuffer: kEnumerableProperty,
      readAsBinaryString: kEnumerableProperty,
      readAsText: kEnumerableProperty,
      readAsDataURL: kEnumerableProperty,
      abort: kEnumerableProperty,
      readyState: kEnumerableProperty,
      result: kEnumerableProperty,
      error: kEnumerableProperty,
      onloadstart: kEnumerableProperty,
      onprogress: kEnumerableProperty,
      onload: kEnumerableProperty,
      onabort: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onloadend: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "FileReader",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(FileReader, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors
    });
    module2.exports = {
      FileReader
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/symbols.js
var require_symbols4 = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kConstruct: require_symbols().kConstruct
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/util.js
var require_util5 = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/util.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { URLSerializer } = require_dataURL();
    var { isValidHeaderName } = require_util2();
    function urlEquals(A, B, excludeFragment = false) {
      const serializedA = URLSerializer(A, excludeFragment);
      const serializedB = URLSerializer(B, excludeFragment);
      return serializedA === serializedB;
    }
    function fieldValues(header) {
      assert(header !== null);
      const values = [];
      for (let value of header.split(",")) {
        value = value.trim();
        if (!value.length) {
          continue;
        } else if (!isValidHeaderName(value)) {
          continue;
        }
        values.push(value);
      }
      return values;
    }
    module2.exports = {
      urlEquals,
      fieldValues
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/cache.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols4();
    var { urlEquals, fieldValues: getFieldValues } = require_util5();
    var { kEnumerableProperty, isDisturbed } = require_util();
    var { kHeadersList } = require_symbols();
    var { webidl } = require_webidl();
    var { Response, cloneResponse } = require_response();
    var { Request } = require_request2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { fetching } = require_fetch();
    var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2();
    var assert = require("assert");
    var { getGlobalDispatcher } = require_global2();
    var Cache = class _Cache {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
       * @type {requestResponseList}
       */
      #relevantRequestResponseList;
      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        this.#relevantRequestResponseList = arguments[1];
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        const p3 = await this.matchAll(request, options);
        if (p3.length === 0) {
          return;
        }
        return p3[0];
      }
      async matchAll(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        if (request !== void 0) request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r3 = null;
        if (request !== void 0) {
          if (request instanceof Request) {
            r3 = request[kState];
            if (r3.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r3 = new Request(request)[kState];
          }
        }
        const responses = [];
        if (request === void 0) {
          for (const requestResponse of this.#relevantRequestResponseList) {
            responses.push(requestResponse[1]);
          }
        } else {
          const requestResponses = this.#queryCache(r3, options);
          for (const requestResponse of requestResponses) {
            responses.push(requestResponse[1]);
          }
        }
        const responseList = [];
        for (const response of responses) {
          const responseObject = new Response(response.body?.source ?? null);
          const body = responseObject[kState].body;
          responseObject[kState] = response;
          responseObject[kState].body = body;
          responseObject[kHeaders][kHeadersList] = response.headersList;
          responseObject[kHeaders][kGuard] = "immutable";
          responseList.push(responseObject);
        }
        return Object.freeze(responseList);
      }
      async add(request) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
        request = webidl.converters.RequestInfo(request);
        const requests = [request];
        const responseArrayPromise = this.addAll(requests);
        return await responseArrayPromise;
      }
      async addAll(requests) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
        requests = webidl.converters["sequence<RequestInfo>"](requests);
        const responsePromises = [];
        const requestList = [];
        for (const request of requests) {
          if (typeof request === "string") {
            continue;
          }
          const r3 = request[kState];
          if (!urlIsHttpHttpsScheme(r3.url) || r3.method !== "GET") {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme when method is not GET."
            });
          }
        }
        const fetchControllers = [];
        for (const request of requests) {
          const r3 = new Request(request)[kState];
          if (!urlIsHttpHttpsScheme(r3.url)) {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme."
            });
          }
          r3.initiator = "fetch";
          r3.destination = "subresource";
          requestList.push(r3);
          const responsePromise = createDeferredPromise();
          fetchControllers.push(fetching({
            request: r3,
            dispatcher: getGlobalDispatcher(),
            processResponse(response) {
              if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
                responsePromise.reject(webidl.errors.exception({
                  header: "Cache.addAll",
                  message: "Received an invalid status code or the request failed."
                }));
              } else if (response.headersList.contains("vary")) {
                const fieldValues = getFieldValues(response.headersList.get("vary"));
                for (const fieldValue of fieldValues) {
                  if (fieldValue === "*") {
                    responsePromise.reject(webidl.errors.exception({
                      header: "Cache.addAll",
                      message: "invalid vary field value"
                    }));
                    for (const controller of fetchControllers) {
                      controller.abort();
                    }
                    return;
                  }
                }
              }
            },
            processResponseEndOfBody(response) {
              if (response.aborted) {
                responsePromise.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              responsePromise.resolve(response);
            }
          }));
          responsePromises.push(responsePromise.promise);
        }
        const p3 = Promise.all(responsePromises);
        const responses = await p3;
        const operations = [];
        let index = 0;
        for (const response of responses) {
          const operation = {
            type: "put",
            // 7.3.2
            request: requestList[index],
            // 7.3.3
            response
            // 7.3.4
          };
          operations.push(operation);
          index++;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e2) {
          errorData = e2;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(void 0);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async put(request, response) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
        request = webidl.converters.RequestInfo(request);
        response = webidl.converters.Response(response);
        let innerRequest = null;
        if (request instanceof Request) {
          innerRequest = request[kState];
        } else {
          innerRequest = new Request(request)[kState];
        }
        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Expected an http/s scheme when method is not GET"
          });
        }
        const innerResponse = response[kState];
        if (innerResponse.status === 206) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Got 206 status"
          });
        }
        if (innerResponse.headersList.contains("vary")) {
          const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
          for (const fieldValue of fieldValues) {
            if (fieldValue === "*") {
              throw webidl.errors.exception({
                header: "Cache.put",
                message: "Got * vary field value"
              });
            }
          }
        }
        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Response body is locked or disturbed"
          });
        }
        const clonedResponse = cloneResponse(innerResponse);
        const bodyReadPromise = createDeferredPromise();
        if (innerResponse.body != null) {
          const stream = innerResponse.body.stream;
          const reader = stream.getReader();
          readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
        } else {
          bodyReadPromise.resolve(void 0);
        }
        const operations = [];
        const operation = {
          type: "put",
          // 14.
          request: innerRequest,
          // 15.
          response: clonedResponse
          // 16.
        };
        operations.push(operation);
        const bytes = await bodyReadPromise.promise;
        if (clonedResponse.body != null) {
          clonedResponse.body.source = bytes;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          this.#batchCacheOperations(operations);
        } catch (e2) {
          errorData = e2;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve();
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async delete(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r3 = null;
        if (request instanceof Request) {
          r3 = request[kState];
          if (r3.method !== "GET" && !options.ignoreMethod) {
            return false;
          }
        } else {
          assert(typeof request === "string");
          r3 = new Request(request)[kState];
        }
        const operations = [];
        const operation = {
          type: "delete",
          request: r3,
          options
        };
        operations.push(operation);
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        let requestResponses;
        try {
          requestResponses = this.#batchCacheOperations(operations);
        } catch (e2) {
          errorData = e2;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(!!requestResponses?.length);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
       * @param {any} request
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @returns {readonly Request[]}
       */
      async keys(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        if (request !== void 0) request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r3 = null;
        if (request !== void 0) {
          if (request instanceof Request) {
            r3 = request[kState];
            if (r3.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r3 = new Request(request)[kState];
          }
        }
        const promise = createDeferredPromise();
        const requests = [];
        if (request === void 0) {
          for (const requestResponse of this.#relevantRequestResponseList) {
            requests.push(requestResponse[0]);
          }
        } else {
          const requestResponses = this.#queryCache(r3, options);
          for (const requestResponse of requestResponses) {
            requests.push(requestResponse[0]);
          }
        }
        queueMicrotask(() => {
          const requestList = [];
          for (const request2 of requests) {
            const requestObject = new Request("https://a");
            requestObject[kState] = request2;
            requestObject[kHeaders][kHeadersList] = request2.headersList;
            requestObject[kHeaders][kGuard] = "immutable";
            requestObject[kRealm] = request2.client;
            requestList.push(requestObject);
          }
          promise.resolve(Object.freeze(requestList));
        });
        return promise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
       * @param {CacheBatchOperation[]} operations
       * @returns {requestResponseList}
       */
      #batchCacheOperations(operations) {
        const cache = this.#relevantRequestResponseList;
        const backupCache = [...cache];
        const addedItems = [];
        const resultList = [];
        try {
          for (const operation of operations) {
            if (operation.type !== "delete" && operation.type !== "put") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: 'operation type does not match "delete" or "put"'
              });
            }
            if (operation.type === "delete" && operation.response != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "delete operation should not have an associated response"
              });
            }
            if (this.#queryCache(operation.request, operation.options, addedItems).length) {
              throw new DOMException("???", "InvalidStateError");
            }
            let requestResponses;
            if (operation.type === "delete") {
              requestResponses = this.#queryCache(operation.request, operation.options);
              if (requestResponses.length === 0) {
                return [];
              }
              for (const requestResponse of requestResponses) {
                const idx = cache.indexOf(requestResponse);
                assert(idx !== -1);
                cache.splice(idx, 1);
              }
            } else if (operation.type === "put") {
              if (operation.response == null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "put operation should have an associated response"
                });
              }
              const r3 = operation.request;
              if (!urlIsHttpHttpsScheme(r3.url)) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "expected http or https scheme"
                });
              }
              if (r3.method !== "GET") {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "not get method"
                });
              }
              if (operation.options != null) {
                throw webidl.errors.exception({
                  header: "Cache.#batchCacheOperations",
                  message: "options must not be defined"
                });
              }
              requestResponses = this.#queryCache(operation.request);
              for (const requestResponse of requestResponses) {
                const idx = cache.indexOf(requestResponse);
                assert(idx !== -1);
                cache.splice(idx, 1);
              }
              cache.push([operation.request, operation.response]);
              addedItems.push([operation.request, operation.response]);
            }
            resultList.push([operation.request, operation.response]);
          }
          return resultList;
        } catch (e2) {
          this.#relevantRequestResponseList.length = 0;
          this.#relevantRequestResponseList = backupCache;
          throw e2;
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#query-cache
       * @param {any} requestQuery
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @param {requestResponseList} targetStorage
       * @returns {requestResponseList}
       */
      #queryCache(requestQuery, options, targetStorage) {
        const resultList = [];
        const storage = targetStorage ?? this.#relevantRequestResponseList;
        for (const requestResponse of storage) {
          const [cachedRequest, cachedResponse] = requestResponse;
          if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
            resultList.push(requestResponse);
          }
        }
        return resultList;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
       * @param {any} requestQuery
       * @param {any} request
       * @param {any | null} response
       * @param {import('../../types/cache').CacheQueryOptions | undefined} options
       * @returns {boolean}
       */
      #requestMatchesCachedItem(requestQuery, request, response = null, options) {
        const queryURL = new URL(requestQuery.url);
        const cachedURL = new URL(request.url);
        if (options?.ignoreSearch) {
          cachedURL.search = "";
          queryURL.search = "";
        }
        if (!urlEquals(queryURL, cachedURL, true)) {
          return false;
        }
        if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) {
          return true;
        }
        const fieldValues = getFieldValues(response.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            return false;
          }
          const requestValue = request.headersList.get(fieldValue);
          const queryValue = requestQuery.headersList.get(fieldValue);
          if (requestValue !== queryValue) {
            return false;
          }
        }
        return true;
      }
    };
    Object.defineProperties(Cache.prototype, {
      [Symbol.toStringTag]: {
        value: "Cache",
        configurable: true
      },
      match: kEnumerableProperty,
      matchAll: kEnumerableProperty,
      add: kEnumerableProperty,
      addAll: kEnumerableProperty,
      put: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    var cacheQueryOptionConverters = [
      {
        key: "ignoreSearch",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreMethod",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreVary",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
    webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
      ...cacheQueryOptionConverters,
      {
        key: "cacheName",
        converter: webidl.converters.DOMString
      }
    ]);
    webidl.converters.Response = webidl.interfaceConverter(Response);
    webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
      webidl.converters.RequestInfo
    );
    module2.exports = {
      Cache
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cache/cachestorage.js"(exports2, module2) {
    "use strict";
    var { kConstruct } = require_symbols4();
    var { Cache } = require_cache();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var CacheStorage = class _CacheStorage {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
       * @type {Map<string, import('./cache').requestResponseList}
       */
      #caches = /* @__PURE__ */ new Map();
      constructor() {
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.MultiCacheQueryOptions(options);
        if (options.cacheName != null) {
          if (this.#caches.has(options.cacheName)) {
            const cacheList = this.#caches.get(options.cacheName);
            const cache = new Cache(kConstruct, cacheList);
            return await cache.match(request, options);
          }
        } else {
          for (const cacheList of this.#caches.values()) {
            const cache = new Cache(kConstruct, cacheList);
            const response = await cache.match(request, options);
            if (response !== void 0) {
              return response;
            }
          }
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async has(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
        cacheName = webidl.converters.DOMString(cacheName);
        return this.#caches.has(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
       * @param {string} cacheName
       * @returns {Promise<Cache>}
       */
      async open(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
        cacheName = webidl.converters.DOMString(cacheName);
        if (this.#caches.has(cacheName)) {
          const cache2 = this.#caches.get(cacheName);
          return new Cache(kConstruct, cache2);
        }
        const cache = [];
        this.#caches.set(cacheName, cache);
        return new Cache(kConstruct, cache);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async delete(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
        cacheName = webidl.converters.DOMString(cacheName);
        return this.#caches.delete(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
       * @returns {string[]}
       */
      async keys() {
        webidl.brandCheck(this, _CacheStorage);
        const keys = this.#caches.keys();
        return [...keys];
      }
    };
    Object.defineProperties(CacheStorage.prototype, {
      [Symbol.toStringTag]: {
        value: "CacheStorage",
        configurable: true
      },
      match: kEnumerableProperty,
      has: kEnumerableProperty,
      open: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    module2.exports = {
      CacheStorage
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/constants.js
var require_constants4 = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/constants.js"(exports2, module2) {
    "use strict";
    var maxAttributeValueSize = 1024;
    var maxNameValuePairSize = 4096;
    module2.exports = {
      maxAttributeValueSize,
      maxNameValuePairSize
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/util.js
var require_util6 = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/util.js"(exports2, module2) {
    "use strict";
    function isCTLExcludingHtab(value) {
      if (value.length === 0) {
        return false;
      }
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127) {
          return false;
        }
      }
    }
    function validateCookieName(name) {
      for (const char of name) {
        const code = char.charCodeAt(0);
        if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") {
          throw new Error("Invalid cookie name");
        }
      }
    }
    function validateCookieValue(value) {
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code < 33 || // exclude CTLs (0-31)
        code === 34 || code === 44 || code === 59 || code === 92 || code > 126) {
          throw new Error("Invalid header value");
        }
      }
    }
    function validateCookiePath(path2) {
      for (const char of path2) {
        const code = char.charCodeAt(0);
        if (code < 33 || char === ";") {
          throw new Error("Invalid cookie path");
        }
      }
    }
    function validateCookieDomain(domain) {
      if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
        throw new Error("Invalid cookie domain");
      }
    }
    function toIMFDate(date) {
      if (typeof date === "number") {
        date = new Date(date);
      }
      const days = [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ];
      const months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      const dayName = days[date.getUTCDay()];
      const day = date.getUTCDate().toString().padStart(2, "0");
      const month = months[date.getUTCMonth()];
      const year = date.getUTCFullYear();
      const hour = date.getUTCHours().toString().padStart(2, "0");
      const minute = date.getUTCMinutes().toString().padStart(2, "0");
      const second = date.getUTCSeconds().toString().padStart(2, "0");
      return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
    }
    function validateCookieMaxAge(maxAge) {
      if (maxAge < 0) {
        throw new Error("Invalid cookie max-age");
      }
    }
    function stringify(cookie) {
      if (cookie.name.length === 0) {
        return null;
      }
      validateCookieName(cookie.name);
      validateCookieValue(cookie.value);
      const out = [`${cookie.name}=${cookie.value}`];
      if (cookie.name.startsWith("__Secure-")) {
        cookie.secure = true;
      }
      if (cookie.name.startsWith("__Host-")) {
        cookie.secure = true;
        cookie.domain = null;
        cookie.path = "/";
      }
      if (cookie.secure) {
        out.push("Secure");
      }
      if (cookie.httpOnly) {
        out.push("HttpOnly");
      }
      if (typeof cookie.maxAge === "number") {
        validateCookieMaxAge(cookie.maxAge);
        out.push(`Max-Age=${cookie.maxAge}`);
      }
      if (cookie.domain) {
        validateCookieDomain(cookie.domain);
        out.push(`Domain=${cookie.domain}`);
      }
      if (cookie.path) {
        validateCookiePath(cookie.path);
        out.push(`Path=${cookie.path}`);
      }
      if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
        out.push(`Expires=${toIMFDate(cookie.expires)}`);
      }
      if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
      }
      for (const part of cookie.unparsed) {
        if (!part.includes("=")) {
          throw new Error("Invalid unparsed");
        }
        const [key, ...value] = part.split("=");
        out.push(`${key.trim()}=${value.join("=")}`);
      }
      return out.join("; ");
    }
    module2.exports = {
      isCTLExcludingHtab,
      validateCookieName,
      validateCookiePath,
      validateCookieValue,
      toIMFDate,
      stringify
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/parse.js"(exports2, module2) {
    "use strict";
    var { maxNameValuePairSize, maxAttributeValueSize } = require_constants4();
    var { isCTLExcludingHtab } = require_util6();
    var { collectASequenceOfCodePointsFast } = require_dataURL();
    var assert = require("assert");
    function parseSetCookie(header) {
      if (isCTLExcludingHtab(header)) {
        return null;
      }
      let nameValuePair = "";
      let unparsedAttributes = "";
      let name = "";
      let value = "";
      if (header.includes(";")) {
        const position = { position: 0 };
        nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
        unparsedAttributes = header.slice(position.position);
      } else {
        nameValuePair = header;
      }
      if (!nameValuePair.includes("=")) {
        value = nameValuePair;
      } else {
        const position = { position: 0 };
        name = collectASequenceOfCodePointsFast(
          "=",
          nameValuePair,
          position
        );
        value = nameValuePair.slice(position.position + 1);
      }
      name = name.trim();
      value = value.trim();
      if (name.length + value.length > maxNameValuePairSize) {
        return null;
      }
      return {
        name,
        value,
        ...parseUnparsedAttributes(unparsedAttributes)
      };
    }
    function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
      if (unparsedAttributes.length === 0) {
        return cookieAttributeList;
      }
      assert(unparsedAttributes[0] === ";");
      unparsedAttributes = unparsedAttributes.slice(1);
      let cookieAv = "";
      if (unparsedAttributes.includes(";")) {
        cookieAv = collectASequenceOfCodePointsFast(
          ";",
          unparsedAttributes,
          { position: 0 }
        );
        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
      } else {
        cookieAv = unparsedAttributes;
        unparsedAttributes = "";
      }
      let attributeName = "";
      let attributeValue = "";
      if (cookieAv.includes("=")) {
        const position = { position: 0 };
        attributeName = collectASequenceOfCodePointsFast(
          "=",
          cookieAv,
          position
        );
        attributeValue = cookieAv.slice(position.position + 1);
      } else {
        attributeName = cookieAv;
      }
      attributeName = attributeName.trim();
      attributeValue = attributeValue.trim();
      if (attributeValue.length > maxAttributeValueSize) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const attributeNameLowercase = attributeName.toLowerCase();
      if (attributeNameLowercase === "expires") {
        const expiryTime = new Date(attributeValue);
        cookieAttributeList.expires = expiryTime;
      } else if (attributeNameLowercase === "max-age") {
        const charCode = attributeValue.charCodeAt(0);
        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        if (!/^\d+$/.test(attributeValue)) {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        const deltaSeconds = Number(attributeValue);
        cookieAttributeList.maxAge = deltaSeconds;
      } else if (attributeNameLowercase === "domain") {
        let cookieDomain = attributeValue;
        if (cookieDomain[0] === ".") {
          cookieDomain = cookieDomain.slice(1);
        }
        cookieDomain = cookieDomain.toLowerCase();
        cookieAttributeList.domain = cookieDomain;
      } else if (attributeNameLowercase === "path") {
        let cookiePath = "";
        if (attributeValue.length === 0 || attributeValue[0] !== "/") {
          cookiePath = "/";
        } else {
          cookiePath = attributeValue;
        }
        cookieAttributeList.path = cookiePath;
      } else if (attributeNameLowercase === "secure") {
        cookieAttributeList.secure = true;
      } else if (attributeNameLowercase === "httponly") {
        cookieAttributeList.httpOnly = true;
      } else if (attributeNameLowercase === "samesite") {
        let enforcement = "Default";
        const attributeValueLowercase = attributeValue.toLowerCase();
        if (attributeValueLowercase.includes("none")) {
          enforcement = "None";
        }
        if (attributeValueLowercase.includes("strict")) {
          enforcement = "Strict";
        }
        if (attributeValueLowercase.includes("lax")) {
          enforcement = "Lax";
        }
        cookieAttributeList.sameSite = enforcement;
      } else {
        cookieAttributeList.unparsed ??= [];
        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
      }
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    module2.exports = {
      parseSetCookie,
      parseUnparsedAttributes
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/cookies/index.js"(exports2, module2) {
    "use strict";
    var { parseSetCookie } = require_parse();
    var { stringify } = require_util6();
    var { webidl } = require_webidl();
    var { Headers } = require_headers();
    function getCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookie = headers.get("cookie");
      const out = {};
      if (!cookie) {
        return out;
      }
      for (const piece of cookie.split(";")) {
        const [name, ...value] = piece.split("=");
        out[name.trim()] = value.join("=");
      }
      return out;
    }
    function deleteCookie(headers, name, attributes) {
      webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      name = webidl.converters.DOMString(name);
      attributes = webidl.converters.DeleteCookieAttributes(attributes);
      setCookie(headers, {
        name,
        value: "",
        expires: /* @__PURE__ */ new Date(0),
        ...attributes
      });
    }
    function getSetCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
      webidl.brandCheck(headers, Headers, { strict: false });
      const cookies = headers.getSetCookie();
      if (!cookies) {
        return [];
      }
      return cookies.map((pair) => parseSetCookie(pair));
    }
    function setCookie(headers, cookie) {
      webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
      webidl.brandCheck(headers, Headers, { strict: false });
      cookie = webidl.converters.Cookie(cookie);
      const str = stringify(cookie);
      if (str) {
        headers.append("Set-Cookie", stringify(cookie));
      }
    }
    webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      }
    ]);
    webidl.converters.Cookie = webidl.dictionaryConverter([
      {
        converter: webidl.converters.DOMString,
        key: "name"
      },
      {
        converter: webidl.converters.DOMString,
        key: "value"
      },
      {
        converter: webidl.nullableConverter((value) => {
          if (typeof value === "number") {
            return webidl.converters["unsigned long long"](value);
          }
          return new Date(value);
        }),
        key: "expires",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters["long long"]),
        key: "maxAge",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "secure",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "httpOnly",
        defaultValue: null
      },
      {
        converter: webidl.converters.USVString,
        key: "sameSite",
        allowedValues: ["Strict", "Lax", "None"]
      },
      {
        converter: webidl.sequenceConverter(webidl.converters.DOMString),
        key: "unparsed",
        defaultValue: []
      }
    ]);
    module2.exports = {
      getCookies,
      deleteCookie,
      getSetCookies,
      setCookie
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/constants.js
var require_constants5 = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/constants.js"(exports2, module2) {
    "use strict";
    var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    var states = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3
    };
    var opcodes = {
      CONTINUATION: 0,
      TEXT: 1,
      BINARY: 2,
      CLOSE: 8,
      PING: 9,
      PONG: 10
    };
    var maxUnsigned16Bit = 2 ** 16 - 1;
    var parserStates = {
      INFO: 0,
      PAYLOADLENGTH_16: 2,
      PAYLOADLENGTH_64: 3,
      READ_DATA: 4
    };
    var emptyBuffer = Buffer.allocUnsafe(0);
    module2.exports = {
      uid,
      staticPropertyDescriptors,
      states,
      opcodes,
      maxUnsigned16Bit,
      parserStates,
      emptyBuffer
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/symbols.js
var require_symbols5 = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kWebSocketURL: Symbol("url"),
      kReadyState: Symbol("ready state"),
      kController: Symbol("controller"),
      kResponse: Symbol("response"),
      kBinaryType: Symbol("binary type"),
      kSentClose: Symbol("sent close"),
      kReceivedClose: Symbol("received close"),
      kByteParser: Symbol("byte parser")
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/events.js
var require_events = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/events.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var { MessagePort } = require("worker_threads");
    var MessageEvent = class _MessageEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
        super(type, eventInitDict);
        this.#eventInit = eventInitDict;
      }
      get data() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.data;
      }
      get origin() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.origin;
      }
      get lastEventId() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.lastEventId;
      }
      get source() {
        webidl.brandCheck(this, _MessageEvent);
        return this.#eventInit.source;
      }
      get ports() {
        webidl.brandCheck(this, _MessageEvent);
        if (!Object.isFrozen(this.#eventInit.ports)) {
          Object.freeze(this.#eventInit.ports);
        }
        return this.#eventInit.ports;
      }
      initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
        webidl.brandCheck(this, _MessageEvent);
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
        return new _MessageEvent(type, {
          bubbles,
          cancelable,
          data,
          origin,
          lastEventId,
          source,
          ports
        });
      }
    };
    var CloseEvent = class _CloseEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
        super(type, eventInitDict);
        this.#eventInit = eventInitDict;
      }
      get wasClean() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.wasClean;
      }
      get code() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.code;
      }
      get reason() {
        webidl.brandCheck(this, _CloseEvent);
        return this.#eventInit.reason;
      }
    };
    var ErrorEvent = class _ErrorEvent extends Event {
      #eventInit;
      constructor(type, eventInitDict) {
        webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
        super(type, eventInitDict);
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
        this.#eventInit = eventInitDict;
      }
      get message() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.message;
      }
      get filename() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.filename;
      }
      get lineno() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.lineno;
      }
      get colno() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.colno;
      }
      get error() {
        webidl.brandCheck(this, _ErrorEvent);
        return this.#eventInit.error;
      }
    };
    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "MessageEvent",
        configurable: true
      },
      data: kEnumerableProperty,
      origin: kEnumerableProperty,
      lastEventId: kEnumerableProperty,
      source: kEnumerableProperty,
      ports: kEnumerableProperty,
      initMessageEvent: kEnumerableProperty
    });
    Object.defineProperties(CloseEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "CloseEvent",
        configurable: true
      },
      reason: kEnumerableProperty,
      code: kEnumerableProperty,
      wasClean: kEnumerableProperty
    });
    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "ErrorEvent",
        configurable: true
      },
      message: kEnumerableProperty,
      filename: kEnumerableProperty,
      lineno: kEnumerableProperty,
      colno: kEnumerableProperty,
      error: kEnumerableProperty
    });
    webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
    webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
      webidl.converters.MessagePort
    );
    var eventInit = [
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.MessageEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "data",
        converter: webidl.converters.any,
        defaultValue: null
      },
      {
        key: "origin",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lastEventId",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "source",
        // Node doesn't implement WindowProxy or ServiceWorker, so the only
        // valid value for source is a MessagePort.
        converter: webidl.nullableConverter(webidl.converters.MessagePort),
        defaultValue: null
      },
      {
        key: "ports",
        converter: webidl.converters["sequence<MessagePort>"],
        get defaultValue() {
          return [];
        }
      }
    ]);
    webidl.converters.CloseEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "wasClean",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "code",
        converter: webidl.converters["unsigned short"],
        defaultValue: 0
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: ""
      }
    ]);
    webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "message",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "filename",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lineno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "colno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "error",
        converter: webidl.converters.any
      }
    ]);
    module2.exports = {
      MessageEvent,
      CloseEvent,
      ErrorEvent
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/util.js
var require_util7 = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/util.js"(exports2, module2) {
    "use strict";
    var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5();
    var { states, opcodes } = require_constants5();
    var { MessageEvent, ErrorEvent } = require_events();
    function isEstablished(ws) {
      return ws[kReadyState] === states.OPEN;
    }
    function isClosing(ws) {
      return ws[kReadyState] === states.CLOSING;
    }
    function isClosed(ws) {
      return ws[kReadyState] === states.CLOSED;
    }
    function fireEvent(e2, target, eventConstructor = Event, eventInitDict) {
      const event = new eventConstructor(e2, eventInitDict);
      target.dispatchEvent(event);
    }
    function websocketMessageReceived(ws, type, data) {
      if (ws[kReadyState] !== states.OPEN) {
        return;
      }
      let dataForEvent;
      if (type === opcodes.TEXT) {
        try {
          dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
        } catch {
          failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
          return;
        }
      } else if (type === opcodes.BINARY) {
        if (ws[kBinaryType] === "blob") {
          dataForEvent = new Blob([data]);
        } else {
          dataForEvent = new Uint8Array(data).buffer;
        }
      }
      fireEvent("message", ws, MessageEvent, {
        origin: ws[kWebSocketURL].origin,
        data: dataForEvent
      });
    }
    function isValidSubprotocol(protocol) {
      if (protocol.length === 0) {
        return false;
      }
      for (const char of protocol) {
        const code = char.charCodeAt(0);
        if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || // SP
        code === 9) {
          return false;
        }
      }
      return true;
    }
    function isValidStatusCode(code) {
      if (code >= 1e3 && code < 1015) {
        return code !== 1004 && // reserved
        code !== 1005 && // "MUST NOT be set as a status code"
        code !== 1006;
      }
      return code >= 3e3 && code <= 4999;
    }
    function failWebsocketConnection(ws, reason) {
      const { [kController]: controller, [kResponse]: response } = ws;
      controller.abort();
      if (response?.socket && !response.socket.destroyed) {
        response.socket.destroy();
      }
      if (reason) {
        fireEvent("error", ws, ErrorEvent, {
          error: new Error(reason)
        });
      }
    }
    module2.exports = {
      isEstablished,
      isClosing,
      isClosed,
      fireEvent,
      isValidSubprotocol,
      isValidStatusCode,
      failWebsocketConnection,
      websocketMessageReceived
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/connection.js"(exports2, module2) {
    "use strict";
    var diagnosticsChannel = require("diagnostics_channel");
    var { uid, states } = require_constants5();
    var {
      kReadyState,
      kSentClose,
      kByteParser,
      kReceivedClose
    } = require_symbols5();
    var { fireEvent, failWebsocketConnection } = require_util7();
    var { CloseEvent } = require_events();
    var { makeRequest } = require_request2();
    var { fetching } = require_fetch();
    var { Headers } = require_headers();
    var { getGlobalDispatcher } = require_global2();
    var { kHeadersList } = require_symbols();
    var channels = {};
    channels.open = diagnosticsChannel.channel("undici:websocket:open");
    channels.close = diagnosticsChannel.channel("undici:websocket:close");
    channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
    var crypto;
    try {
      crypto = require("crypto");
    } catch {
    }
    function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {
      const requestURL = url;
      requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
      const request = makeRequest({
        urlList: [requestURL],
        serviceWorkers: "none",
        referrer: "no-referrer",
        mode: "websocket",
        credentials: "include",
        cache: "no-store",
        redirect: "error"
      });
      if (options.headers) {
        const headersList = new Headers(options.headers)[kHeadersList];
        request.headersList = headersList;
      }
      const keyValue = crypto.randomBytes(16).toString("base64");
      request.headersList.append("sec-websocket-key", keyValue);
      request.headersList.append("sec-websocket-version", "13");
      for (const protocol of protocols) {
        request.headersList.append("sec-websocket-protocol", protocol);
      }
      const permessageDeflate = "";
      const controller = fetching({
        request,
        useParallelQueue: true,
        dispatcher: options.dispatcher ?? getGlobalDispatcher(),
        processResponse(response) {
          if (response.type === "error" || response.status !== 101) {
            failWebsocketConnection(ws, "Received network error or non-101 status code.");
            return;
          }
          if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Server did not respond with sent protocols.");
            return;
          }
          if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
          const digest = crypto.createHash("sha1").update(keyValue + uid).digest("base64");
          if (secWSAccept !== digest) {
            failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
          if (secExtension !== null && secExtension !== permessageDeflate) {
            failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
            return;
          }
          const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
          if (secProtocol !== null && secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
            return;
          }
          response.socket.on("data", onSocketData);
          response.socket.on("close", onSocketClose);
          response.socket.on("error", onSocketError);
          if (channels.open.hasSubscribers) {
            channels.open.publish({
              address: response.socket.address(),
              protocol: secProtocol,
              extensions: secExtension
            });
          }
          onEstablish(response);
        }
      });
      return controller;
    }
    function onSocketData(chunk) {
      if (!this.ws[kByteParser].write(chunk)) {
        this.pause();
      }
    }
    function onSocketClose() {
      const { ws } = this;
      const wasClean = ws[kSentClose] && ws[kReceivedClose];
      let code = 1005;
      let reason = "";
      const result = ws[kByteParser].closingInfo;
      if (result) {
        code = result.code ?? 1005;
        reason = result.reason;
      } else if (!ws[kSentClose]) {
        code = 1006;
      }
      ws[kReadyState] = states.CLOSED;
      fireEvent("close", ws, CloseEvent, {
        wasClean,
        code,
        reason
      });
      if (channels.close.hasSubscribers) {
        channels.close.publish({
          websocket: ws,
          code,
          reason
        });
      }
    }
    function onSocketError(error2) {
      const { ws } = this;
      ws[kReadyState] = states.CLOSING;
      if (channels.socketError.hasSubscribers) {
        channels.socketError.publish(error2);
      }
      this.destroy();
    }
    module2.exports = {
      establishWebSocketConnection
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/frame.js"(exports2, module2) {
    "use strict";
    var { maxUnsigned16Bit } = require_constants5();
    var crypto;
    try {
      crypto = require("crypto");
    } catch {
    }
    var WebsocketFrameSend = class {
      /**
       * @param {Buffer|undefined} data
       */
      constructor(data) {
        this.frameData = data;
        this.maskKey = crypto.randomBytes(4);
      }
      createFrame(opcode) {
        const bodyLength = this.frameData?.byteLength ?? 0;
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const buffer = Buffer.allocUnsafe(bodyLength + offset);
        buffer[0] = buffer[1] = 0;
        buffer[0] |= 128;
        buffer[0] = (buffer[0] & 240) + opcode;
        buffer[offset - 4] = this.maskKey[0];
        buffer[offset - 3] = this.maskKey[1];
        buffer[offset - 2] = this.maskKey[2];
        buffer[offset - 1] = this.maskKey[3];
        buffer[1] = payloadLength;
        if (payloadLength === 126) {
          buffer.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          buffer[2] = buffer[3] = 0;
          buffer.writeUIntBE(bodyLength, 4, 6);
        }
        buffer[1] |= 128;
        for (let i3 = 0; i3 < bodyLength; i3++) {
          buffer[offset + i3] = this.frameData[i3] ^ this.maskKey[i3 % 4];
        }
        return buffer;
      }
    };
    module2.exports = {
      WebsocketFrameSend
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var diagnosticsChannel = require("diagnostics_channel");
    var { parserStates, opcodes, states, emptyBuffer } = require_constants5();
    var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
    var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util7();
    var { WebsocketFrameSend } = require_frame();
    var channels = {};
    channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
    channels.pong = diagnosticsChannel.channel("undici:websocket:pong");
    var ByteParser = class extends Writable {
      #buffers = [];
      #byteOffset = 0;
      #state = parserStates.INFO;
      #info = {};
      #fragments = [];
      constructor(ws) {
        super();
        this.ws = ws;
      }
      /**
       * @param {Buffer} chunk
       * @param {() => void} callback
       */
      _write(chunk, _, callback) {
        this.#buffers.push(chunk);
        this.#byteOffset += chunk.length;
        this.run(callback);
      }
      /**
       * Runs whenever a new chunk is received.
       * Callback is called whenever there are no more chunks buffering,
       * or not enough bytes are buffered to parse.
       */
      run(callback) {
        while (true) {
          if (this.#state === parserStates.INFO) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            this.#info.fin = (buffer[0] & 128) !== 0;
            this.#info.opcode = buffer[0] & 15;
            this.#info.originalOpcode ??= this.#info.opcode;
            this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;
            if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
              failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
              return;
            }
            const payloadLength = buffer[1] & 127;
            if (payloadLength <= 125) {
              this.#info.payloadLength = payloadLength;
              this.#state = parserStates.READ_DATA;
            } else if (payloadLength === 126) {
              this.#state = parserStates.PAYLOADLENGTH_16;
            } else if (payloadLength === 127) {
              this.#state = parserStates.PAYLOADLENGTH_64;
            }
            if (this.#info.fragmented && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
              return;
            } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
              return;
            } else if (this.#info.opcode === opcodes.CLOSE) {
              if (payloadLength === 1) {
                failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
                return;
              }
              const body = this.consume(payloadLength);
              this.#info.closeInfo = this.parseCloseBody(false, body);
              if (!this.ws[kSentClose]) {
                const body2 = Buffer.allocUnsafe(2);
                body2.writeUInt16BE(this.#info.closeInfo.code, 0);
                const closeFrame = new WebsocketFrameSend(body2);
                this.ws[kResponse].socket.write(
                  closeFrame.createFrame(opcodes.CLOSE),
                  (err) => {
                    if (!err) {
                      this.ws[kSentClose] = true;
                    }
                  }
                );
              }
              this.ws[kReadyState] = states.CLOSING;
              this.ws[kReceivedClose] = true;
              this.end();
              return;
            } else if (this.#info.opcode === opcodes.PING) {
              const body = this.consume(payloadLength);
              if (!this.ws[kReceivedClose]) {
                const frame = new WebsocketFrameSend(body);
                this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
                if (channels.ping.hasSubscribers) {
                  channels.ping.publish({
                    payload: body
                  });
                }
              }
              this.#state = parserStates.INFO;
              if (this.#byteOffset > 0) {
                continue;
              } else {
                callback();
                return;
              }
            } else if (this.#info.opcode === opcodes.PONG) {
              const body = this.consume(payloadLength);
              if (channels.pong.hasSubscribers) {
                channels.pong.publish({
                  payload: body
                });
              }
              if (this.#byteOffset > 0) {
                continue;
              } else {
                callback();
                return;
              }
            }
          } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
            if (this.#byteOffset < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            this.#info.payloadLength = buffer.readUInt16BE(0);
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
            if (this.#byteOffset < 8) {
              return callback();
            }
            const buffer = this.consume(8);
            const upper = buffer.readUInt32BE(0);
            if (upper > 2 ** 31 - 1) {
              failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
              return;
            }
            const lower = buffer.readUInt32BE(4);
            this.#info.payloadLength = (upper << 8) + lower;
            this.#state = parserStates.READ_DATA;
          } else if (this.#state === parserStates.READ_DATA) {
            if (this.#byteOffset < this.#info.payloadLength) {
              return callback();
            } else if (this.#byteOffset >= this.#info.payloadLength) {
              const body = this.consume(this.#info.payloadLength);
              this.#fragments.push(body);
              if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {
                const fullMessage = Buffer.concat(this.#fragments);
                websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
                this.#info = {};
                this.#fragments.length = 0;
              }
              this.#state = parserStates.INFO;
            }
          }
          if (this.#byteOffset > 0) {
            continue;
          } else {
            callback();
            break;
          }
        }
      }
      /**
       * Take n bytes from the buffered Buffers
       * @param {number} n
       * @returns {Buffer|null}
       */
      consume(n3) {
        if (n3 > this.#byteOffset) {
          return null;
        } else if (n3 === 0) {
          return emptyBuffer;
        }
        if (this.#buffers[0].length === n3) {
          this.#byteOffset -= this.#buffers[0].length;
          return this.#buffers.shift();
        }
        const buffer = Buffer.allocUnsafe(n3);
        let offset = 0;
        while (offset !== n3) {
          const next = this.#buffers[0];
          const { length } = next;
          if (length + offset === n3) {
            buffer.set(this.#buffers.shift(), offset);
            break;
          } else if (length + offset > n3) {
            buffer.set(next.subarray(0, n3 - offset), offset);
            this.#buffers[0] = next.subarray(n3 - offset);
            break;
          } else {
            buffer.set(this.#buffers.shift(), offset);
            offset += next.length;
          }
        }
        this.#byteOffset -= n3;
        return buffer;
      }
      parseCloseBody(onlyCode, data) {
        let code;
        if (data.length >= 2) {
          code = data.readUInt16BE(0);
        }
        if (onlyCode) {
          if (!isValidStatusCode(code)) {
            return null;
          }
          return { code };
        }
        let reason = data.subarray(2);
        if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
          reason = reason.subarray(3);
        }
        if (code !== void 0 && !isValidStatusCode(code)) {
          return null;
        }
        try {
          reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
        } catch {
          return null;
        }
        return { code, reason };
      }
      get closingInfo() {
        return this.#info.closeInfo;
      }
    };
    module2.exports = {
      ByteParser
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/lib/websocket/websocket.js"(exports2, module2) {
    "use strict";
    var { webidl } = require_webidl();
    var { DOMException: DOMException2 } = require_constants2();
    var { URLSerializer } = require_dataURL();
    var { getGlobalOrigin } = require_global();
    var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants5();
    var {
      kWebSocketURL,
      kReadyState,
      kController,
      kBinaryType,
      kResponse,
      kSentClose,
      kByteParser
    } = require_symbols5();
    var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util7();
    var { establishWebSocketConnection } = require_connection();
    var { WebsocketFrameSend } = require_frame();
    var { ByteParser } = require_receiver();
    var { kEnumerableProperty, isBlobLike } = require_util();
    var { getGlobalDispatcher } = require_global2();
    var { types } = require("util");
    var experimentalWarned = false;
    var WebSocket = class _WebSocket extends EventTarget {
      #events = {
        open: null,
        error: null,
        close: null,
        message: null
      };
      #bufferedAmount = 0;
      #protocol = "";
      #extensions = "";
      /**
       * @param {string} url
       * @param {string|string[]} protocols
       */
      constructor(url, protocols = []) {
        super();
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
        if (!experimentalWarned) {
          experimentalWarned = true;
          process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
            code: "UNDICI-WS"
          });
        }
        const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
        url = webidl.converters.USVString(url);
        protocols = options.protocols;
        const baseURL = getGlobalOrigin();
        let urlRecord;
        try {
          urlRecord = new URL(url, baseURL);
        } catch (e2) {
          throw new DOMException2(e2, "SyntaxError");
        }
        if (urlRecord.protocol === "http:") {
          urlRecord.protocol = "ws:";
        } else if (urlRecord.protocol === "https:") {
          urlRecord.protocol = "wss:";
        }
        if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
          throw new DOMException2(
            `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
            "SyntaxError"
          );
        }
        if (urlRecord.hash || urlRecord.href.endsWith("#")) {
          throw new DOMException2("Got fragment", "SyntaxError");
        }
        if (typeof protocols === "string") {
          protocols = [protocols];
        }
        if (protocols.length !== new Set(protocols.map((p3) => p3.toLowerCase())).size) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (protocols.length > 0 && !protocols.every((p3) => isValidSubprotocol(p3))) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this[kWebSocketURL] = new URL(urlRecord.href);
        this[kController] = establishWebSocketConnection(
          urlRecord,
          protocols,
          this,
          (response) => this.#onConnectionEstablished(response),
          options
        );
        this[kReadyState] = _WebSocket.CONNECTING;
        this[kBinaryType] = "blob";
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-close
       * @param {number|undefined} code
       * @param {string|undefined} reason
       */
      close(code = void 0, reason = void 0) {
        webidl.brandCheck(this, _WebSocket);
        if (code !== void 0) {
          code = webidl.converters["unsigned short"](code, { clamp: true });
        }
        if (reason !== void 0) {
          reason = webidl.converters.USVString(reason);
        }
        if (code !== void 0) {
          if (code !== 1e3 && (code < 3e3 || code > 4999)) {
            throw new DOMException2("invalid code", "InvalidAccessError");
          }
        }
        let reasonByteLength = 0;
        if (reason !== void 0) {
          reasonByteLength = Buffer.byteLength(reason);
          if (reasonByteLength > 123) {
            throw new DOMException2(
              `Reason must be less than 123 bytes; received ${reasonByteLength}`,
              "SyntaxError"
            );
          }
        }
        if (this[kReadyState] === _WebSocket.CLOSING || this[kReadyState] === _WebSocket.CLOSED) {
        } else if (!isEstablished(this)) {
          failWebsocketConnection(this, "Connection was closed before it was established.");
          this[kReadyState] = _WebSocket.CLOSING;
        } else if (!isClosing(this)) {
          const frame = new WebsocketFrameSend();
          if (code !== void 0 && reason === void 0) {
            frame.frameData = Buffer.allocUnsafe(2);
            frame.frameData.writeUInt16BE(code, 0);
          } else if (code !== void 0 && reason !== void 0) {
            frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
            frame.frameData.writeUInt16BE(code, 0);
            frame.frameData.write(reason, 2, "utf-8");
          } else {
            frame.frameData = emptyBuffer;
          }
          const socket = this[kResponse].socket;
          socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
            if (!err) {
              this[kSentClose] = true;
            }
          });
          this[kReadyState] = states.CLOSING;
        } else {
          this[kReadyState] = _WebSocket.CLOSING;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-send
       * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
       */
      send(data) {
        webidl.brandCheck(this, _WebSocket);
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
        data = webidl.converters.WebSocketSendData(data);
        if (this[kReadyState] === _WebSocket.CONNECTING) {
          throw new DOMException2("Sent before connected.", "InvalidStateError");
        }
        if (!isEstablished(this) || isClosing(this)) {
          return;
        }
        const socket = this[kResponse].socket;
        if (typeof data === "string") {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.TEXT);
          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        } else if (types.isArrayBuffer(data)) {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        } else if (ArrayBuffer.isView(data)) {
          const ab = Buffer.from(data, data.byteOffset, data.byteLength);
          const frame = new WebsocketFrameSend(ab);
          const buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += ab.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= ab.byteLength;
          });
        } else if (isBlobLike(data)) {
          const frame = new WebsocketFrameSend();
          data.arrayBuffer().then((ab) => {
            const value = Buffer.from(ab);
            frame.frameData = value;
            const buffer = frame.createFrame(opcodes.BINARY);
            this.#bufferedAmount += value.byteLength;
            socket.write(buffer, () => {
              this.#bufferedAmount -= value.byteLength;
            });
          });
        }
      }
      get readyState() {
        webidl.brandCheck(this, _WebSocket);
        return this[kReadyState];
      }
      get bufferedAmount() {
        webidl.brandCheck(this, _WebSocket);
        return this.#bufferedAmount;
      }
      get url() {
        webidl.brandCheck(this, _WebSocket);
        return URLSerializer(this[kWebSocketURL]);
      }
      get extensions() {
        webidl.brandCheck(this, _WebSocket);
        return this.#extensions;
      }
      get protocol() {
        webidl.brandCheck(this, _WebSocket);
        return this.#protocol;
      }
      get onopen() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.open;
      }
      set onopen(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.open) {
          this.removeEventListener("open", this.#events.open);
        }
        if (typeof fn === "function") {
          this.#events.open = fn;
          this.addEventListener("open", fn);
        } else {
          this.#events.open = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.error;
      }
      set onerror(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.error) {
          this.removeEventListener("error", this.#events.error);
        }
        if (typeof fn === "function") {
          this.#events.error = fn;
          this.addEventListener("error", fn);
        } else {
          this.#events.error = null;
        }
      }
      get onclose() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.close;
      }
      set onclose(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.close) {
          this.removeEventListener("close", this.#events.close);
        }
        if (typeof fn === "function") {
          this.#events.close = fn;
          this.addEventListener("close", fn);
        } else {
          this.#events.close = null;
        }
      }
      get onmessage() {
        webidl.brandCheck(this, _WebSocket);
        return this.#events.message;
      }
      set onmessage(fn) {
        webidl.brandCheck(this, _WebSocket);
        if (this.#events.message) {
          this.removeEventListener("message", this.#events.message);
        }
        if (typeof fn === "function") {
          this.#events.message = fn;
          this.addEventListener("message", fn);
        } else {
          this.#events.message = null;
        }
      }
      get binaryType() {
        webidl.brandCheck(this, _WebSocket);
        return this[kBinaryType];
      }
      set binaryType(type) {
        webidl.brandCheck(this, _WebSocket);
        if (type !== "blob" && type !== "arraybuffer") {
          this[kBinaryType] = "blob";
        } else {
          this[kBinaryType] = type;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
       */
      #onConnectionEstablished(response) {
        this[kResponse] = response;
        const parser = new ByteParser(this);
        parser.on("drain", function onParserDrain() {
          this.ws[kResponse].socket.resume();
        });
        response.socket.ws = this;
        this[kByteParser] = parser;
        this[kReadyState] = states.OPEN;
        const extensions = response.headersList.get("sec-websocket-extensions");
        if (extensions !== null) {
          this.#extensions = extensions;
        }
        const protocol = response.headersList.get("sec-websocket-protocol");
        if (protocol !== null) {
          this.#protocol = protocol;
        }
        fireEvent("open", this);
      }
    };
    WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
    WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
    WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
    WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
    Object.defineProperties(WebSocket.prototype, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
      url: kEnumerableProperty,
      readyState: kEnumerableProperty,
      bufferedAmount: kEnumerableProperty,
      onopen: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onclose: kEnumerableProperty,
      close: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      binaryType: kEnumerableProperty,
      send: kEnumerableProperty,
      extensions: kEnumerableProperty,
      protocol: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocket",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(WebSocket, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors
    });
    webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
      webidl.converters.DOMString
    );
    webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
      if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) {
        return webidl.converters["sequence<DOMString>"](V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.WebSocketInit = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.converters["DOMString or sequence<DOMString>"],
        get defaultValue() {
          return [];
        }
      },
      {
        key: "dispatcher",
        converter: (V) => V,
        get defaultValue() {
          return getGlobalDispatcher();
        }
      },
      {
        key: "headers",
        converter: webidl.nullableConverter(webidl.converters.HeadersInit)
      }
    ]);
    webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
      if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
        return webidl.converters.WebSocketInit(V);
      }
      return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
    };
    webidl.converters.WebSocketSendData = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
          return webidl.converters.BufferSource(V);
        }
      }
      return webidl.converters.USVString(V);
    };
    module2.exports = {
      WebSocket
    };
  }
});

// ../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/index.js
var require_undici = __commonJS({
  "../../node_modules/.pnpm/undici@5.29.0/node_modules/undici/index.js"(exports2, module2) {
    "use strict";
    var Client = require_client();
    var Dispatcher = require_dispatcher();
    var errors = require_errors();
    var Pool = require_pool();
    var BalancedPool = require_balanced_pool();
    var Agent = require_agent();
    var util = require_util();
    var { InvalidArgumentError } = errors;
    var api = require_api();
    var buildConnector = require_connect();
    var MockClient = require_mock_client();
    var MockAgent = require_mock_agent();
    var MockPool = require_mock_pool();
    var mockErrors = require_mock_errors();
    var ProxyAgent = require_proxy_agent();
    var RetryHandler = require_RetryHandler();
    var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
    var DecoratorHandler = require_DecoratorHandler();
    var RedirectHandler = require_RedirectHandler();
    var createRedirectInterceptor = require_redirectInterceptor();
    var hasCrypto;
    try {
      require("crypto");
      hasCrypto = true;
    } catch {
      hasCrypto = false;
    }
    Object.assign(Dispatcher.prototype, api);
    module2.exports.Dispatcher = Dispatcher;
    module2.exports.Client = Client;
    module2.exports.Pool = Pool;
    module2.exports.BalancedPool = BalancedPool;
    module2.exports.Agent = Agent;
    module2.exports.ProxyAgent = ProxyAgent;
    module2.exports.RetryHandler = RetryHandler;
    module2.exports.DecoratorHandler = DecoratorHandler;
    module2.exports.RedirectHandler = RedirectHandler;
    module2.exports.createRedirectInterceptor = createRedirectInterceptor;
    module2.exports.buildConnector = buildConnector;
    module2.exports.errors = errors;
    function makeDispatcher(fn) {
      return (url, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }
        if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
          throw new InvalidArgumentError("invalid url");
        }
        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }
          let path2 = opts.path;
          if (!opts.path.startsWith("/")) {
            path2 = `/${path2}`;
          }
          url = new URL(util.parseOrigin(url).origin + path2);
        } else {
          if (!opts) {
            opts = typeof url === "object" ? url : {};
          }
          url = util.parseURL(url);
        }
        const { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent) {
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        }
        return fn.call(dispatcher, {
          ...opts,
          origin: url.origin,
          path: url.search ? `${url.pathname}${url.search}` : url.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module2.exports.setGlobalDispatcher = setGlobalDispatcher;
    module2.exports.getGlobalDispatcher = getGlobalDispatcher;
    if (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {
      let fetchImpl = null;
      module2.exports.fetch = async function fetch(resource) {
        if (!fetchImpl) {
          fetchImpl = require_fetch().fetch;
        }
        try {
          return await fetchImpl(...arguments);
        } catch (err) {
          if (typeof err === "object") {
            Error.captureStackTrace(err, this);
          }
          throw err;
        }
      };
      module2.exports.Headers = require_headers().Headers;
      module2.exports.Response = require_response().Response;
      module2.exports.Request = require_request2().Request;
      module2.exports.FormData = require_formdata().FormData;
      module2.exports.File = require_file().File;
      module2.exports.FileReader = require_filereader().FileReader;
      const { setGlobalOrigin, getGlobalOrigin } = require_global();
      module2.exports.setGlobalOrigin = setGlobalOrigin;
      module2.exports.getGlobalOrigin = getGlobalOrigin;
      const { CacheStorage } = require_cachestorage();
      const { kConstruct } = require_symbols4();
      module2.exports.caches = new CacheStorage(kConstruct);
    }
    if (util.nodeMajor >= 16) {
      const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
      module2.exports.deleteCookie = deleteCookie;
      module2.exports.getCookies = getCookies;
      module2.exports.getSetCookies = getSetCookies;
      module2.exports.setCookie = setCookie;
      const { parseMIMEType, serializeAMimeType } = require_dataURL();
      module2.exports.parseMIMEType = parseMIMEType;
      module2.exports.serializeAMimeType = serializeAMimeType;
    }
    if (util.nodeMajor >= 18 && hasCrypto) {
      const { WebSocket } = require_websocket();
      module2.exports.WebSocket = WebSocket;
    }
    module2.exports.request = makeDispatcher(api.request);
    module2.exports.stream = makeDispatcher(api.stream);
    module2.exports.pipeline = makeDispatcher(api.pipeline);
    module2.exports.connect = makeDispatcher(api.connect);
    module2.exports.upgrade = makeDispatcher(api.upgrade);
    module2.exports.MockClient = MockClient;
    module2.exports.MockPool = MockPool;
    module2.exports.MockAgent = MockAgent;
    module2.exports.mockErrors = mockErrors;
  }
});

// ../../node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      o[k22] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v3) {
      Object.defineProperty(o, "default", { enumerable: true, value: v3 });
    } : function(o, v3) {
      o["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpClient = exports2.isHttps = exports2.HttpClientResponse = exports2.HttpClientError = exports2.getProxyUrl = exports2.MediaTypes = exports2.Headers = exports2.HttpCodes = void 0;
    var http = __importStar(require("http"));
    var https = __importStar(require("https"));
    var pm = __importStar(require_proxy());
    var tunnel = __importStar(require_tunnel2());
    var undici_1 = require_undici();
    var HttpCodes;
    (function(HttpCodes2) {
      HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
      HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
      HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
      HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
      HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
      HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
      HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
      HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
      HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
      HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
      HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
      HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
      HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
      HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
      HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
      HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
      HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
      HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
      HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
      HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
      HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
      HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
      HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
      HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(HttpCodes || (exports2.HttpCodes = HttpCodes = {}));
    var Headers;
    (function(Headers2) {
      Headers2["Accept"] = "accept";
      Headers2["ContentType"] = "content-type";
    })(Headers || (exports2.Headers = Headers = {}));
    var MediaTypes;
    (function(MediaTypes2) {
      MediaTypes2["ApplicationJson"] = "application/json";
    })(MediaTypes || (exports2.MediaTypes = MediaTypes = {}));
    function getProxyUrl(serverUrl) {
      const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
      return proxyUrl ? proxyUrl.href : "";
    }
    exports2.getProxyUrl = getProxyUrl;
    var HttpRedirectCodes = [
      HttpCodes.MovedPermanently,
      HttpCodes.ResourceMoved,
      HttpCodes.SeeOther,
      HttpCodes.TemporaryRedirect,
      HttpCodes.PermanentRedirect
    ];
    var HttpResponseRetryCodes = [
      HttpCodes.BadGateway,
      HttpCodes.ServiceUnavailable,
      HttpCodes.GatewayTimeout
    ];
    var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
    var ExponentialBackoffCeiling = 10;
    var ExponentialBackoffTimeSlice = 5;
    var HttpClientError = class _HttpClientError extends Error {
      constructor(message, statusCode) {
        super(message);
        this.name = "HttpClientError";
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, _HttpClientError.prototype);
      }
    };
    exports2.HttpClientError = HttpClientError;
    var HttpClientResponse = class {
      constructor(message) {
        this.message = message;
      }
      readBody() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve2) => __awaiter(this, void 0, void 0, function* () {
            let output = Buffer.alloc(0);
            this.message.on("data", (chunk) => {
              output = Buffer.concat([output, chunk]);
            });
            this.message.on("end", () => {
              resolve2(output.toString());
            });
          }));
        });
      }
      readBodyBuffer() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve2) => __awaiter(this, void 0, void 0, function* () {
            const chunks = [];
            this.message.on("data", (chunk) => {
              chunks.push(chunk);
            });
            this.message.on("end", () => {
              resolve2(Buffer.concat(chunks));
            });
          }));
        });
      }
    };
    exports2.HttpClientResponse = HttpClientResponse;
    function isHttps(requestUrl) {
      const parsedUrl = new URL(requestUrl);
      return parsedUrl.protocol === "https:";
    }
    exports2.isHttps = isHttps;
    var HttpClient = class {
      constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
          if (requestOptions.ignoreSslError != null) {
            this._ignoreSslError = requestOptions.ignoreSslError;
          }
          this._socketTimeout = requestOptions.socketTimeout;
          if (requestOptions.allowRedirects != null) {
            this._allowRedirects = requestOptions.allowRedirects;
          }
          if (requestOptions.allowRedirectDowngrade != null) {
            this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
          }
          if (requestOptions.maxRedirects != null) {
            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
          }
          if (requestOptions.keepAlive != null) {
            this._keepAlive = requestOptions.keepAlive;
          }
          if (requestOptions.allowRetries != null) {
            this._allowRetries = requestOptions.allowRetries;
          }
          if (requestOptions.maxRetries != null) {
            this._maxRetries = requestOptions.maxRetries;
          }
        }
      }
      options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
        });
      }
      get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("GET", requestUrl, null, additionalHeaders || {});
        });
      }
      del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("DELETE", requestUrl, null, additionalHeaders || {});
        });
      }
      post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("POST", requestUrl, data, additionalHeaders || {});
        });
      }
      patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PATCH", requestUrl, data, additionalHeaders || {});
        });
      }
      put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PUT", requestUrl, data, additionalHeaders || {});
        });
      }
      head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("HEAD", requestUrl, null, additionalHeaders || {});
        });
      }
      sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request(verb, requestUrl, stream, additionalHeaders);
        });
      }
      /**
       * Gets a typed object from an endpoint
       * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
       */
      getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          const res = yield this.get(requestUrl, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.post(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.put(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.patch(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      /**
       * Makes a raw http request.
       * All other methods such as get, post, patch, and request ultimately call this.
       * Prefer get, del, post and patch
       */
      request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._disposed) {
            throw new Error("Client has already been disposed.");
          }
          const parsedUrl = new URL(requestUrl);
          let info2 = this._prepareRequest(verb, parsedUrl, headers);
          const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
          let numTries = 0;
          let response;
          do {
            response = yield this.requestRaw(info2, data);
            if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
              let authenticationHandler;
              for (const handler of this.handlers) {
                if (handler.canHandleAuthentication(response)) {
                  authenticationHandler = handler;
                  break;
                }
              }
              if (authenticationHandler) {
                return authenticationHandler.handleAuthentication(this, info2, data);
              } else {
                return response;
              }
            }
            let redirectsRemaining = this._maxRedirects;
            while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
              const redirectUrl = response.message.headers["location"];
              if (!redirectUrl) {
                break;
              }
              const parsedRedirectUrl = new URL(redirectUrl);
              if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
                throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
              }
              yield response.readBody();
              if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                for (const header in headers) {
                  if (header.toLowerCase() === "authorization") {
                    delete headers[header];
                  }
                }
              }
              info2 = this._prepareRequest(verb, parsedRedirectUrl, headers);
              response = yield this.requestRaw(info2, data);
              redirectsRemaining--;
            }
            if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
              return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
              yield response.readBody();
              yield this._performExponentialBackoff(numTries);
            }
          } while (numTries < maxTries);
          return response;
        });
      }
      /**
       * Needs to be called if keepAlive is set to true in request options.
       */
      dispose() {
        if (this._agent) {
          this._agent.destroy();
        }
        this._disposed = true;
      }
      /**
       * Raw request.
       * @param info
       * @param data
       */
      requestRaw(info2, data) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve2, reject) => {
            function callbackForResult(err, res) {
              if (err) {
                reject(err);
              } else if (!res) {
                reject(new Error("Unknown error"));
              } else {
                resolve2(res);
              }
            }
            this.requestRawWithCallback(info2, data, callbackForResult);
          });
        });
      }
      /**
       * Raw request with callback.
       * @param info
       * @param data
       * @param onResult
       */
      requestRawWithCallback(info2, data, onResult) {
        if (typeof data === "string") {
          if (!info2.options.headers) {
            info2.options.headers = {};
          }
          info2.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
        }
        let callbackCalled = false;
        function handleResult(err, res) {
          if (!callbackCalled) {
            callbackCalled = true;
            onResult(err, res);
          }
        }
        const req = info2.httpModule.request(info2.options, (msg) => {
          const res = new HttpClientResponse(msg);
          handleResult(void 0, res);
        });
        let socket;
        req.on("socket", (sock) => {
          socket = sock;
        });
        req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
          if (socket) {
            socket.end();
          }
          handleResult(new Error(`Request timeout: ${info2.options.path}`));
        });
        req.on("error", function(err) {
          handleResult(err);
        });
        if (data && typeof data === "string") {
          req.write(data, "utf8");
        }
        if (data && typeof data !== "string") {
          data.on("close", function() {
            req.end();
          });
          data.pipe(req);
        } else {
          req.end();
        }
      }
      /**
       * Gets an http agent. This function is useful when you need an http agent that handles
       * routing through a proxy server - depending upon the url and proxy environment variables.
       * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
       */
      getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
      }
      getAgentDispatcher(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (!useProxy) {
          return;
        }
        return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
      }
      _prepareRequest(method, requestUrl, headers) {
        const info2 = {};
        info2.parsedUrl = requestUrl;
        const usingSsl = info2.parsedUrl.protocol === "https:";
        info2.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info2.options = {};
        info2.options.host = info2.parsedUrl.hostname;
        info2.options.port = info2.parsedUrl.port ? parseInt(info2.parsedUrl.port) : defaultPort;
        info2.options.path = (info2.parsedUrl.pathname || "") + (info2.parsedUrl.search || "");
        info2.options.method = method;
        info2.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
          info2.options.headers["user-agent"] = this.userAgent;
        }
        info2.options.agent = this._getAgent(info2.parsedUrl);
        if (this.handlers) {
          for (const handler of this.handlers) {
            handler.prepareRequest(info2.options);
          }
        }
        return info2;
      }
      _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
          return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
      }
      _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
          clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
      }
      _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
          agent = this._proxyAgent;
        }
        if (!useProxy) {
          agent = this._agent;
        }
        if (agent) {
          return agent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        let maxSockets = 100;
        if (this.requestOptions) {
          maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        if (proxyUrl && proxyUrl.hostname) {
          const agentOptions = {
            maxSockets,
            keepAlive: this._keepAlive,
            proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
              proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
            }), { host: proxyUrl.hostname, port: proxyUrl.port })
          };
          let tunnelAgent;
          const overHttps = proxyUrl.protocol === "https:";
          if (usingSsl) {
            tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
          } else {
            tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
          }
          agent = tunnelAgent(agentOptions);
          this._proxyAgent = agent;
        }
        if (!agent) {
          const options = { keepAlive: this._keepAlive, maxSockets };
          agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
          this._agent = agent;
        }
        if (usingSsl && this._ignoreSslError) {
          agent.options = Object.assign(agent.options || {}, {
            rejectUnauthorized: false
          });
        }
        return agent;
      }
      _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
        let proxyAgent;
        if (this._keepAlive) {
          proxyAgent = this._proxyAgentDispatcher;
        }
        if (proxyAgent) {
          return proxyAgent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
          token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}`
        }));
        this._proxyAgentDispatcher = proxyAgent;
        if (usingSsl && this._ignoreSslError) {
          proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
            rejectUnauthorized: false
          });
        }
        return proxyAgent;
      }
      _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
          const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
          return new Promise((resolve2) => setTimeout(() => resolve2(), ms));
        });
      }
      _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve2, reject) => __awaiter(this, void 0, void 0, function* () {
            const statusCode = res.message.statusCode || 0;
            const response = {
              statusCode,
              result: null,
              headers: {}
            };
            if (statusCode === HttpCodes.NotFound) {
              resolve2(response);
            }
            function dateTimeDeserializer(key, value) {
              if (typeof value === "string") {
                const a = new Date(value);
                if (!isNaN(a.valueOf())) {
                  return a;
                }
              }
              return value;
            }
            let obj;
            let contents;
            try {
              contents = yield res.readBody();
              if (contents && contents.length > 0) {
                if (options && options.deserializeDates) {
                  obj = JSON.parse(contents, dateTimeDeserializer);
                } else {
                  obj = JSON.parse(contents);
                }
                response.result = obj;
              }
              response.headers = res.message.headers;
            } catch (err) {
            }
            if (statusCode > 299) {
              let msg;
              if (obj && obj.message) {
                msg = obj.message;
              } else if (contents && contents.length > 0) {
                msg = contents;
              } else {
                msg = `Failed request: (${statusCode})`;
              }
              const err = new HttpClientError(msg, statusCode);
              err.result = response.result;
              reject(err);
            } else {
              resolve2(response);
            }
          }));
        });
      }
    };
    exports2.HttpClient = HttpClient;
    var lowercaseKeys = (obj) => Object.keys(obj).reduce((c3, k) => (c3[k.toLowerCase()] = obj[k], c3), {});
  }
});

// ../../node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS({
  "../../node_modules/.pnpm/@actions+http-client@2.2.3/node_modules/@actions/http-client/lib/auth.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PersonalAccessTokenCredentialHandler = exports2.BearerCredentialHandler = exports2.BasicCredentialHandler = void 0;
    var BasicCredentialHandler = class {
      constructor(username, password) {
        this.username = username;
        this.password = password;
      }
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.BasicCredentialHandler = BasicCredentialHandler;
    var BearerCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Bearer ${this.token}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.BearerCredentialHandler = BearerCredentialHandler;
    var PersonalAccessTokenCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports2.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  }
});

// ../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS({
  "../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/oidc-utils.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OidcClient = void 0;
    var http_client_1 = require_lib();
    var auth_1 = require_auth();
    var core_1 = require_core();
    var OidcClient = class _OidcClient {
      static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
          allowRetries: allowRetry,
          maxRetries: maxRetry
        };
        return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(_OidcClient.getRequestToken())], requestOptions);
      }
      static getRequestToken() {
        const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
        if (!token) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
        }
        return token;
      }
      static getIDTokenUrl() {
        const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
        if (!runtimeUrl) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
        }
        return runtimeUrl;
      }
      static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const httpclient = _OidcClient.createHttpClient();
          const res = yield httpclient.getJson(id_token_url).catch((error2) => {
            throw new Error(`Failed to get ID Token. 
 
        Error Code : ${error2.statusCode}
 
        Error Message: ${error2.message}`);
          });
          const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
          if (!id_token) {
            throw new Error("Response json body do not have ID Token field");
          }
          return id_token;
        });
      }
      static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            let id_token_url = _OidcClient.getIDTokenUrl();
            if (audience) {
              const encodedAudience = encodeURIComponent(audience);
              id_token_url = `${id_token_url}&audience=${encodedAudience}`;
            }
            (0, core_1.debug)(`ID token url is ${id_token_url}`);
            const id_token = yield _OidcClient.getCall(id_token_url);
            (0, core_1.setSecret)(id_token);
            return id_token;
          } catch (error2) {
            throw new Error(`Error message: ${error2.message}`);
          }
        });
      }
    };
    exports2.OidcClient = OidcClient;
  }
});

// ../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS({
  "../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/summary.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.summary = exports2.markdownSummary = exports2.SUMMARY_DOCS_URL = exports2.SUMMARY_ENV_VAR = void 0;
    var os_1 = require("os");
    var fs_1 = require("fs");
    var { access, appendFile, writeFile } = fs_1.promises;
    exports2.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
    exports2.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
    var Summary = class {
      constructor() {
        this._buffer = "";
      }
      /**
       * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
       * Also checks r/w permissions.
       *
       * @returns step summary file path
       */
      filePath() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._filePath) {
            return this._filePath;
          }
          const pathFromEnv = process.env[exports2.SUMMARY_ENV_VAR];
          if (!pathFromEnv) {
            throw new Error(`Unable to find environment variable for $${exports2.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
          }
          try {
            yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
          } catch (_a) {
            throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
          }
          this._filePath = pathFromEnv;
          return this._filePath;
        });
      }
      /**
       * Wraps content in an HTML tag, adding any HTML attributes
       *
       * @param {string} tag HTML tag to wrap
       * @param {string | null} content content within the tag
       * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
       *
       * @returns {string} content wrapped in HTML element
       */
      wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
        if (!content) {
          return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
      }
      /**
       * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
       *
       * @param {SummaryWriteOptions} [options] (optional) options for write operation
       *
       * @returns {Promise<Summary>} summary instance
       */
      write(options) {
        return __awaiter(this, void 0, void 0, function* () {
          const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
          const filePath = yield this.filePath();
          const writeFunc = overwrite ? writeFile : appendFile;
          yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
          return this.emptyBuffer();
        });
      }
      /**
       * Clears the summary buffer and wipes the summary file
       *
       * @returns {Summary} summary instance
       */
      clear() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.emptyBuffer().write({ overwrite: true });
        });
      }
      /**
       * Returns the current summary buffer as a string
       *
       * @returns {string} string of summary buffer
       */
      stringify() {
        return this._buffer;
      }
      /**
       * If the summary buffer is empty
       *
       * @returns {boolen} true if the buffer is empty
       */
      isEmptyBuffer() {
        return this._buffer.length === 0;
      }
      /**
       * Resets the summary buffer without writing to summary file
       *
       * @returns {Summary} summary instance
       */
      emptyBuffer() {
        this._buffer = "";
        return this;
      }
      /**
       * Adds raw text to the summary buffer
       *
       * @param {string} text content to add
       * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
       *
       * @returns {Summary} summary instance
       */
      addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
      }
      /**
       * Adds the operating system-specific end-of-line marker to the buffer
       *
       * @returns {Summary} summary instance
       */
      addEOL() {
        return this.addRaw(os_1.EOL);
      }
      /**
       * Adds an HTML codeblock to the summary buffer
       *
       * @param {string} code content to render within fenced code block
       * @param {string} lang (optional) language to syntax highlight code
       *
       * @returns {Summary} summary instance
       */
      addCodeBlock(code, lang) {
        const attrs = Object.assign({}, lang && { lang });
        const element = this.wrap("pre", this.wrap("code", code), attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML list to the summary buffer
       *
       * @param {string[]} items list of items to render
       * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
       *
       * @returns {Summary} summary instance
       */
      addList(items, ordered = false) {
        const tag = ordered ? "ol" : "ul";
        const listItems = items.map((item) => this.wrap("li", item)).join("");
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML table to the summary buffer
       *
       * @param {SummaryTableCell[]} rows table rows
       *
       * @returns {Summary} summary instance
       */
      addTable(rows) {
        const tableBody = rows.map((row) => {
          const cells = row.map((cell) => {
            if (typeof cell === "string") {
              return this.wrap("td", cell);
            }
            const { header, data, colspan, rowspan } = cell;
            const tag = header ? "th" : "td";
            const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
            return this.wrap(tag, data, attrs);
          }).join("");
          return this.wrap("tr", cells);
        }).join("");
        const element = this.wrap("table", tableBody);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds a collapsable HTML details element to the summary buffer
       *
       * @param {string} label text for the closed state
       * @param {string} content collapsable content
       *
       * @returns {Summary} summary instance
       */
      addDetails(label, content) {
        const element = this.wrap("details", this.wrap("summary", label) + content);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML image tag to the summary buffer
       *
       * @param {string} src path to the image you to embed
       * @param {string} alt text description of the image
       * @param {SummaryImageOptions} options (optional) addition image attributes
       *
       * @returns {Summary} summary instance
       */
      addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
        const element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML section heading element
       *
       * @param {string} text heading text
       * @param {number | string} [level=1] (optional) the heading level, default: 1
       *
       * @returns {Summary} summary instance
       */
      addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1";
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML thematic break (<hr>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addSeparator() {
        const element = this.wrap("hr", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML line break (<br>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addBreak() {
        const element = this.wrap("br", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML blockquote to the summary buffer
       *
       * @param {string} text quote text
       * @param {string} cite (optional) citation url
       *
       * @returns {Summary} summary instance
       */
      addQuote(text, cite) {
        const attrs = Object.assign({}, cite && { cite });
        const element = this.wrap("blockquote", text, attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML anchor tag to the summary buffer
       *
       * @param {string} text link text/content
       * @param {string} href hyperlink
       *
       * @returns {Summary} summary instance
       */
      addLink(text, href) {
        const element = this.wrap("a", text, { href });
        return this.addRaw(element).addEOL();
      }
    };
    var _summary = new Summary();
    exports2.markdownSummary = _summary;
    exports2.summary = _summary;
  }
});

// ../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS({
  "../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/path-utils.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      o[k22] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v3) {
      Object.defineProperty(o, "default", { enumerable: true, value: v3 });
    } : function(o, v3) {
      o["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toPlatformPath = exports2.toWin32Path = exports2.toPosixPath = void 0;
    var path2 = __importStar(require("path"));
    function toPosixPath(pth) {
      return pth.replace(/[\\]/g, "/");
    }
    exports2.toPosixPath = toPosixPath;
    function toWin32Path(pth) {
      return pth.replace(/[/]/g, "\\");
    }
    exports2.toWin32Path = toWin32Path;
    function toPlatformPath(pth) {
      return pth.replace(/[/\\]/g, path2.sep);
    }
    exports2.toPlatformPath = toPlatformPath;
  }
});

// ../../node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS({
  "../../node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io-util.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      Object.defineProperty(o, k22, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      o[k22] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v3) {
      Object.defineProperty(o, "default", { enumerable: true, value: v3 });
    } : function(o, v3) {
      o["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCmdPath = exports2.tryGetExecutablePath = exports2.isRooted = exports2.isDirectory = exports2.exists = exports2.READONLY = exports2.UV_FS_O_EXLOCK = exports2.IS_WINDOWS = exports2.unlink = exports2.symlink = exports2.stat = exports2.rmdir = exports2.rm = exports2.rename = exports2.readlink = exports2.readdir = exports2.open = exports2.mkdir = exports2.lstat = exports2.copyFile = exports2.chmod = void 0;
    var fs2 = __importStar(require("fs"));
    var path2 = __importStar(require("path"));
    _a = fs2.promises, exports2.chmod = _a.chmod, exports2.copyFile = _a.copyFile, exports2.lstat = _a.lstat, exports2.mkdir = _a.mkdir, exports2.open = _a.open, exports2.readdir = _a.readdir, exports2.readlink = _a.readlink, exports2.rename = _a.rename, exports2.rm = _a.rm, exports2.rmdir = _a.rmdir, exports2.stat = _a.stat, exports2.symlink = _a.symlink, exports2.unlink = _a.unlink;
    exports2.IS_WINDOWS = process.platform === "win32";
    exports2.UV_FS_O_EXLOCK = 268435456;
    exports2.READONLY = fs2.constants.O_RDONLY;
    function exists(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          yield exports2.stat(fsPath);
        } catch (err) {
          if (err.code === "ENOENT") {
            return false;
          }
          throw err;
        }
        return true;
      });
    }
    exports2.exists = exists;
    function isDirectory(fsPath, useStat = false) {
      return __awaiter(this, void 0, void 0, function* () {
        const stats = useStat ? yield exports2.stat(fsPath) : yield exports2.lstat(fsPath);
        return stats.isDirectory();
      });
    }
    exports2.isDirectory = isDirectory;
    function isRooted(p3) {
      p3 = normalizeSeparators(p3);
      if (!p3) {
        throw new Error('isRooted() parameter "p" cannot be empty');
      }
      if (exports2.IS_WINDOWS) {
        return p3.startsWith("\\") || /^[A-Z]:/i.test(p3);
      }
      return p3.startsWith("/");
    }
    exports2.isRooted = isRooted;
    function tryGetExecutablePath(filePath, extensions) {
      return __awaiter(this, void 0, void 0, function* () {
        let stats = void 0;
        try {
          stats = yield exports2.stat(filePath);
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
          }
        }
        if (stats && stats.isFile()) {
          if (exports2.IS_WINDOWS) {
            const upperExt = path2.extname(filePath).toUpperCase();
            if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
              return filePath;
            }
          } else {
            if (isUnixExecutable(stats)) {
              return filePath;
            }
          }
        }
        const originalFilePath = filePath;
        for (const extension of extensions) {
          filePath = originalFilePath + extension;
          stats = void 0;
          try {
            stats = yield exports2.stat(filePath);
          } catch (err) {
            if (err.code !== "ENOENT") {
              console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
            }
          }
          if (stats && stats.isFile()) {
            if (exports2.IS_WINDOWS) {
              try {
                const directory = path2.dirname(filePath);
                const upperName = path2.basename(filePath).toUpperCase();
                for (const actualName of yield exports2.readdir(directory)) {
                  if (upperName === actualName.toUpperCase()) {
                    filePath = path2.join(directory, actualName);
                    break;
                  }
                }
              } catch (err) {
                console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
              }
              return filePath;
            } else {
              if (isUnixExecutable(stats)) {
                return filePath;
              }
            }
          }
        }
        return "";
      });
    }
    exports2.tryGetExecutablePath = tryGetExecutablePath;
    function normalizeSeparators(p3) {
      p3 = p3 || "";
      if (exports2.IS_WINDOWS) {
        p3 = p3.replace(/\//g, "\\");
        return p3.replace(/\\\\+/g, "\\");
      }
      return p3.replace(/\/\/+/g, "/");
    }
    function isUnixExecutable(stats) {
      return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
    }
    function getCmdPath() {
      var _a2;
      return (_a2 = process.env["COMSPEC"]) !== null && _a2 !== void 0 ? _a2 : `cmd.exe`;
    }
    exports2.getCmdPath = getCmdPath;
  }
});

// ../../node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io.js
var require_io = __commonJS({
  "../../node_modules/.pnpm/@actions+io@1.1.3/node_modules/@actions/io/lib/io.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      Object.defineProperty(o, k22, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      o[k22] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v3) {
      Object.defineProperty(o, "default", { enumerable: true, value: v3 });
    } : function(o, v3) {
      o["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findInPath = exports2.which = exports2.mkdirP = exports2.rmRF = exports2.mv = exports2.cp = void 0;
    var assert_1 = require("assert");
    var path2 = __importStar(require("path"));
    var ioUtil = __importStar(require_io_util());
    function cp(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        const { force, recursive, copySourceDirectory } = readCopyOptions(options);
        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
        if (destStat && destStat.isFile() && !force) {
          return;
        }
        const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path2.join(dest, path2.basename(source)) : dest;
        if (!(yield ioUtil.exists(source))) {
          throw new Error(`no such file or directory: ${source}`);
        }
        const sourceStat = yield ioUtil.stat(source);
        if (sourceStat.isDirectory()) {
          if (!recursive) {
            throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
          } else {
            yield cpDirRecursive(source, newDest, 0, force);
          }
        } else {
          if (path2.relative(source, newDest) === "") {
            throw new Error(`'${newDest}' and '${source}' are the same file`);
          }
          yield copyFile(source, newDest, force);
        }
      });
    }
    exports2.cp = cp;
    function mv(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        if (yield ioUtil.exists(dest)) {
          let destExists = true;
          if (yield ioUtil.isDirectory(dest)) {
            dest = path2.join(dest, path2.basename(source));
            destExists = yield ioUtil.exists(dest);
          }
          if (destExists) {
            if (options.force == null || options.force) {
              yield rmRF(dest);
            } else {
              throw new Error("Destination already exists");
            }
          }
        }
        yield mkdirP(path2.dirname(dest));
        yield ioUtil.rename(source, dest);
      });
    }
    exports2.mv = mv;
    function rmRF(inputPath) {
      return __awaiter(this, void 0, void 0, function* () {
        if (ioUtil.IS_WINDOWS) {
          if (/[*"<>|]/.test(inputPath)) {
            throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
          }
        }
        try {
          yield ioUtil.rm(inputPath, {
            force: true,
            maxRetries: 3,
            recursive: true,
            retryDelay: 300
          });
        } catch (err) {
          throw new Error(`File was unable to be removed ${err}`);
        }
      });
    }
    exports2.rmRF = rmRF;
    function mkdirP(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        assert_1.ok(fsPath, "a path argument must be provided");
        yield ioUtil.mkdir(fsPath, { recursive: true });
      });
    }
    exports2.mkdirP = mkdirP;
    function which(tool, check) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!tool) {
          throw new Error("parameter 'tool' is required");
        }
        if (check) {
          const result = yield which(tool, false);
          if (!result) {
            if (ioUtil.IS_WINDOWS) {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
            } else {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
            }
          }
          return result;
        }
        const matches = yield findInPath(tool);
        if (matches && matches.length > 0) {
          return matches[0];
        }
        return "";
      });
    }
    exports2.which = which;
    function findInPath(tool) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!tool) {
          throw new Error("parameter 'tool' is required");
        }
        const extensions = [];
        if (ioUtil.IS_WINDOWS && process.env["PATHEXT"]) {
          for (const extension of process.env["PATHEXT"].split(path2.delimiter)) {
            if (extension) {
              extensions.push(extension);
            }
          }
        }
        if (ioUtil.isRooted(tool)) {
          const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
          if (filePath) {
            return [filePath];
          }
          return [];
        }
        if (tool.includes(path2.sep)) {
          return [];
        }
        const directories = [];
        if (process.env.PATH) {
          for (const p3 of process.env.PATH.split(path2.delimiter)) {
            if (p3) {
              directories.push(p3);
            }
          }
        }
        const matches = [];
        for (const directory of directories) {
          const filePath = yield ioUtil.tryGetExecutablePath(path2.join(directory, tool), extensions);
          if (filePath) {
            matches.push(filePath);
          }
        }
        return matches;
      });
    }
    exports2.findInPath = findInPath;
    function readCopyOptions(options) {
      const force = options.force == null ? true : options.force;
      const recursive = Boolean(options.recursive);
      const copySourceDirectory = options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory);
      return { force, recursive, copySourceDirectory };
    }
    function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if (currentDepth >= 255)
          return;
        currentDepth++;
        yield mkdirP(destDir);
        const files = yield ioUtil.readdir(sourceDir);
        for (const fileName of files) {
          const srcFile = `${sourceDir}/${fileName}`;
          const destFile = `${destDir}/${fileName}`;
          const srcFileStat = yield ioUtil.lstat(srcFile);
          if (srcFileStat.isDirectory()) {
            yield cpDirRecursive(srcFile, destFile, currentDepth, force);
          } else {
            yield copyFile(srcFile, destFile, force);
          }
        }
        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
      });
    }
    function copyFile(srcFile, destFile, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
          try {
            yield ioUtil.lstat(destFile);
            yield ioUtil.unlink(destFile);
          } catch (e2) {
            if (e2.code === "EPERM") {
              yield ioUtil.chmod(destFile, "0666");
              yield ioUtil.unlink(destFile);
            }
          }
          const symlinkFull = yield ioUtil.readlink(srcFile);
          yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
        } else if (!(yield ioUtil.exists(destFile)) || force) {
          yield ioUtil.copyFile(srcFile, destFile);
        }
      });
    }
  }
});

// ../../node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS({
  "../../node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/toolrunner.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      Object.defineProperty(o, k22, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      o[k22] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v3) {
      Object.defineProperty(o, "default", { enumerable: true, value: v3 });
    } : function(o, v3) {
      o["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.argStringToArray = exports2.ToolRunner = void 0;
    var os = __importStar(require("os"));
    var events = __importStar(require("events"));
    var child = __importStar(require("child_process"));
    var path2 = __importStar(require("path"));
    var io = __importStar(require_io());
    var ioUtil = __importStar(require_io_util());
    var timers_1 = require("timers");
    var IS_WINDOWS = process.platform === "win32";
    var ToolRunner = class extends events.EventEmitter {
      constructor(toolPath, args, options) {
        super();
        if (!toolPath) {
          throw new Error("Parameter 'toolPath' cannot be null or empty.");
        }
        this.toolPath = toolPath;
        this.args = args || [];
        this.options = options || {};
      }
      _debug(message) {
        if (this.options.listeners && this.options.listeners.debug) {
          this.options.listeners.debug(message);
        }
      }
      _getCommandString(options, noPrefix) {
        const toolPath = this._getSpawnFileName();
        const args = this._getSpawnArgs(options);
        let cmd = noPrefix ? "" : "[command]";
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            cmd += toolPath;
            for (const a of args) {
              cmd += ` ${a}`;
            }
          } else if (options.windowsVerbatimArguments) {
            cmd += `"${toolPath}"`;
            for (const a of args) {
              cmd += ` ${a}`;
            }
          } else {
            cmd += this._windowsQuoteCmdArg(toolPath);
            for (const a of args) {
              cmd += ` ${this._windowsQuoteCmdArg(a)}`;
            }
          }
        } else {
          cmd += toolPath;
          for (const a of args) {
            cmd += ` ${a}`;
          }
        }
        return cmd;
      }
      _processLineBuffer(data, strBuffer, onLine) {
        try {
          let s = strBuffer + data.toString();
          let n3 = s.indexOf(os.EOL);
          while (n3 > -1) {
            const line = s.substring(0, n3);
            onLine(line);
            s = s.substring(n3 + os.EOL.length);
            n3 = s.indexOf(os.EOL);
          }
          return s;
        } catch (err) {
          this._debug(`error processing line. Failed with error ${err}`);
          return "";
        }
      }
      _getSpawnFileName() {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            return process.env["COMSPEC"] || "cmd.exe";
          }
        }
        return this.toolPath;
      }
      _getSpawnArgs(options) {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
            for (const a of this.args) {
              argline += " ";
              argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
            }
            argline += '"';
            return [argline];
          }
        }
        return this.args;
      }
      _endsWith(str, end) {
        return str.endsWith(end);
      }
      _isCmdFile() {
        const upperToolPath = this.toolPath.toUpperCase();
        return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
      }
      _windowsQuoteCmdArg(arg) {
        if (!this._isCmdFile()) {
          return this._uvQuoteCmdArg(arg);
        }
        if (!arg) {
          return '""';
        }
        const cmdSpecialChars = [
          " ",
          "	",
          "&",
          "(",
          ")",
          "[",
          "]",
          "{",
          "}",
          "^",
          "=",
          ";",
          "!",
          "'",
          "+",
          ",",
          "`",
          "~",
          "|",
          "<",
          ">",
          '"'
        ];
        let needsQuotes = false;
        for (const char of arg) {
          if (cmdSpecialChars.some((x3) => x3 === char)) {
            needsQuotes = true;
            break;
          }
        }
        if (!needsQuotes) {
          return arg;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i3 = arg.length; i3 > 0; i3--) {
          reverse += arg[i3 - 1];
          if (quoteHit && arg[i3 - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i3 - 1] === '"') {
            quoteHit = true;
            reverse += '"';
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _uvQuoteCmdArg(arg) {
        if (!arg) {
          return '""';
        }
        if (!arg.includes(" ") && !arg.includes("	") && !arg.includes('"')) {
          return arg;
        }
        if (!arg.includes('"') && !arg.includes("\\")) {
          return `"${arg}"`;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i3 = arg.length; i3 > 0; i3--) {
          reverse += arg[i3 - 1];
          if (quoteHit && arg[i3 - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i3 - 1] === '"') {
            quoteHit = true;
            reverse += "\\";
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _cloneExecOptions(options) {
        options = options || {};
        const result = {
          cwd: options.cwd || process.cwd(),
          env: options.env || process.env,
          silent: options.silent || false,
          windowsVerbatimArguments: options.windowsVerbatimArguments || false,
          failOnStdErr: options.failOnStdErr || false,
          ignoreReturnCode: options.ignoreReturnCode || false,
          delay: options.delay || 1e4
        };
        result.outStream = options.outStream || process.stdout;
        result.errStream = options.errStream || process.stderr;
        return result;
      }
      _getSpawnOptions(options, toolPath) {
        options = options || {};
        const result = {};
        result.cwd = options.cwd;
        result.env = options.env;
        result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
        if (options.windowsVerbatimArguments) {
          result.argv0 = `"${toolPath}"`;
        }
        return result;
      }
      /**
       * Exec a tool.
       * Output will be streamed to the live console.
       * Returns promise with return code
       *
       * @param     tool     path to tool to exec
       * @param     options  optional exec options.  See ExecOptions
       * @returns   number
       */
      exec() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) {
            this.toolPath = path2.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
          }
          this.toolPath = yield io.which(this.toolPath, true);
          return new Promise((resolve2, reject) => __awaiter(this, void 0, void 0, function* () {
            this._debug(`exec tool: ${this.toolPath}`);
            this._debug("arguments:");
            for (const arg of this.args) {
              this._debug(`   ${arg}`);
            }
            const optionsNonNull = this._cloneExecOptions(this.options);
            if (!optionsNonNull.silent && optionsNonNull.outStream) {
              optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
            }
            const state = new ExecState(optionsNonNull, this.toolPath);
            state.on("debug", (message) => {
              this._debug(message);
            });
            if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
              return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
            }
            const fileName = this._getSpawnFileName();
            const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
            let stdbuffer = "";
            if (cp.stdout) {
              cp.stdout.on("data", (data) => {
                if (this.options.listeners && this.options.listeners.stdout) {
                  this.options.listeners.stdout(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.outStream) {
                  optionsNonNull.outStream.write(data);
                }
                stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.stdline) {
                    this.options.listeners.stdline(line);
                  }
                });
              });
            }
            let errbuffer = "";
            if (cp.stderr) {
              cp.stderr.on("data", (data) => {
                state.processStderr = true;
                if (this.options.listeners && this.options.listeners.stderr) {
                  this.options.listeners.stderr(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                  const s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                  s.write(data);
                }
                errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.errline) {
                    this.options.listeners.errline(line);
                  }
                });
              });
            }
            cp.on("error", (err) => {
              state.processError = err.message;
              state.processExited = true;
              state.processClosed = true;
              state.CheckComplete();
            });
            cp.on("exit", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            cp.on("close", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              state.processClosed = true;
              this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            state.on("done", (error2, exitCode) => {
              if (stdbuffer.length > 0) {
                this.emit("stdline", stdbuffer);
              }
              if (errbuffer.length > 0) {
                this.emit("errline", errbuffer);
              }
              cp.removeAllListeners();
              if (error2) {
                reject(error2);
              } else {
                resolve2(exitCode);
              }
            });
            if (this.options.input) {
              if (!cp.stdin) {
                throw new Error("child process missing stdin");
              }
              cp.stdin.end(this.options.input);
            }
          }));
        });
      }
    };
    exports2.ToolRunner = ToolRunner;
    function argStringToArray(argString) {
      const args = [];
      let inQuotes = false;
      let escaped = false;
      let arg = "";
      function append(c3) {
        if (escaped && c3 !== '"') {
          arg += "\\";
        }
        arg += c3;
        escaped = false;
      }
      for (let i3 = 0; i3 < argString.length; i3++) {
        const c3 = argString.charAt(i3);
        if (c3 === '"') {
          if (!escaped) {
            inQuotes = !inQuotes;
          } else {
            append(c3);
          }
          continue;
        }
        if (c3 === "\\" && escaped) {
          append(c3);
          continue;
        }
        if (c3 === "\\" && inQuotes) {
          escaped = true;
          continue;
        }
        if (c3 === " " && !inQuotes) {
          if (arg.length > 0) {
            args.push(arg);
            arg = "";
          }
          continue;
        }
        append(c3);
      }
      if (arg.length > 0) {
        args.push(arg.trim());
      }
      return args;
    }
    exports2.argStringToArray = argStringToArray;
    var ExecState = class _ExecState extends events.EventEmitter {
      constructor(options, toolPath) {
        super();
        this.processClosed = false;
        this.processError = "";
        this.processExitCode = 0;
        this.processExited = false;
        this.processStderr = false;
        this.delay = 1e4;
        this.done = false;
        this.timeout = null;
        if (!toolPath) {
          throw new Error("toolPath must not be empty");
        }
        this.options = options;
        this.toolPath = toolPath;
        if (options.delay) {
          this.delay = options.delay;
        }
      }
      CheckComplete() {
        if (this.done) {
          return;
        }
        if (this.processClosed) {
          this._setResult();
        } else if (this.processExited) {
          this.timeout = timers_1.setTimeout(_ExecState.HandleTimeout, this.delay, this);
        }
      }
      _debug(message) {
        this.emit("debug", message);
      }
      _setResult() {
        let error2;
        if (this.processExited) {
          if (this.processError) {
            error2 = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
          } else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
            error2 = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
          } else if (this.processStderr && this.options.failOnStdErr) {
            error2 = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
          }
        }
        if (this.timeout) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
        this.done = true;
        this.emit("done", error2, this.processExitCode);
      }
      static HandleTimeout(state) {
        if (state.done) {
          return;
        }
        if (!state.processClosed && state.processExited) {
          const message = `The STDIO streams did not close within ${state.delay / 1e3} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
          state._debug(message);
        }
        state._setResult();
      }
    };
  }
});

// ../../node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS({
  "../../node_modules/.pnpm/@actions+exec@1.1.1/node_modules/@actions/exec/lib/exec.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      Object.defineProperty(o, k22, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      o[k22] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v3) {
      Object.defineProperty(o, "default", { enumerable: true, value: v3 });
    } : function(o, v3) {
      o["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getExecOutput = exports2.exec = void 0;
    var string_decoder_1 = require("string_decoder");
    var tr = __importStar(require_toolrunner());
    function exec3(commandLine, args, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const commandArgs = tr.argStringToArray(commandLine);
        if (commandArgs.length === 0) {
          throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
        }
        const toolPath = commandArgs[0];
        args = commandArgs.slice(1).concat(args || []);
        const runner = new tr.ToolRunner(toolPath, args, options);
        return runner.exec();
      });
    }
    exports2.exec = exec3;
    function getExecOutput(commandLine, args, options) {
      var _a, _b;
      return __awaiter(this, void 0, void 0, function* () {
        let stdout = "";
        let stderr = "";
        const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
        const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
        const originalStdoutListener = (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0 ? void 0 : _a.stdout;
        const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;
        const stdErrListener = (data) => {
          stderr += stderrDecoder.write(data);
          if (originalStdErrListener) {
            originalStdErrListener(data);
          }
        };
        const stdOutListener = (data) => {
          stdout += stdoutDecoder.write(data);
          if (originalStdoutListener) {
            originalStdoutListener(data);
          }
        };
        const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });
        const exitCode = yield exec3(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
        stdout += stdoutDecoder.end();
        stderr += stderrDecoder.end();
        return {
          exitCode,
          stdout,
          stderr
        };
      });
    }
    exports2.getExecOutput = getExecOutput;
  }
});

// ../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/platform.js
var require_platform = __commonJS({
  "../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/platform.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      o[k22] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v3) {
      Object.defineProperty(o, "default", { enumerable: true, value: v3 });
    } : function(o, v3) {
      o["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDetails = exports2.isLinux = exports2.isMacOS = exports2.isWindows = exports2.arch = exports2.platform = void 0;
    var os_1 = __importDefault(require("os"));
    var exec3 = __importStar(require_exec());
    var getWindowsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
      const { stdout: version } = yield exec3.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', void 0, {
        silent: true
      });
      const { stdout: name } = yield exec3.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', void 0, {
        silent: true
      });
      return {
        name: name.trim(),
        version: version.trim()
      };
    });
    var getMacOsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
      var _a, _b, _c, _d;
      const { stdout } = yield exec3.getExecOutput("sw_vers", void 0, {
        silent: true
      });
      const version = (_b = (_a = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : "";
      const name = (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : "";
      return {
        name,
        version
      };
    });
    var getLinuxInfo = () => __awaiter(void 0, void 0, void 0, function* () {
      const { stdout } = yield exec3.getExecOutput("lsb_release", ["-i", "-r", "-s"], {
        silent: true
      });
      const [name, version] = stdout.trim().split("\n");
      return {
        name,
        version
      };
    });
    exports2.platform = os_1.default.platform();
    exports2.arch = os_1.default.arch();
    exports2.isWindows = exports2.platform === "win32";
    exports2.isMacOS = exports2.platform === "darwin";
    exports2.isLinux = exports2.platform === "linux";
    function getDetails() {
      return __awaiter(this, void 0, void 0, function* () {
        return Object.assign(Object.assign({}, yield exports2.isWindows ? getWindowsInfo() : exports2.isMacOS ? getMacOsInfo() : getLinuxInfo()), {
          platform: exports2.platform,
          arch: exports2.arch,
          isWindows: exports2.isWindows,
          isMacOS: exports2.isMacOS,
          isLinux: exports2.isLinux
        });
      });
    }
    exports2.getDetails = getDetails;
  }
});

// ../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/core.js
var require_core = __commonJS({
  "../../node_modules/.pnpm/@actions+core@1.11.1/node_modules/@actions/core/lib/core.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k, k22) {
      if (k22 === void 0) k22 = k;
      o[k22] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v3) {
      Object.defineProperty(o, "default", { enumerable: true, value: v3 });
    } : function(o, v3) {
      o["default"] = v3;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P3, generator) {
      function adopt(value) {
        return value instanceof P3 ? value : new P3(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P3 || (P3 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.platform = exports2.toPlatformPath = exports2.toWin32Path = exports2.toPosixPath = exports2.markdownSummary = exports2.summary = exports2.getIDToken = exports2.getState = exports2.saveState = exports2.group = exports2.endGroup = exports2.startGroup = exports2.info = exports2.notice = exports2.warning = exports2.error = exports2.debug = exports2.isDebug = exports2.setFailed = exports2.setCommandEcho = exports2.setOutput = exports2.getBooleanInput = exports2.getMultilineInput = exports2.getInput = exports2.addPath = exports2.setSecret = exports2.exportVariable = exports2.ExitCode = void 0;
    var command_1 = require_command();
    var file_command_1 = require_file_command();
    var utils_1 = require_utils();
    var os = __importStar(require("os"));
    var path2 = __importStar(require("path"));
    var oidc_utils_1 = require_oidc_utils();
    var ExitCode;
    (function(ExitCode2) {
      ExitCode2[ExitCode2["Success"] = 0] = "Success";
      ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
    })(ExitCode || (exports2.ExitCode = ExitCode = {}));
    function exportVariable(name, val) {
      const convertedVal = (0, utils_1.toCommandValue)(val);
      process.env[name] = convertedVal;
      const filePath = process.env["GITHUB_ENV"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name, val));
      }
      (0, command_1.issueCommand)("set-env", { name }, convertedVal);
    }
    exports2.exportVariable = exportVariable;
    function setSecret(secret) {
      (0, command_1.issueCommand)("add-mask", {}, secret);
    }
    exports2.setSecret = setSecret;
    function addPath(inputPath) {
      const filePath = process.env["GITHUB_PATH"] || "";
      if (filePath) {
        (0, file_command_1.issueFileCommand)("PATH", inputPath);
      } else {
        (0, command_1.issueCommand)("add-path", {}, inputPath);
      }
      process.env["PATH"] = `${inputPath}${path2.delimiter}${process.env["PATH"]}`;
    }
    exports2.addPath = addPath;
    function getInput(name, options) {
      const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
      if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
      }
      if (options && options.trimWhitespace === false) {
        return val;
      }
      return val.trim();
    }
    exports2.getInput = getInput;
    function getMultilineInput(name, options) {
      const inputs = getInput(name, options).split("\n").filter((x3) => x3 !== "");
      if (options && options.trimWhitespace === false) {
        return inputs;
      }
      return inputs.map((input) => input.trim());
    }
    exports2.getMultilineInput = getMultilineInput;
    function getBooleanInput(name, options) {
      const trueValue = ["true", "True", "TRUE"];
      const falseValue = ["false", "False", "FALSE"];
      const val = getInput(name, options);
      if (trueValue.includes(val))
        return true;
      if (falseValue.includes(val))
        return false;
      throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
    }
    exports2.getBooleanInput = getBooleanInput;
    function setOutput(name, value) {
      const filePath = process.env["GITHUB_OUTPUT"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name, value));
      }
      process.stdout.write(os.EOL);
      (0, command_1.issueCommand)("set-output", { name }, (0, utils_1.toCommandValue)(value));
    }
    exports2.setOutput = setOutput;
    function setCommandEcho(enabled) {
      (0, command_1.issue)("echo", enabled ? "on" : "off");
    }
    exports2.setCommandEcho = setCommandEcho;
    function setFailed(message) {
      process.exitCode = ExitCode.Failure;
      error2(message);
    }
    exports2.setFailed = setFailed;
    function isDebug() {
      return process.env["RUNNER_DEBUG"] === "1";
    }
    exports2.isDebug = isDebug;
    function debug2(message) {
      (0, command_1.issueCommand)("debug", {}, message);
    }
    exports2.debug = debug2;
    function error2(message, properties = {}) {
      (0, command_1.issueCommand)("error", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.error = error2;
    function warning(message, properties = {}) {
      (0, command_1.issueCommand)("warning", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.warning = warning;
    function notice(message, properties = {}) {
      (0, command_1.issueCommand)("notice", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports2.notice = notice;
    function info2(message) {
      process.stdout.write(message + os.EOL);
    }
    exports2.info = info2;
    function startGroup2(name) {
      (0, command_1.issue)("group", name);
    }
    exports2.startGroup = startGroup2;
    function endGroup2() {
      (0, command_1.issue)("endgroup");
    }
    exports2.endGroup = endGroup2;
    function group(name, fn) {
      return __awaiter(this, void 0, void 0, function* () {
        startGroup2(name);
        let result;
        try {
          result = yield fn();
        } finally {
          endGroup2();
        }
        return result;
      });
    }
    exports2.group = group;
    function saveState(name, value) {
      const filePath = process.env["GITHUB_STATE"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name, value));
      }
      (0, command_1.issueCommand)("save-state", { name }, (0, utils_1.toCommandValue)(value));
    }
    exports2.saveState = saveState;
    function getState(name) {
      return process.env[`STATE_${name}`] || "";
    }
    exports2.getState = getState;
    function getIDToken(aud) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
      });
    }
    exports2.getIDToken = getIDToken;
    var summary_1 = require_summary();
    Object.defineProperty(exports2, "summary", { enumerable: true, get: function() {
      return summary_1.summary;
    } });
    var summary_2 = require_summary();
    Object.defineProperty(exports2, "markdownSummary", { enumerable: true, get: function() {
      return summary_2.markdownSummary;
    } });
    var path_utils_1 = require_path_utils();
    Object.defineProperty(exports2, "toPosixPath", { enumerable: true, get: function() {
      return path_utils_1.toPosixPath;
    } });
    Object.defineProperty(exports2, "toWin32Path", { enumerable: true, get: function() {
      return path_utils_1.toWin32Path;
    } });
    Object.defineProperty(exports2, "toPlatformPath", { enumerable: true, get: function() {
      return path_utils_1.toPlatformPath;
    } });
    exports2.platform = __importStar(require_platform());
  }
});

// claude/index.ts
var index_exports = {};
__export(index_exports, {
  buildCIFixPrompt: () => buildCIFixPrompt,
  buildImplementationPrompt: () => buildImplementationPrompt,
  buildReviewResponsePrompt: () => buildReviewResponsePrompt,
  executeClaudeSDK: () => executeClaudeSDK,
  getClaudeVersion: () => getClaudeVersion,
  isClaudeAvailable: () => isClaudeAvailable,
  resolvePrompt: () => resolvePrompt,
  resolvePromptDir: () => resolvePromptDir,
  substituteVars: () => substituteVars
});
module.exports = __toCommonJS(index_exports);

// claude/src/executor.ts
var core = __toESM(require_core(), 1);
var exec = __toESM(require_exec(), 1);

// ../../node_modules/.pnpm/@anthropic-ai+claude-agent-sdk@0.2.29_zod@3.25.76/node_modules/@anthropic-ai/claude-agent-sdk/sdk.mjs
var import_path = require("path");
var import_url = require("url");
var import_events = require("events");
var import_child_process = require("child_process");
var import_readline = require("readline");
var h = __toESM(require("fs"), 1);
var import_promises = require("fs/promises");
var import_path2 = require("path");
var import_os = require("os");
var import_path3 = require("path");
var import_process = require("process");
var import_fs = require("fs");
var import_crypto = require("crypto");
var import_crypto2 = require("crypto");
var import_fs2 = require("fs");
var import_path4 = require("path");
var import_crypto3 = require("crypto");
var import_meta = {};
var $K = Object.create;
var { getPrototypeOf: YK, defineProperty: Y9, getOwnPropertyNames: WK } = Object;
var JK = Object.prototype.hasOwnProperty;
var K7 = (X, Q, $) => {
  $ = X != null ? $K(YK(X)) : {};
  let Y = Q || !X || !X.__esModule ? Y9($, "default", { value: X, enumerable: true }) : $;
  for (let W of WK(X)) if (!JK.call(Y, W)) Y9(Y, W, { get: () => X[W], enumerable: true });
  return Y;
};
var P = (X, Q) => () => (Q || X((Q = { exports: {} }).exports, Q), Q.exports);
var U7 = (X, Q) => {
  for (var $ in Q) Y9(X, $, { get: Q[$], enumerable: true, configurable: true, set: (Y) => Q[$] = () => Y });
};
var GK = Symbol.dispose || Symbol.for("Symbol.dispose");
var HK = Symbol.asyncDispose || Symbol.for("Symbol.asyncDispose");
var hX = P((JG) => {
  Object.defineProperty(JG, "__esModule", { value: true });
  JG.regexpCode = JG.getEsmExportName = JG.getProperty = JG.safeStringify = JG.stringify = JG.strConcat = JG.addCodeArg = JG.str = JG._ = JG.nil = JG._Code = JG.Name = JG.IDENTIFIER = JG._CodeOrName = void 0;
  class D8 {
  }
  JG._CodeOrName = D8;
  JG.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class f6 extends D8 {
    constructor(X) {
      super();
      if (!JG.IDENTIFIER.test(X)) throw Error("CodeGen: name must be a valid identifier");
      this.str = X;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  JG.Name = f6;
  class s0 extends D8 {
    constructor(X) {
      super();
      this._items = typeof X === "string" ? [X] : X;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1) return false;
      let X = this._items[0];
      return X === "" || X === '""';
    }
    get str() {
      var X;
      return (X = this._str) !== null && X !== void 0 ? X : this._str = this._items.reduce((Q, $) => `${Q}${$}`, "");
    }
    get names() {
      var X;
      return (X = this._names) !== null && X !== void 0 ? X : this._names = this._items.reduce((Q, $) => {
        if ($ instanceof f6) Q[$.str] = (Q[$.str] || 0) + 1;
        return Q;
      }, {});
    }
  }
  JG._Code = s0;
  JG.nil = new s0("");
  function YG(X, ...Q) {
    let $ = [X[0]], Y = 0;
    while (Y < Q.length) s$($, Q[Y]), $.push(X[++Y]);
    return new s0($);
  }
  JG._ = YG;
  var a$ = new s0("+");
  function WG(X, ...Q) {
    let $ = [fX(X[0])], Y = 0;
    while (Y < Q.length) $.push(a$), s$($, Q[Y]), $.push(a$, fX(X[++Y]));
    return qN($), new s0($);
  }
  JG.str = WG;
  function s$(X, Q) {
    if (Q instanceof s0) X.push(...Q._items);
    else if (Q instanceof f6) X.push(Q);
    else X.push(ON(Q));
  }
  JG.addCodeArg = s$;
  function qN(X) {
    let Q = 1;
    while (Q < X.length - 1) {
      if (X[Q] === a$) {
        let $ = FN(X[Q - 1], X[Q + 1]);
        if ($ !== void 0) {
          X.splice(Q - 1, 3, $);
          continue;
        }
        X[Q++] = "+";
      }
      Q++;
    }
  }
  function FN(X, Q) {
    if (Q === '""') return X;
    if (X === '""') return Q;
    if (typeof X == "string") {
      if (Q instanceof f6 || X[X.length - 1] !== '"') return;
      if (typeof Q != "string") return `${X.slice(0, -1)}${Q}"`;
      if (Q[0] === '"') return X.slice(0, -1) + Q.slice(1);
      return;
    }
    if (typeof Q == "string" && Q[0] === '"' && !(X instanceof f6)) return `"${X}${Q.slice(1)}`;
    return;
  }
  function NN(X, Q) {
    return Q.emptyStr() ? X : X.emptyStr() ? Q : WG`${X}${Q}`;
  }
  JG.strConcat = NN;
  function ON(X) {
    return typeof X == "number" || typeof X == "boolean" || X === null ? X : fX(Array.isArray(X) ? X.join(",") : X);
  }
  function DN(X) {
    return new s0(fX(X));
  }
  JG.stringify = DN;
  function fX(X) {
    return JSON.stringify(X).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  JG.safeStringify = fX;
  function AN(X) {
    return typeof X == "string" && JG.IDENTIFIER.test(X) ? new s0(`.${X}`) : YG`[${X}]`;
  }
  JG.getProperty = AN;
  function wN(X) {
    if (typeof X == "string" && JG.IDENTIFIER.test(X)) return new s0(`${X}`);
    throw Error(`CodeGen: invalid export name: ${X}, use explicit $id name mapping`);
  }
  JG.getEsmExportName = wN;
  function MN(X) {
    return new s0(X.toString());
  }
  JG.regexpCode = MN;
});
var $Y = P((zG) => {
  Object.defineProperty(zG, "__esModule", { value: true });
  zG.ValueScope = zG.ValueScopeName = zG.Scope = zG.varKinds = zG.UsedValueState = void 0;
  var x0 = hX();
  class HG extends Error {
    constructor(X) {
      super(`CodeGen: "code" for ${X} not defined`);
      this.value = X.value;
    }
  }
  var w8;
  (function(X) {
    X[X.Started = 0] = "Started", X[X.Completed = 1] = "Completed";
  })(w8 || (zG.UsedValueState = w8 = {}));
  zG.varKinds = { const: new x0.Name("const"), let: new x0.Name("let"), var: new x0.Name("var") };
  class XY {
    constructor({ prefixes: X, parent: Q } = {}) {
      this._names = {}, this._prefixes = X, this._parent = Q;
    }
    toName(X) {
      return X instanceof x0.Name ? X : this.name(X);
    }
    name(X) {
      return new x0.Name(this._newName(X));
    }
    _newName(X) {
      let Q = this._names[X] || this._nameGroup(X);
      return `${X}${Q.index++}`;
    }
    _nameGroup(X) {
      var Q, $;
      if ((($ = (Q = this._parent) === null || Q === void 0 ? void 0 : Q._prefixes) === null || $ === void 0 ? void 0 : $.has(X)) || this._prefixes && !this._prefixes.has(X)) throw Error(`CodeGen: prefix "${X}" is not allowed in this scope`);
      return this._names[X] = { prefix: X, index: 0 };
    }
  }
  zG.Scope = XY;
  class QY extends x0.Name {
    constructor(X, Q) {
      super(Q);
      this.prefix = X;
    }
    setValue(X, { property: Q, itemIndex: $ }) {
      this.value = X, this.scopePath = x0._`.${new x0.Name(Q)}[${$}]`;
    }
  }
  zG.ValueScopeName = QY;
  var _N = x0._`\n`;
  class BG extends XY {
    constructor(X) {
      super(X);
      this._values = {}, this._scope = X.scope, this.opts = { ...X, _n: X.lines ? _N : x0.nil };
    }
    get() {
      return this._scope;
    }
    name(X) {
      return new QY(X, this._newName(X));
    }
    value(X, Q) {
      var $;
      if (Q.ref === void 0) throw Error("CodeGen: ref must be passed in value");
      let Y = this.toName(X), { prefix: W } = Y, J = ($ = Q.key) !== null && $ !== void 0 ? $ : Q.ref, G = this._values[W];
      if (G) {
        let z = G.get(J);
        if (z) return z;
      } else G = this._values[W] = /* @__PURE__ */ new Map();
      G.set(J, Y);
      let H = this._scope[W] || (this._scope[W] = []), B = H.length;
      return H[B] = Q.ref, Y.setValue(Q, { property: W, itemIndex: B }), Y;
    }
    getValue(X, Q) {
      let $ = this._values[X];
      if (!$) return;
      return $.get(Q);
    }
    scopeRefs(X, Q = this._values) {
      return this._reduceValues(Q, ($) => {
        if ($.scopePath === void 0) throw Error(`CodeGen: name "${$}" has no value`);
        return x0._`${X}${$.scopePath}`;
      });
    }
    scopeCode(X = this._values, Q, $) {
      return this._reduceValues(X, (Y) => {
        if (Y.value === void 0) throw Error(`CodeGen: name "${Y}" has no value`);
        return Y.value.code;
      }, Q, $);
    }
    _reduceValues(X, Q, $ = {}, Y) {
      let W = x0.nil;
      for (let J in X) {
        let G = X[J];
        if (!G) continue;
        let H = $[J] = $[J] || /* @__PURE__ */ new Map();
        G.forEach((B) => {
          if (H.has(B)) return;
          H.set(B, w8.Started);
          let z = Q(B);
          if (z) {
            let K = this.opts.es5 ? zG.varKinds.var : zG.varKinds.const;
            W = x0._`${W}${K} ${B} = ${z};${this.opts._n}`;
          } else if (z = Y === null || Y === void 0 ? void 0 : Y(B)) W = x0._`${W}${z}${this.opts._n}`;
          else throw new HG(B);
          H.set(B, w8.Completed);
        });
      }
      return W;
    }
  }
  zG.ValueScope = BG;
});
var c = P((y0) => {
  Object.defineProperty(y0, "__esModule", { value: true });
  y0.or = y0.and = y0.not = y0.CodeGen = y0.operators = y0.varKinds = y0.ValueScopeName = y0.ValueScope = y0.Scope = y0.Name = y0.regexpCode = y0.stringify = y0.getProperty = y0.nil = y0.strConcat = y0.str = y0._ = void 0;
  var t = hX(), e0 = $Y(), l1 = hX();
  Object.defineProperty(y0, "_", { enumerable: true, get: function() {
    return l1._;
  } });
  Object.defineProperty(y0, "str", { enumerable: true, get: function() {
    return l1.str;
  } });
  Object.defineProperty(y0, "strConcat", { enumerable: true, get: function() {
    return l1.strConcat;
  } });
  Object.defineProperty(y0, "nil", { enumerable: true, get: function() {
    return l1.nil;
  } });
  Object.defineProperty(y0, "getProperty", { enumerable: true, get: function() {
    return l1.getProperty;
  } });
  Object.defineProperty(y0, "stringify", { enumerable: true, get: function() {
    return l1.stringify;
  } });
  Object.defineProperty(y0, "regexpCode", { enumerable: true, get: function() {
    return l1.regexpCode;
  } });
  Object.defineProperty(y0, "Name", { enumerable: true, get: function() {
    return l1.Name;
  } });
  var b8 = $Y();
  Object.defineProperty(y0, "Scope", { enumerable: true, get: function() {
    return b8.Scope;
  } });
  Object.defineProperty(y0, "ValueScope", { enumerable: true, get: function() {
    return b8.ValueScope;
  } });
  Object.defineProperty(y0, "ValueScopeName", { enumerable: true, get: function() {
    return b8.ValueScopeName;
  } });
  Object.defineProperty(y0, "varKinds", { enumerable: true, get: function() {
    return b8.varKinds;
  } });
  y0.operators = { GT: new t._Code(">"), GTE: new t._Code(">="), LT: new t._Code("<"), LTE: new t._Code("<="), EQ: new t._Code("==="), NEQ: new t._Code("!=="), NOT: new t._Code("!"), OR: new t._Code("||"), AND: new t._Code("&&"), ADD: new t._Code("+") };
  class m1 {
    optimizeNodes() {
      return this;
    }
    optimizeNames(X, Q) {
      return this;
    }
  }
  class UG extends m1 {
    constructor(X, Q, $) {
      super();
      this.varKind = X, this.name = Q, this.rhs = $;
    }
    render({ es5: X, _n: Q }) {
      let $ = X ? e0.varKinds.var : this.varKind, Y = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${$} ${this.name}${Y};` + Q;
    }
    optimizeNames(X, Q) {
      if (!X[this.name.str]) return;
      if (this.rhs) this.rhs = u6(this.rhs, X, Q);
      return this;
    }
    get names() {
      return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
    }
  }
  class JY extends m1 {
    constructor(X, Q, $) {
      super();
      this.lhs = X, this.rhs = Q, this.sideEffects = $;
    }
    render({ _n: X }) {
      return `${this.lhs} = ${this.rhs};` + X;
    }
    optimizeNames(X, Q) {
      if (this.lhs instanceof t.Name && !X[this.lhs.str] && !this.sideEffects) return;
      return this.rhs = u6(this.rhs, X, Q), this;
    }
    get names() {
      let X = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
      return E8(X, this.rhs);
    }
  }
  class VG extends JY {
    constructor(X, Q, $, Y) {
      super(X, $, Y);
      this.op = Q;
    }
    render({ _n: X }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + X;
    }
  }
  class LG extends m1 {
    constructor(X) {
      super();
      this.label = X, this.names = {};
    }
    render({ _n: X }) {
      return `${this.label}:` + X;
    }
  }
  class qG extends m1 {
    constructor(X) {
      super();
      this.label = X, this.names = {};
    }
    render({ _n: X }) {
      return `break${this.label ? ` ${this.label}` : ""};` + X;
    }
  }
  class FG extends m1 {
    constructor(X) {
      super();
      this.error = X;
    }
    render({ _n: X }) {
      return `throw ${this.error};` + X;
    }
    get names() {
      return this.error.names;
    }
  }
  class NG extends m1 {
    constructor(X) {
      super();
      this.code = X;
    }
    render({ _n: X }) {
      return `${this.code};` + X;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(X, Q) {
      return this.code = u6(this.code, X, Q), this;
    }
    get names() {
      return this.code instanceof t._CodeOrName ? this.code.names : {};
    }
  }
  class P8 extends m1 {
    constructor(X = []) {
      super();
      this.nodes = X;
    }
    render(X) {
      return this.nodes.reduce((Q, $) => Q + $.render(X), "");
    }
    optimizeNodes() {
      let { nodes: X } = this, Q = X.length;
      while (Q--) {
        let $ = X[Q].optimizeNodes();
        if (Array.isArray($)) X.splice(Q, 1, ...$);
        else if ($) X[Q] = $;
        else X.splice(Q, 1);
      }
      return X.length > 0 ? this : void 0;
    }
    optimizeNames(X, Q) {
      let { nodes: $ } = this, Y = $.length;
      while (Y--) {
        let W = $[Y];
        if (W.optimizeNames(X, Q)) continue;
        fN(X, W.names), $.splice(Y, 1);
      }
      return $.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((X, Q) => J6(X, Q.names), {});
    }
  }
  class c1 extends P8 {
    render(X) {
      return "{" + X._n + super.render(X) + "}" + X._n;
    }
  }
  class OG extends P8 {
  }
  class uX extends c1 {
  }
  uX.kind = "else";
  class j1 extends c1 {
    constructor(X, Q) {
      super(Q);
      this.condition = X;
    }
    render(X) {
      let Q = `if(${this.condition})` + super.render(X);
      if (this.else) Q += "else " + this.else.render(X);
      return Q;
    }
    optimizeNodes() {
      super.optimizeNodes();
      let X = this.condition;
      if (X === true) return this.nodes;
      let Q = this.else;
      if (Q) {
        let $ = Q.optimizeNodes();
        Q = this.else = Array.isArray($) ? new uX($) : $;
      }
      if (Q) {
        if (X === false) return Q instanceof j1 ? Q : Q.nodes;
        if (this.nodes.length) return this;
        return new j1(jG(X), Q instanceof j1 ? [Q] : Q.nodes);
      }
      if (X === false || !this.nodes.length) return;
      return this;
    }
    optimizeNames(X, Q) {
      var $;
      if (this.else = ($ = this.else) === null || $ === void 0 ? void 0 : $.optimizeNames(X, Q), !(super.optimizeNames(X, Q) || this.else)) return;
      return this.condition = u6(this.condition, X, Q), this;
    }
    get names() {
      let X = super.names;
      if (E8(X, this.condition), this.else) J6(X, this.else.names);
      return X;
    }
  }
  j1.kind = "if";
  class h6 extends c1 {
  }
  h6.kind = "for";
  class DG extends h6 {
    constructor(X) {
      super();
      this.iteration = X;
    }
    render(X) {
      return `for(${this.iteration})` + super.render(X);
    }
    optimizeNames(X, Q) {
      if (!super.optimizeNames(X, Q)) return;
      return this.iteration = u6(this.iteration, X, Q), this;
    }
    get names() {
      return J6(super.names, this.iteration.names);
    }
  }
  class AG extends h6 {
    constructor(X, Q, $, Y) {
      super();
      this.varKind = X, this.name = Q, this.from = $, this.to = Y;
    }
    render(X) {
      let Q = X.es5 ? e0.varKinds.var : this.varKind, { name: $, from: Y, to: W } = this;
      return `for(${Q} ${$}=${Y}; ${$}<${W}; ${$}++)` + super.render(X);
    }
    get names() {
      let X = E8(super.names, this.from);
      return E8(X, this.to);
    }
  }
  class YY extends h6 {
    constructor(X, Q, $, Y) {
      super();
      this.loop = X, this.varKind = Q, this.name = $, this.iterable = Y;
    }
    render(X) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(X);
    }
    optimizeNames(X, Q) {
      if (!super.optimizeNames(X, Q)) return;
      return this.iterable = u6(this.iterable, X, Q), this;
    }
    get names() {
      return J6(super.names, this.iterable.names);
    }
  }
  class M8 extends c1 {
    constructor(X, Q, $) {
      super();
      this.name = X, this.args = Q, this.async = $;
    }
    render(X) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(X);
    }
  }
  M8.kind = "func";
  class j8 extends P8 {
    render(X) {
      return "return " + super.render(X);
    }
  }
  j8.kind = "return";
  class wG extends c1 {
    render(X) {
      let Q = "try" + super.render(X);
      if (this.catch) Q += this.catch.render(X);
      if (this.finally) Q += this.finally.render(X);
      return Q;
    }
    optimizeNodes() {
      var X, Q;
      return super.optimizeNodes(), (X = this.catch) === null || X === void 0 || X.optimizeNodes(), (Q = this.finally) === null || Q === void 0 || Q.optimizeNodes(), this;
    }
    optimizeNames(X, Q) {
      var $, Y;
      return super.optimizeNames(X, Q), ($ = this.catch) === null || $ === void 0 || $.optimizeNames(X, Q), (Y = this.finally) === null || Y === void 0 || Y.optimizeNames(X, Q), this;
    }
    get names() {
      let X = super.names;
      if (this.catch) J6(X, this.catch.names);
      if (this.finally) J6(X, this.finally.names);
      return X;
    }
  }
  class R8 extends c1 {
    constructor(X) {
      super();
      this.error = X;
    }
    render(X) {
      return `catch(${this.error})` + super.render(X);
    }
  }
  R8.kind = "catch";
  class I8 extends c1 {
    render(X) {
      return "finally" + super.render(X);
    }
  }
  I8.kind = "finally";
  class MG {
    constructor(X, Q = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...Q, _n: Q.lines ? `
` : "" }, this._extScope = X, this._scope = new e0.Scope({ parent: X }), this._nodes = [new OG()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(X) {
      return this._scope.name(X);
    }
    scopeName(X) {
      return this._extScope.name(X);
    }
    scopeValue(X, Q) {
      let $ = this._extScope.value(X, Q);
      return (this._values[$.prefix] || (this._values[$.prefix] = /* @__PURE__ */ new Set())).add($), $;
    }
    getScopeValue(X, Q) {
      return this._extScope.getValue(X, Q);
    }
    scopeRefs(X) {
      return this._extScope.scopeRefs(X, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(X, Q, $, Y) {
      let W = this._scope.toName(Q);
      if ($ !== void 0 && Y) this._constants[W.str] = $;
      return this._leafNode(new UG(X, W, $)), W;
    }
    const(X, Q, $) {
      return this._def(e0.varKinds.const, X, Q, $);
    }
    let(X, Q, $) {
      return this._def(e0.varKinds.let, X, Q, $);
    }
    var(X, Q, $) {
      return this._def(e0.varKinds.var, X, Q, $);
    }
    assign(X, Q, $) {
      return this._leafNode(new JY(X, Q, $));
    }
    add(X, Q) {
      return this._leafNode(new VG(X, y0.operators.ADD, Q));
    }
    code(X) {
      if (typeof X == "function") X();
      else if (X !== t.nil) this._leafNode(new NG(X));
      return this;
    }
    object(...X) {
      let Q = ["{"];
      for (let [$, Y] of X) {
        if (Q.length > 1) Q.push(",");
        if (Q.push($), $ !== Y || this.opts.es5) Q.push(":"), (0, t.addCodeArg)(Q, Y);
      }
      return Q.push("}"), new t._Code(Q);
    }
    if(X, Q, $) {
      if (this._blockNode(new j1(X)), Q && $) this.code(Q).else().code($).endIf();
      else if (Q) this.code(Q).endIf();
      else if ($) throw Error('CodeGen: "else" body without "then" body');
      return this;
    }
    elseIf(X) {
      return this._elseNode(new j1(X));
    }
    else() {
      return this._elseNode(new uX());
    }
    endIf() {
      return this._endBlockNode(j1, uX);
    }
    _for(X, Q) {
      if (this._blockNode(X), Q) this.code(Q).endFor();
      return this;
    }
    for(X, Q) {
      return this._for(new DG(X), Q);
    }
    forRange(X, Q, $, Y, W = this.opts.es5 ? e0.varKinds.var : e0.varKinds.let) {
      let J = this._scope.toName(X);
      return this._for(new AG(W, J, Q, $), () => Y(J));
    }
    forOf(X, Q, $, Y = e0.varKinds.const) {
      let W = this._scope.toName(X);
      if (this.opts.es5) {
        let J = Q instanceof t.Name ? Q : this.var("_arr", Q);
        return this.forRange("_i", 0, t._`${J}.length`, (G) => {
          this.var(W, t._`${J}[${G}]`), $(W);
        });
      }
      return this._for(new YY("of", Y, W, Q), () => $(W));
    }
    forIn(X, Q, $, Y = this.opts.es5 ? e0.varKinds.var : e0.varKinds.const) {
      if (this.opts.ownProperties) return this.forOf(X, t._`Object.keys(${Q})`, $);
      let W = this._scope.toName(X);
      return this._for(new YY("in", Y, W, Q), () => $(W));
    }
    endFor() {
      return this._endBlockNode(h6);
    }
    label(X) {
      return this._leafNode(new LG(X));
    }
    break(X) {
      return this._leafNode(new qG(X));
    }
    return(X) {
      let Q = new j8();
      if (this._blockNode(Q), this.code(X), Q.nodes.length !== 1) throw Error('CodeGen: "return" should have one node');
      return this._endBlockNode(j8);
    }
    try(X, Q, $) {
      if (!Q && !$) throw Error('CodeGen: "try" without "catch" and "finally"');
      let Y = new wG();
      if (this._blockNode(Y), this.code(X), Q) {
        let W = this.name("e");
        this._currNode = Y.catch = new R8(W), Q(W);
      }
      if ($) this._currNode = Y.finally = new I8(), this.code($);
      return this._endBlockNode(R8, I8);
    }
    throw(X) {
      return this._leafNode(new FG(X));
    }
    block(X, Q) {
      if (this._blockStarts.push(this._nodes.length), X) this.code(X).endBlock(Q);
      return this;
    }
    endBlock(X) {
      let Q = this._blockStarts.pop();
      if (Q === void 0) throw Error("CodeGen: not in self-balancing block");
      let $ = this._nodes.length - Q;
      if ($ < 0 || X !== void 0 && $ !== X) throw Error(`CodeGen: wrong number of nodes: ${$} vs ${X} expected`);
      return this._nodes.length = Q, this;
    }
    func(X, Q = t.nil, $, Y) {
      if (this._blockNode(new M8(X, Q, $)), Y) this.code(Y).endFunc();
      return this;
    }
    endFunc() {
      return this._endBlockNode(M8);
    }
    optimize(X = 1) {
      while (X-- > 0) this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(X) {
      return this._currNode.nodes.push(X), this;
    }
    _blockNode(X) {
      this._currNode.nodes.push(X), this._nodes.push(X);
    }
    _endBlockNode(X, Q) {
      let $ = this._currNode;
      if ($ instanceof X || Q && $ instanceof Q) return this._nodes.pop(), this;
      throw Error(`CodeGen: not in block "${Q ? `${X.kind}/${Q.kind}` : X.kind}"`);
    }
    _elseNode(X) {
      let Q = this._currNode;
      if (!(Q instanceof j1)) throw Error('CodeGen: "else" without "if"');
      return this._currNode = Q.else = X, this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      let X = this._nodes;
      return X[X.length - 1];
    }
    set _currNode(X) {
      let Q = this._nodes;
      Q[Q.length - 1] = X;
    }
  }
  y0.CodeGen = MG;
  function J6(X, Q) {
    for (let $ in Q) X[$] = (X[$] || 0) + (Q[$] || 0);
    return X;
  }
  function E8(X, Q) {
    return Q instanceof t._CodeOrName ? J6(X, Q.names) : X;
  }
  function u6(X, Q, $) {
    if (X instanceof t.Name) return Y(X);
    if (!W(X)) return X;
    return new t._Code(X._items.reduce((J, G) => {
      if (G instanceof t.Name) G = Y(G);
      if (G instanceof t._Code) J.push(...G._items);
      else J.push(G);
      return J;
    }, []));
    function Y(J) {
      let G = $[J.str];
      if (G === void 0 || Q[J.str] !== 1) return J;
      return delete Q[J.str], G;
    }
    function W(J) {
      return J instanceof t._Code && J._items.some((G) => G instanceof t.Name && Q[G.str] === 1 && $[G.str] !== void 0);
    }
  }
  function fN(X, Q) {
    for (let $ in Q) X[$] = (X[$] || 0) - (Q[$] || 0);
  }
  function jG(X) {
    return typeof X == "boolean" || typeof X == "number" || X === null ? !X : t._`!${WY(X)}`;
  }
  y0.not = jG;
  var hN = RG(y0.operators.AND);
  function uN(...X) {
    return X.reduce(hN);
  }
  y0.and = uN;
  var lN = RG(y0.operators.OR);
  function mN(...X) {
    return X.reduce(lN);
  }
  y0.or = mN;
  function RG(X) {
    return (Q, $) => Q === t.nil ? $ : $ === t.nil ? Q : t._`${WY(Q)} ${X} ${WY($)}`;
  }
  function WY(X) {
    return X instanceof t.Name ? X : t._`(${X})`;
  }
});
var e = P((vG) => {
  Object.defineProperty(vG, "__esModule", { value: true });
  vG.checkStrictMode = vG.getErrorPath = vG.Type = vG.useFunc = vG.setEvaluated = vG.evaluatedPropsToName = vG.mergeEvaluated = vG.eachItem = vG.unescapeJsonPointer = vG.escapeJsonPointer = vG.escapeFragment = vG.unescapeFragment = vG.schemaRefOrVal = vG.schemaHasRulesButRef = vG.schemaHasRules = vG.checkUnknownRules = vG.alwaysValidSchema = vG.toHash = void 0;
  var $0 = c(), iN = hX();
  function nN(X) {
    let Q = {};
    for (let $ of X) Q[$] = true;
    return Q;
  }
  vG.toHash = nN;
  function rN(X, Q) {
    if (typeof Q == "boolean") return Q;
    if (Object.keys(Q).length === 0) return true;
    return PG(X, Q), !SG(Q, X.self.RULES.all);
  }
  vG.alwaysValidSchema = rN;
  function PG(X, Q = X.schema) {
    let { opts: $, self: Y } = X;
    if (!$.strictSchema) return;
    if (typeof Q === "boolean") return;
    let W = Y.RULES.keywords;
    for (let J in Q) if (!W[J]) kG(X, `unknown keyword: "${J}"`);
  }
  vG.checkUnknownRules = PG;
  function SG(X, Q) {
    if (typeof X == "boolean") return !X;
    for (let $ in X) if (Q[$]) return true;
    return false;
  }
  vG.schemaHasRules = SG;
  function oN(X, Q) {
    if (typeof X == "boolean") return !X;
    for (let $ in X) if ($ !== "$ref" && Q.all[$]) return true;
    return false;
  }
  vG.schemaHasRulesButRef = oN;
  function tN({ topSchemaRef: X, schemaPath: Q }, $, Y, W) {
    if (!W) {
      if (typeof $ == "number" || typeof $ == "boolean") return $;
      if (typeof $ == "string") return $0._`${$}`;
    }
    return $0._`${X}${Q}${(0, $0.getProperty)(Y)}`;
  }
  vG.schemaRefOrVal = tN;
  function aN(X) {
    return ZG(decodeURIComponent(X));
  }
  vG.unescapeFragment = aN;
  function sN(X) {
    return encodeURIComponent(HY(X));
  }
  vG.escapeFragment = sN;
  function HY(X) {
    if (typeof X == "number") return `${X}`;
    return X.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  vG.escapeJsonPointer = HY;
  function ZG(X) {
    return X.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  vG.unescapeJsonPointer = ZG;
  function eN(X, Q) {
    if (Array.isArray(X)) for (let $ of X) Q($);
    else Q(X);
  }
  vG.eachItem = eN;
  function EG({ mergeNames: X, mergeToName: Q, mergeValues: $, resultToName: Y }) {
    return (W, J, G, H) => {
      let B = G === void 0 ? J : G instanceof $0.Name ? (J instanceof $0.Name ? X(W, J, G) : Q(W, J, G), G) : J instanceof $0.Name ? (Q(W, G, J), J) : $(J, G);
      return H === $0.Name && !(B instanceof $0.Name) ? Y(W, B) : B;
    };
  }
  vG.mergeEvaluated = { props: EG({ mergeNames: (X, Q, $) => X.if($0._`${$} !== true && ${Q} !== undefined`, () => {
    X.if($0._`${Q} === true`, () => X.assign($, true), () => X.assign($, $0._`${$} || {}`).code($0._`Object.assign(${$}, ${Q})`));
  }), mergeToName: (X, Q, $) => X.if($0._`${$} !== true`, () => {
    if (Q === true) X.assign($, true);
    else X.assign($, $0._`${$} || {}`), BY(X, $, Q);
  }), mergeValues: (X, Q) => X === true ? true : { ...X, ...Q }, resultToName: CG }), items: EG({ mergeNames: (X, Q, $) => X.if($0._`${$} !== true && ${Q} !== undefined`, () => X.assign($, $0._`${Q} === true ? true : ${$} > ${Q} ? ${$} : ${Q}`)), mergeToName: (X, Q, $) => X.if($0._`${$} !== true`, () => X.assign($, Q === true ? true : $0._`${$} > ${Q} ? ${$} : ${Q}`)), mergeValues: (X, Q) => X === true ? true : Math.max(X, Q), resultToName: (X, Q) => X.var("items", Q) }) };
  function CG(X, Q) {
    if (Q === true) return X.var("props", true);
    let $ = X.var("props", $0._`{}`);
    if (Q !== void 0) BY(X, $, Q);
    return $;
  }
  vG.evaluatedPropsToName = CG;
  function BY(X, Q, $) {
    Object.keys($).forEach((Y) => X.assign($0._`${Q}${(0, $0.getProperty)(Y)}`, true));
  }
  vG.setEvaluated = BY;
  var bG = {};
  function XO(X, Q) {
    return X.scopeValue("func", { ref: Q, code: bG[Q.code] || (bG[Q.code] = new iN._Code(Q.code)) });
  }
  vG.useFunc = XO;
  var GY;
  (function(X) {
    X[X.Num = 0] = "Num", X[X.Str = 1] = "Str";
  })(GY || (vG.Type = GY = {}));
  function QO(X, Q, $) {
    if (X instanceof $0.Name) {
      let Y = Q === GY.Num;
      return $ ? Y ? $0._`"[" + ${X} + "]"` : $0._`"['" + ${X} + "']"` : Y ? $0._`"/" + ${X}` : $0._`"/" + ${X}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return $ ? (0, $0.getProperty)(X).toString() : "/" + HY(X);
  }
  vG.getErrorPath = QO;
  function kG(X, Q, $ = X.opts.strictSchema) {
    if (!$) return;
    if (Q = `strict mode: ${Q}`, $ === true) throw Error(Q);
    X.self.logger.warn(Q);
  }
  vG.checkStrictMode = kG;
});
var R1 = P((_G) => {
  Object.defineProperty(_G, "__esModule", { value: true });
  var P0 = c(), AO = { data: new P0.Name("data"), valCxt: new P0.Name("valCxt"), instancePath: new P0.Name("instancePath"), parentData: new P0.Name("parentData"), parentDataProperty: new P0.Name("parentDataProperty"), rootData: new P0.Name("rootData"), dynamicAnchors: new P0.Name("dynamicAnchors"), vErrors: new P0.Name("vErrors"), errors: new P0.Name("errors"), this: new P0.Name("this"), self: new P0.Name("self"), scope: new P0.Name("scope"), json: new P0.Name("json"), jsonPos: new P0.Name("jsonPos"), jsonLen: new P0.Name("jsonLen"), jsonPart: new P0.Name("jsonPart") };
  _G.default = AO;
});
var lX = P((fG) => {
  Object.defineProperty(fG, "__esModule", { value: true });
  fG.extendErrors = fG.resetErrorsCount = fG.reportExtraError = fG.reportError = fG.keyword$DataError = fG.keywordError = void 0;
  var a = c(), Z8 = e(), v0 = R1();
  fG.keywordError = { message: ({ keyword: X }) => a.str`must pass "${X}" keyword validation` };
  fG.keyword$DataError = { message: ({ keyword: X, schemaType: Q }) => Q ? a.str`"${X}" keyword must be ${Q} ($data)` : a.str`"${X}" keyword is invalid ($data)` };
  function MO(X, Q = fG.keywordError, $, Y) {
    let { it: W } = X, { gen: J, compositeRule: G, allErrors: H } = W, B = gG(X, Q, $);
    if (Y !== null && Y !== void 0 ? Y : G || H) xG(J, B);
    else yG(W, a._`[${B}]`);
  }
  fG.reportError = MO;
  function jO(X, Q = fG.keywordError, $) {
    let { it: Y } = X, { gen: W, compositeRule: J, allErrors: G } = Y, H = gG(X, Q, $);
    if (xG(W, H), !(J || G)) yG(Y, v0.default.vErrors);
  }
  fG.reportExtraError = jO;
  function RO(X, Q) {
    X.assign(v0.default.errors, Q), X.if(a._`${v0.default.vErrors} !== null`, () => X.if(Q, () => X.assign(a._`${v0.default.vErrors}.length`, Q), () => X.assign(v0.default.vErrors, null)));
  }
  fG.resetErrorsCount = RO;
  function IO({ gen: X, keyword: Q, schemaValue: $, data: Y, errsCount: W, it: J }) {
    if (W === void 0) throw Error("ajv implementation error");
    let G = X.name("err");
    X.forRange("i", W, v0.default.errors, (H) => {
      if (X.const(G, a._`${v0.default.vErrors}[${H}]`), X.if(a._`${G}.instancePath === undefined`, () => X.assign(a._`${G}.instancePath`, (0, a.strConcat)(v0.default.instancePath, J.errorPath))), X.assign(a._`${G}.schemaPath`, a.str`${J.errSchemaPath}/${Q}`), J.opts.verbose) X.assign(a._`${G}.schema`, $), X.assign(a._`${G}.data`, Y);
    });
  }
  fG.extendErrors = IO;
  function xG(X, Q) {
    let $ = X.const("err", Q);
    X.if(a._`${v0.default.vErrors} === null`, () => X.assign(v0.default.vErrors, a._`[${$}]`), a._`${v0.default.vErrors}.push(${$})`), X.code(a._`${v0.default.errors}++`);
  }
  function yG(X, Q) {
    let { gen: $, validateName: Y, schemaEnv: W } = X;
    if (W.$async) $.throw(a._`new ${X.ValidationError}(${Q})`);
    else $.assign(a._`${Y}.errors`, Q), $.return(false);
  }
  var G6 = { keyword: new a.Name("keyword"), schemaPath: new a.Name("schemaPath"), params: new a.Name("params"), propertyName: new a.Name("propertyName"), message: new a.Name("message"), schema: new a.Name("schema"), parentSchema: new a.Name("parentSchema") };
  function gG(X, Q, $) {
    let { createErrors: Y } = X.it;
    if (Y === false) return a._`{}`;
    return EO(X, Q, $);
  }
  function EO(X, Q, $ = {}) {
    let { gen: Y, it: W } = X, J = [bO(W, $), PO(X, $)];
    return SO(X, Q, J), Y.object(...J);
  }
  function bO({ errorPath: X }, { instancePath: Q }) {
    let $ = Q ? a.str`${X}${(0, Z8.getErrorPath)(Q, Z8.Type.Str)}` : X;
    return [v0.default.instancePath, (0, a.strConcat)(v0.default.instancePath, $)];
  }
  function PO({ keyword: X, it: { errSchemaPath: Q } }, { schemaPath: $, parentSchema: Y }) {
    let W = Y ? Q : a.str`${Q}/${X}`;
    if ($) W = a.str`${W}${(0, Z8.getErrorPath)($, Z8.Type.Str)}`;
    return [G6.schemaPath, W];
  }
  function SO(X, { params: Q, message: $ }, Y) {
    let { keyword: W, data: J, schemaValue: G, it: H } = X, { opts: B, propertyName: z, topSchemaRef: K, schemaPath: V } = H;
    if (Y.push([G6.keyword, W], [G6.params, typeof Q == "function" ? Q(X) : Q || a._`{}`]), B.messages) Y.push([G6.message, typeof $ == "function" ? $(X) : $]);
    if (B.verbose) Y.push([G6.schema, G], [G6.parentSchema, a._`${K}${V}`], [v0.default.data, J]);
    if (z) Y.push([G6.propertyName, z]);
  }
});
var cG = P((lG) => {
  Object.defineProperty(lG, "__esModule", { value: true });
  lG.boolOrEmptySchema = lG.topBoolOrEmptySchema = void 0;
  var TO = lX(), _O = c(), xO = R1(), yO = { message: "boolean schema is false" };
  function gO(X) {
    let { gen: Q, schema: $, validateName: Y } = X;
    if ($ === false) uG(X, false);
    else if (typeof $ == "object" && $.$async === true) Q.return(xO.default.data);
    else Q.assign(_O._`${Y}.errors`, null), Q.return(true);
  }
  lG.topBoolOrEmptySchema = gO;
  function fO(X, Q) {
    let { gen: $, schema: Y } = X;
    if (Y === false) $.var(Q, false), uG(X);
    else $.var(Q, true);
  }
  lG.boolOrEmptySchema = fO;
  function uG(X, Q) {
    let { gen: $, data: Y } = X, W = { gen: $, keyword: "false schema", data: Y, schema: false, schemaCode: false, schemaValue: false, params: {}, it: X };
    (0, TO.reportError)(W, yO, void 0, Q);
  }
});
var KY = P((pG) => {
  Object.defineProperty(pG, "__esModule", { value: true });
  pG.getRules = pG.isJSONType = void 0;
  var uO = ["string", "number", "integer", "boolean", "null", "object", "array"], lO = new Set(uO);
  function mO(X) {
    return typeof X == "string" && lO.has(X);
  }
  pG.isJSONType = mO;
  function cO() {
    let X = { number: { type: "number", rules: [] }, string: { type: "string", rules: [] }, array: { type: "array", rules: [] }, object: { type: "object", rules: [] } };
    return { types: { ...X, integer: true, boolean: true, null: true }, rules: [{ rules: [] }, X.number, X.string, X.array, X.object], post: { rules: [] }, all: {}, keywords: {} };
  }
  pG.getRules = cO;
});
var UY = P((rG) => {
  Object.defineProperty(rG, "__esModule", { value: true });
  rG.shouldUseRule = rG.shouldUseGroup = rG.schemaHasRulesForType = void 0;
  function dO({ schema: X, self: Q }, $) {
    let Y = Q.RULES.types[$];
    return Y && Y !== true && iG(X, Y);
  }
  rG.schemaHasRulesForType = dO;
  function iG(X, Q) {
    return Q.rules.some(($) => nG(X, $));
  }
  rG.shouldUseGroup = iG;
  function nG(X, Q) {
    var $;
    return X[Q.keyword] !== void 0 || (($ = Q.definition.implements) === null || $ === void 0 ? void 0 : $.some((Y) => X[Y] !== void 0));
  }
  rG.shouldUseRule = nG;
});
var mX = P((eG) => {
  Object.defineProperty(eG, "__esModule", { value: true });
  eG.reportTypeError = eG.checkDataTypes = eG.checkDataType = eG.coerceAndCheckDataType = eG.getJSONTypes = eG.getSchemaTypes = eG.DataType = void 0;
  var rO = KY(), oO = UY(), tO = lX(), m = c(), tG = e(), l6;
  (function(X) {
    X[X.Correct = 0] = "Correct", X[X.Wrong = 1] = "Wrong";
  })(l6 || (eG.DataType = l6 = {}));
  function aO(X) {
    let Q = aG(X.type);
    if (Q.includes("null")) {
      if (X.nullable === false) throw Error("type: null contradicts nullable: false");
    } else {
      if (!Q.length && X.nullable !== void 0) throw Error('"nullable" cannot be used without "type"');
      if (X.nullable === true) Q.push("null");
    }
    return Q;
  }
  eG.getSchemaTypes = aO;
  function aG(X) {
    let Q = Array.isArray(X) ? X : X ? [X] : [];
    if (Q.every(rO.isJSONType)) return Q;
    throw Error("type must be JSONType or JSONType[]: " + Q.join(","));
  }
  eG.getJSONTypes = aG;
  function sO(X, Q) {
    let { gen: $, data: Y, opts: W } = X, J = eO(Q, W.coerceTypes), G = Q.length > 0 && !(J.length === 0 && Q.length === 1 && (0, oO.schemaHasRulesForType)(X, Q[0]));
    if (G) {
      let H = LY(Q, Y, W.strictNumbers, l6.Wrong);
      $.if(H, () => {
        if (J.length) XD(X, Q, J);
        else qY(X);
      });
    }
    return G;
  }
  eG.coerceAndCheckDataType = sO;
  var sG = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function eO(X, Q) {
    return Q ? X.filter(($) => sG.has($) || Q === "array" && $ === "array") : [];
  }
  function XD(X, Q, $) {
    let { gen: Y, data: W, opts: J } = X, G = Y.let("dataType", m._`typeof ${W}`), H = Y.let("coerced", m._`undefined`);
    if (J.coerceTypes === "array") Y.if(m._`${G} == 'object' && Array.isArray(${W}) && ${W}.length == 1`, () => Y.assign(W, m._`${W}[0]`).assign(G, m._`typeof ${W}`).if(LY(Q, W, J.strictNumbers), () => Y.assign(H, W)));
    Y.if(m._`${H} !== undefined`);
    for (let z of $) if (sG.has(z) || z === "array" && J.coerceTypes === "array") B(z);
    Y.else(), qY(X), Y.endIf(), Y.if(m._`${H} !== undefined`, () => {
      Y.assign(W, H), QD(X, H);
    });
    function B(z) {
      switch (z) {
        case "string":
          Y.elseIf(m._`${G} == "number" || ${G} == "boolean"`).assign(H, m._`"" + ${W}`).elseIf(m._`${W} === null`).assign(H, m._`""`);
          return;
        case "number":
          Y.elseIf(m._`${G} == "boolean" || ${W} === null
              || (${G} == "string" && ${W} && ${W} == +${W})`).assign(H, m._`+${W}`);
          return;
        case "integer":
          Y.elseIf(m._`${G} === "boolean" || ${W} === null
              || (${G} === "string" && ${W} && ${W} == +${W} && !(${W} % 1))`).assign(H, m._`+${W}`);
          return;
        case "boolean":
          Y.elseIf(m._`${W} === "false" || ${W} === 0 || ${W} === null`).assign(H, false).elseIf(m._`${W} === "true" || ${W} === 1`).assign(H, true);
          return;
        case "null":
          Y.elseIf(m._`${W} === "" || ${W} === 0 || ${W} === false`), Y.assign(H, null);
          return;
        case "array":
          Y.elseIf(m._`${G} === "string" || ${G} === "number"
              || ${G} === "boolean" || ${W} === null`).assign(H, m._`[${W}]`);
      }
    }
  }
  function QD({ gen: X, parentData: Q, parentDataProperty: $ }, Y) {
    X.if(m._`${Q} !== undefined`, () => X.assign(m._`${Q}[${$}]`, Y));
  }
  function VY(X, Q, $, Y = l6.Correct) {
    let W = Y === l6.Correct ? m.operators.EQ : m.operators.NEQ, J;
    switch (X) {
      case "null":
        return m._`${Q} ${W} null`;
      case "array":
        J = m._`Array.isArray(${Q})`;
        break;
      case "object":
        J = m._`${Q} && typeof ${Q} == "object" && !Array.isArray(${Q})`;
        break;
      case "integer":
        J = G(m._`!(${Q} % 1) && !isNaN(${Q})`);
        break;
      case "number":
        J = G();
        break;
      default:
        return m._`typeof ${Q} ${W} ${X}`;
    }
    return Y === l6.Correct ? J : (0, m.not)(J);
    function G(H = m.nil) {
      return (0, m.and)(m._`typeof ${Q} == "number"`, H, $ ? m._`isFinite(${Q})` : m.nil);
    }
  }
  eG.checkDataType = VY;
  function LY(X, Q, $, Y) {
    if (X.length === 1) return VY(X[0], Q, $, Y);
    let W, J = (0, tG.toHash)(X);
    if (J.array && J.object) {
      let G = m._`typeof ${Q} != "object"`;
      W = J.null ? G : m._`!${Q} || ${G}`, delete J.null, delete J.array, delete J.object;
    } else W = m.nil;
    if (J.number) delete J.integer;
    for (let G in J) W = (0, m.and)(W, VY(G, Q, $, Y));
    return W;
  }
  eG.checkDataTypes = LY;
  var $D = { message: ({ schema: X }) => `must be ${X}`, params: ({ schema: X, schemaValue: Q }) => typeof X == "string" ? m._`{type: ${X}}` : m._`{type: ${Q}}` };
  function qY(X) {
    let Q = YD(X);
    (0, tO.reportError)(Q, $D);
  }
  eG.reportTypeError = qY;
  function YD(X) {
    let { gen: Q, data: $, schema: Y } = X, W = (0, tG.schemaRefOrVal)(X, Y, "type");
    return { gen: Q, keyword: "type", data: $, schema: Y.type, schemaCode: W, schemaValue: W, parentSchema: Y, params: {}, it: X };
  }
});
var W3 = P(($3) => {
  Object.defineProperty($3, "__esModule", { value: true });
  $3.assignDefaults = void 0;
  var m6 = c(), KD = e();
  function UD(X, Q) {
    let { properties: $, items: Y } = X.schema;
    if (Q === "object" && $) for (let W in $) Q3(X, W, $[W].default);
    else if (Q === "array" && Array.isArray(Y)) Y.forEach((W, J) => Q3(X, J, W.default));
  }
  $3.assignDefaults = UD;
  function Q3(X, Q, $) {
    let { gen: Y, compositeRule: W, data: J, opts: G } = X;
    if ($ === void 0) return;
    let H = m6._`${J}${(0, m6.getProperty)(Q)}`;
    if (W) {
      (0, KD.checkStrictMode)(X, `default is ignored for: ${H}`);
      return;
    }
    let B = m6._`${H} === undefined`;
    if (G.useDefaults === "empty") B = m6._`${B} || ${H} === null || ${H} === ""`;
    Y.if(B, m6._`${H} = ${(0, m6.stringify)($)}`);
  }
});
var d0 = P((H3) => {
  Object.defineProperty(H3, "__esModule", { value: true });
  H3.validateUnion = H3.validateArray = H3.usePattern = H3.callValidateCode = H3.schemaProperties = H3.allSchemaProperties = H3.noPropertyInData = H3.propertyInData = H3.isOwnProperty = H3.hasPropFunc = H3.reportMissingProp = H3.checkMissingProp = H3.checkReportMissingProp = void 0;
  var G0 = c(), FY = e(), p1 = R1(), VD = e();
  function LD(X, Q) {
    let { gen: $, data: Y, it: W } = X;
    $.if(OY($, Y, Q, W.opts.ownProperties), () => {
      X.setParams({ missingProperty: G0._`${Q}` }, true), X.error();
    });
  }
  H3.checkReportMissingProp = LD;
  function qD({ gen: X, data: Q, it: { opts: $ } }, Y, W) {
    return (0, G0.or)(...Y.map((J) => (0, G0.and)(OY(X, Q, J, $.ownProperties), G0._`${W} = ${J}`)));
  }
  H3.checkMissingProp = qD;
  function FD(X, Q) {
    X.setParams({ missingProperty: Q }, true), X.error();
  }
  H3.reportMissingProp = FD;
  function J3(X) {
    return X.scopeValue("func", { ref: Object.prototype.hasOwnProperty, code: G0._`Object.prototype.hasOwnProperty` });
  }
  H3.hasPropFunc = J3;
  function NY(X, Q, $) {
    return G0._`${J3(X)}.call(${Q}, ${$})`;
  }
  H3.isOwnProperty = NY;
  function ND(X, Q, $, Y) {
    let W = G0._`${Q}${(0, G0.getProperty)($)} !== undefined`;
    return Y ? G0._`${W} && ${NY(X, Q, $)}` : W;
  }
  H3.propertyInData = ND;
  function OY(X, Q, $, Y) {
    let W = G0._`${Q}${(0, G0.getProperty)($)} === undefined`;
    return Y ? (0, G0.or)(W, (0, G0.not)(NY(X, Q, $))) : W;
  }
  H3.noPropertyInData = OY;
  function G3(X) {
    return X ? Object.keys(X).filter((Q) => Q !== "__proto__") : [];
  }
  H3.allSchemaProperties = G3;
  function OD(X, Q) {
    return G3(Q).filter(($) => !(0, FY.alwaysValidSchema)(X, Q[$]));
  }
  H3.schemaProperties = OD;
  function DD({ schemaCode: X, data: Q, it: { gen: $, topSchemaRef: Y, schemaPath: W, errorPath: J }, it: G }, H, B, z) {
    let K = z ? G0._`${X}, ${Q}, ${Y}${W}` : Q, V = [[p1.default.instancePath, (0, G0.strConcat)(p1.default.instancePath, J)], [p1.default.parentData, G.parentData], [p1.default.parentDataProperty, G.parentDataProperty], [p1.default.rootData, p1.default.rootData]];
    if (G.opts.dynamicRef) V.push([p1.default.dynamicAnchors, p1.default.dynamicAnchors]);
    let L = G0._`${K}, ${$.object(...V)}`;
    return B !== G0.nil ? G0._`${H}.call(${B}, ${L})` : G0._`${H}(${L})`;
  }
  H3.callValidateCode = DD;
  var AD = G0._`new RegExp`;
  function wD({ gen: X, it: { opts: Q } }, $) {
    let Y = Q.unicodeRegExp ? "u" : "", { regExp: W } = Q.code, J = W($, Y);
    return X.scopeValue("pattern", { key: J.toString(), ref: J, code: G0._`${W.code === "new RegExp" ? AD : (0, VD.useFunc)(X, W)}(${$}, ${Y})` });
  }
  H3.usePattern = wD;
  function MD(X) {
    let { gen: Q, data: $, keyword: Y, it: W } = X, J = Q.name("valid");
    if (W.allErrors) {
      let H = Q.let("valid", true);
      return G(() => Q.assign(H, false)), H;
    }
    return Q.var(J, true), G(() => Q.break()), J;
    function G(H) {
      let B = Q.const("len", G0._`${$}.length`);
      Q.forRange("i", 0, B, (z) => {
        X.subschema({ keyword: Y, dataProp: z, dataPropType: FY.Type.Num }, J), Q.if((0, G0.not)(J), H);
      });
    }
  }
  H3.validateArray = MD;
  function jD(X) {
    let { gen: Q, schema: $, keyword: Y, it: W } = X;
    if (!Array.isArray($)) throw Error("ajv implementation error");
    if ($.some((B) => (0, FY.alwaysValidSchema)(W, B)) && !W.opts.unevaluated) return;
    let G = Q.let("valid", false), H = Q.name("_valid");
    Q.block(() => $.forEach((B, z) => {
      let K = X.subschema({ keyword: Y, schemaProp: z, compositeRule: true }, H);
      if (Q.assign(G, G0._`${G} || ${H}`), !X.mergeValidEvaluated(K, H)) Q.if((0, G0.not)(G));
    })), X.result(G, () => X.reset(), () => X.error(true));
  }
  H3.validateUnion = jD;
});
var L3 = P((U3) => {
  Object.defineProperty(U3, "__esModule", { value: true });
  U3.validateKeywordUsage = U3.validSchemaType = U3.funcKeywordCode = U3.macroKeywordCode = void 0;
  var T0 = c(), H6 = R1(), xD = d0(), yD = lX();
  function gD(X, Q) {
    let { gen: $, keyword: Y, schema: W, parentSchema: J, it: G } = X, H = Q.macro.call(G.self, W, J, G), B = K3($, Y, H);
    if (G.opts.validateSchema !== false) G.self.validateSchema(H, true);
    let z = $.name("valid");
    X.subschema({ schema: H, schemaPath: T0.nil, errSchemaPath: `${G.errSchemaPath}/${Y}`, topSchemaRef: B, compositeRule: true }, z), X.pass(z, () => X.error(true));
  }
  U3.macroKeywordCode = gD;
  function fD(X, Q) {
    var $;
    let { gen: Y, keyword: W, schema: J, parentSchema: G, $data: H, it: B } = X;
    uD(B, Q);
    let z = !H && Q.compile ? Q.compile.call(B.self, J, G, B) : Q.validate, K = K3(Y, W, z), V = Y.let("valid");
    X.block$data(V, L), X.ok(($ = Q.valid) !== null && $ !== void 0 ? $ : V);
    function L() {
      if (Q.errors === false) {
        if (q(), Q.modifying) z3(X);
        N(() => X.error());
      } else {
        let A = Q.async ? U() : F();
        if (Q.modifying) z3(X);
        N(() => hD(X, A));
      }
    }
    function U() {
      let A = Y.let("ruleErrs", null);
      return Y.try(() => q(T0._`await `), (M) => Y.assign(V, false).if(T0._`${M} instanceof ${B.ValidationError}`, () => Y.assign(A, T0._`${M}.errors`), () => Y.throw(M))), A;
    }
    function F() {
      let A = T0._`${K}.errors`;
      return Y.assign(A, null), q(T0.nil), A;
    }
    function q(A = Q.async ? T0._`await ` : T0.nil) {
      let M = B.opts.passContext ? H6.default.this : H6.default.self, R = !("compile" in Q && !H || Q.schema === false);
      Y.assign(V, T0._`${A}${(0, xD.callValidateCode)(X, K, M, R)}`, Q.modifying);
    }
    function N(A) {
      var M;
      Y.if((0, T0.not)((M = Q.valid) !== null && M !== void 0 ? M : V), A);
    }
  }
  U3.funcKeywordCode = fD;
  function z3(X) {
    let { gen: Q, data: $, it: Y } = X;
    Q.if(Y.parentData, () => Q.assign($, T0._`${Y.parentData}[${Y.parentDataProperty}]`));
  }
  function hD(X, Q) {
    let { gen: $ } = X;
    $.if(T0._`Array.isArray(${Q})`, () => {
      $.assign(H6.default.vErrors, T0._`${H6.default.vErrors} === null ? ${Q} : ${H6.default.vErrors}.concat(${Q})`).assign(H6.default.errors, T0._`${H6.default.vErrors}.length`), (0, yD.extendErrors)(X);
    }, () => X.error());
  }
  function uD({ schemaEnv: X }, Q) {
    if (Q.async && !X.$async) throw Error("async keyword in sync schema");
  }
  function K3(X, Q, $) {
    if ($ === void 0) throw Error(`keyword "${Q}" failed to compile`);
    return X.scopeValue("keyword", typeof $ == "function" ? { ref: $ } : { ref: $, code: (0, T0.stringify)($) });
  }
  function lD(X, Q, $ = false) {
    return !Q.length || Q.some((Y) => Y === "array" ? Array.isArray(X) : Y === "object" ? X && typeof X == "object" && !Array.isArray(X) : typeof X == Y || $ && typeof X > "u");
  }
  U3.validSchemaType = lD;
  function mD({ schema: X, opts: Q, self: $, errSchemaPath: Y }, W, J) {
    if (Array.isArray(W.keyword) ? !W.keyword.includes(J) : W.keyword !== J) throw Error("ajv implementation error");
    let G = W.dependencies;
    if (G === null || G === void 0 ? void 0 : G.some((H) => !Object.prototype.hasOwnProperty.call(X, H))) throw Error(`parent schema must have dependencies of ${J}: ${G.join(",")}`);
    if (W.validateSchema) {
      if (!W.validateSchema(X[J])) {
        let B = `keyword "${J}" value is invalid at path "${Y}": ` + $.errorsText(W.validateSchema.errors);
        if (Q.validateSchema === "log") $.logger.error(B);
        else throw Error(B);
      }
    }
  }
  U3.validateKeywordUsage = mD;
});
var O3 = P((F3) => {
  Object.defineProperty(F3, "__esModule", { value: true });
  F3.extendSubschemaMode = F3.extendSubschemaData = F3.getSubschema = void 0;
  var U1 = c(), q3 = e();
  function iD(X, { keyword: Q, schemaProp: $, schema: Y, schemaPath: W, errSchemaPath: J, topSchemaRef: G }) {
    if (Q !== void 0 && Y !== void 0) throw Error('both "keyword" and "schema" passed, only one allowed');
    if (Q !== void 0) {
      let H = X.schema[Q];
      return $ === void 0 ? { schema: H, schemaPath: U1._`${X.schemaPath}${(0, U1.getProperty)(Q)}`, errSchemaPath: `${X.errSchemaPath}/${Q}` } : { schema: H[$], schemaPath: U1._`${X.schemaPath}${(0, U1.getProperty)(Q)}${(0, U1.getProperty)($)}`, errSchemaPath: `${X.errSchemaPath}/${Q}/${(0, q3.escapeFragment)($)}` };
    }
    if (Y !== void 0) {
      if (W === void 0 || J === void 0 || G === void 0) throw Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return { schema: Y, schemaPath: W, topSchemaRef: G, errSchemaPath: J };
    }
    throw Error('either "keyword" or "schema" must be passed');
  }
  F3.getSubschema = iD;
  function nD(X, Q, { dataProp: $, dataPropType: Y, data: W, dataTypes: J, propertyName: G }) {
    if (W !== void 0 && $ !== void 0) throw Error('both "data" and "dataProp" passed, only one allowed');
    let { gen: H } = Q;
    if ($ !== void 0) {
      let { errorPath: z, dataPathArr: K, opts: V } = Q, L = H.let("data", U1._`${Q.data}${(0, U1.getProperty)($)}`, true);
      B(L), X.errorPath = U1.str`${z}${(0, q3.getErrorPath)($, Y, V.jsPropertySyntax)}`, X.parentDataProperty = U1._`${$}`, X.dataPathArr = [...K, X.parentDataProperty];
    }
    if (W !== void 0) {
      let z = W instanceof U1.Name ? W : H.let("data", W, true);
      if (B(z), G !== void 0) X.propertyName = G;
    }
    if (J) X.dataTypes = J;
    function B(z) {
      X.data = z, X.dataLevel = Q.dataLevel + 1, X.dataTypes = [], Q.definedProperties = /* @__PURE__ */ new Set(), X.parentData = Q.data, X.dataNames = [...Q.dataNames, z];
    }
  }
  F3.extendSubschemaData = nD;
  function rD(X, { jtdDiscriminator: Q, jtdMetadata: $, compositeRule: Y, createErrors: W, allErrors: J }) {
    if (Y !== void 0) X.compositeRule = Y;
    if (W !== void 0) X.createErrors = W;
    if (J !== void 0) X.allErrors = J;
    X.jtdDiscriminator = Q, X.jtdMetadata = $;
  }
  F3.extendSubschemaMode = rD;
});
var DY = P((ev, D3) => {
  D3.exports = function X(Q, $) {
    if (Q === $) return true;
    if (Q && $ && typeof Q == "object" && typeof $ == "object") {
      if (Q.constructor !== $.constructor) return false;
      var Y, W, J;
      if (Array.isArray(Q)) {
        if (Y = Q.length, Y != $.length) return false;
        for (W = Y; W-- !== 0; ) if (!X(Q[W], $[W])) return false;
        return true;
      }
      if (Q.constructor === RegExp) return Q.source === $.source && Q.flags === $.flags;
      if (Q.valueOf !== Object.prototype.valueOf) return Q.valueOf() === $.valueOf();
      if (Q.toString !== Object.prototype.toString) return Q.toString() === $.toString();
      if (J = Object.keys(Q), Y = J.length, Y !== Object.keys($).length) return false;
      for (W = Y; W-- !== 0; ) if (!Object.prototype.hasOwnProperty.call($, J[W])) return false;
      for (W = Y; W-- !== 0; ) {
        var G = J[W];
        if (!X(Q[G], $[G])) return false;
      }
      return true;
    }
    return Q !== Q && $ !== $;
  };
});
var w3 = P((XT, A3) => {
  var d1 = A3.exports = function(X, Q, $) {
    if (typeof Q == "function") $ = Q, Q = {};
    $ = Q.cb || $;
    var Y = typeof $ == "function" ? $ : $.pre || function() {
    }, W = $.post || function() {
    };
    C8(Q, Y, W, X, "", X);
  };
  d1.keywords = { additionalItems: true, items: true, contains: true, additionalProperties: true, propertyNames: true, not: true, if: true, then: true, else: true };
  d1.arrayKeywords = { items: true, allOf: true, anyOf: true, oneOf: true };
  d1.propsKeywords = { $defs: true, definitions: true, properties: true, patternProperties: true, dependencies: true };
  d1.skipKeywords = { default: true, enum: true, const: true, required: true, maximum: true, minimum: true, exclusiveMaximum: true, exclusiveMinimum: true, multipleOf: true, maxLength: true, minLength: true, pattern: true, format: true, maxItems: true, minItems: true, uniqueItems: true, maxProperties: true, minProperties: true };
  function C8(X, Q, $, Y, W, J, G, H, B, z) {
    if (Y && typeof Y == "object" && !Array.isArray(Y)) {
      Q(Y, W, J, G, H, B, z);
      for (var K in Y) {
        var V = Y[K];
        if (Array.isArray(V)) {
          if (K in d1.arrayKeywords) for (var L = 0; L < V.length; L++) C8(X, Q, $, V[L], W + "/" + K + "/" + L, J, W, K, Y, L);
        } else if (K in d1.propsKeywords) {
          if (V && typeof V == "object") for (var U in V) C8(X, Q, $, V[U], W + "/" + K + "/" + aD(U), J, W, K, Y, U);
        } else if (K in d1.keywords || X.allKeys && !(K in d1.skipKeywords)) C8(X, Q, $, V, W + "/" + K, J, W, K, Y);
      }
      $(Y, W, J, G, H, B, z);
    }
  }
  function aD(X) {
    return X.replace(/~/g, "~0").replace(/\//g, "~1");
  }
});
var cX = P((I3) => {
  Object.defineProperty(I3, "__esModule", { value: true });
  I3.getSchemaRefs = I3.resolveUrl = I3.normalizeId = I3._getFullPath = I3.getFullPath = I3.inlineRef = void 0;
  var sD = e(), eD = DY(), XA = w3(), QA = /* @__PURE__ */ new Set(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum", "const"]);
  function $A(X, Q = true) {
    if (typeof X == "boolean") return true;
    if (Q === true) return !AY(X);
    if (!Q) return false;
    return M3(X) <= Q;
  }
  I3.inlineRef = $A;
  var YA = /* @__PURE__ */ new Set(["$ref", "$recursiveRef", "$recursiveAnchor", "$dynamicRef", "$dynamicAnchor"]);
  function AY(X) {
    for (let Q in X) {
      if (YA.has(Q)) return true;
      let $ = X[Q];
      if (Array.isArray($) && $.some(AY)) return true;
      if (typeof $ == "object" && AY($)) return true;
    }
    return false;
  }
  function M3(X) {
    let Q = 0;
    for (let $ in X) {
      if ($ === "$ref") return 1 / 0;
      if (Q++, QA.has($)) continue;
      if (typeof X[$] == "object") (0, sD.eachItem)(X[$], (Y) => Q += M3(Y));
      if (Q === 1 / 0) return 1 / 0;
    }
    return Q;
  }
  function j3(X, Q = "", $) {
    if ($ !== false) Q = c6(Q);
    let Y = X.parse(Q);
    return R3(X, Y);
  }
  I3.getFullPath = j3;
  function R3(X, Q) {
    return X.serialize(Q).split("#")[0] + "#";
  }
  I3._getFullPath = R3;
  var WA = /#\/?$/;
  function c6(X) {
    return X ? X.replace(WA, "") : "";
  }
  I3.normalizeId = c6;
  function JA(X, Q, $) {
    return $ = c6($), X.resolve(Q, $);
  }
  I3.resolveUrl = JA;
  var GA = /^[a-z_][-a-z0-9._]*$/i;
  function HA(X, Q) {
    if (typeof X == "boolean") return {};
    let { schemaId: $, uriResolver: Y } = this.opts, W = c6(X[$] || Q), J = { "": W }, G = j3(Y, W, false), H = {}, B = /* @__PURE__ */ new Set();
    return XA(X, { allKeys: true }, (V, L, U, F) => {
      if (F === void 0) return;
      let q = G + L, N = J[F];
      if (typeof V[$] == "string") N = A.call(this, V[$]);
      M.call(this, V.$anchor), M.call(this, V.$dynamicAnchor), J[L] = N;
      function A(R) {
        let S = this.opts.uriResolver.resolve;
        if (R = c6(N ? S(N, R) : R), B.has(R)) throw K(R);
        B.add(R);
        let C = this.refs[R];
        if (typeof C == "string") C = this.refs[C];
        if (typeof C == "object") z(V, C.schema, R);
        else if (R !== c6(q)) if (R[0] === "#") z(V, H[R], R), H[R] = V;
        else this.refs[R] = q;
        return R;
      }
      function M(R) {
        if (typeof R == "string") {
          if (!GA.test(R)) throw Error(`invalid anchor "${R}"`);
          A.call(this, `#${R}`);
        }
      }
    }), H;
    function z(V, L, U) {
      if (L !== void 0 && !eD(V, L)) throw K(U);
    }
    function K(V) {
      return Error(`reference "${V}" resolves to more than one schema`);
    }
  }
  I3.getSchemaRefs = HA;
});
var iX = P((u3) => {
  Object.defineProperty(u3, "__esModule", { value: true });
  u3.getData = u3.KeywordCxt = u3.validateFunctionCode = void 0;
  var C3 = cG(), b3 = mX(), MY = UY(), k8 = mX(), LA = W3(), dX = L3(), wY = O3(), _ = c(), u = R1(), qA = cX(), I1 = e(), pX = lX();
  function FA(X) {
    if (T3(X)) {
      if (_3(X), v3(X)) {
        DA(X);
        return;
      }
    }
    k3(X, () => (0, C3.topBoolOrEmptySchema)(X));
  }
  u3.validateFunctionCode = FA;
  function k3({ gen: X, validateName: Q, schema: $, schemaEnv: Y, opts: W }, J) {
    if (W.code.es5) X.func(Q, _._`${u.default.data}, ${u.default.valCxt}`, Y.$async, () => {
      X.code(_._`"use strict"; ${P3($, W)}`), OA(X, W), X.code(J);
    });
    else X.func(Q, _._`${u.default.data}, ${NA(W)}`, Y.$async, () => X.code(P3($, W)).code(J));
  }
  function NA(X) {
    return _._`{${u.default.instancePath}="", ${u.default.parentData}, ${u.default.parentDataProperty}, ${u.default.rootData}=${u.default.data}${X.dynamicRef ? _._`, ${u.default.dynamicAnchors}={}` : _.nil}}={}`;
  }
  function OA(X, Q) {
    X.if(u.default.valCxt, () => {
      if (X.var(u.default.instancePath, _._`${u.default.valCxt}.${u.default.instancePath}`), X.var(u.default.parentData, _._`${u.default.valCxt}.${u.default.parentData}`), X.var(u.default.parentDataProperty, _._`${u.default.valCxt}.${u.default.parentDataProperty}`), X.var(u.default.rootData, _._`${u.default.valCxt}.${u.default.rootData}`), Q.dynamicRef) X.var(u.default.dynamicAnchors, _._`${u.default.valCxt}.${u.default.dynamicAnchors}`);
    }, () => {
      if (X.var(u.default.instancePath, _._`""`), X.var(u.default.parentData, _._`undefined`), X.var(u.default.parentDataProperty, _._`undefined`), X.var(u.default.rootData, u.default.data), Q.dynamicRef) X.var(u.default.dynamicAnchors, _._`{}`);
    });
  }
  function DA(X) {
    let { schema: Q, opts: $, gen: Y } = X;
    k3(X, () => {
      if ($.$comment && Q.$comment) y3(X);
      if (RA(X), Y.let(u.default.vErrors, null), Y.let(u.default.errors, 0), $.unevaluated) AA(X);
      x3(X), bA(X);
    });
    return;
  }
  function AA(X) {
    let { gen: Q, validateName: $ } = X;
    X.evaluated = Q.const("evaluated", _._`${$}.evaluated`), Q.if(_._`${X.evaluated}.dynamicProps`, () => Q.assign(_._`${X.evaluated}.props`, _._`undefined`)), Q.if(_._`${X.evaluated}.dynamicItems`, () => Q.assign(_._`${X.evaluated}.items`, _._`undefined`));
  }
  function P3(X, Q) {
    let $ = typeof X == "object" && X[Q.schemaId];
    return $ && (Q.code.source || Q.code.process) ? _._`/*# sourceURL=${$} */` : _.nil;
  }
  function wA(X, Q) {
    if (T3(X)) {
      if (_3(X), v3(X)) {
        MA(X, Q);
        return;
      }
    }
    (0, C3.boolOrEmptySchema)(X, Q);
  }
  function v3({ schema: X, self: Q }) {
    if (typeof X == "boolean") return !X;
    for (let $ in X) if (Q.RULES.all[$]) return true;
    return false;
  }
  function T3(X) {
    return typeof X.schema != "boolean";
  }
  function MA(X, Q) {
    let { schema: $, gen: Y, opts: W } = X;
    if (W.$comment && $.$comment) y3(X);
    IA(X), EA(X);
    let J = Y.const("_errs", u.default.errors);
    x3(X, J), Y.var(Q, _._`${J} === ${u.default.errors}`);
  }
  function _3(X) {
    (0, I1.checkUnknownRules)(X), jA(X);
  }
  function x3(X, Q) {
    if (X.opts.jtd) return S3(X, [], false, Q);
    let $ = (0, b3.getSchemaTypes)(X.schema), Y = (0, b3.coerceAndCheckDataType)(X, $);
    S3(X, $, !Y, Q);
  }
  function jA(X) {
    let { schema: Q, errSchemaPath: $, opts: Y, self: W } = X;
    if (Q.$ref && Y.ignoreKeywordsWithRef && (0, I1.schemaHasRulesButRef)(Q, W.RULES)) W.logger.warn(`$ref: keywords ignored in schema at path "${$}"`);
  }
  function RA(X) {
    let { schema: Q, opts: $ } = X;
    if (Q.default !== void 0 && $.useDefaults && $.strictSchema) (0, I1.checkStrictMode)(X, "default is ignored in the schema root");
  }
  function IA(X) {
    let Q = X.schema[X.opts.schemaId];
    if (Q) X.baseId = (0, qA.resolveUrl)(X.opts.uriResolver, X.baseId, Q);
  }
  function EA(X) {
    if (X.schema.$async && !X.schemaEnv.$async) throw Error("async schema in sync schema");
  }
  function y3({ gen: X, schemaEnv: Q, schema: $, errSchemaPath: Y, opts: W }) {
    let J = $.$comment;
    if (W.$comment === true) X.code(_._`${u.default.self}.logger.log(${J})`);
    else if (typeof W.$comment == "function") {
      let G = _.str`${Y}/$comment`, H = X.scopeValue("root", { ref: Q.root });
      X.code(_._`${u.default.self}.opts.$comment(${J}, ${G}, ${H}.schema)`);
    }
  }
  function bA(X) {
    let { gen: Q, schemaEnv: $, validateName: Y, ValidationError: W, opts: J } = X;
    if ($.$async) Q.if(_._`${u.default.errors} === 0`, () => Q.return(u.default.data), () => Q.throw(_._`new ${W}(${u.default.vErrors})`));
    else {
      if (Q.assign(_._`${Y}.errors`, u.default.vErrors), J.unevaluated) PA(X);
      Q.return(_._`${u.default.errors} === 0`);
    }
  }
  function PA({ gen: X, evaluated: Q, props: $, items: Y }) {
    if ($ instanceof _.Name) X.assign(_._`${Q}.props`, $);
    if (Y instanceof _.Name) X.assign(_._`${Q}.items`, Y);
  }
  function S3(X, Q, $, Y) {
    let { gen: W, schema: J, data: G, allErrors: H, opts: B, self: z } = X, { RULES: K } = z;
    if (J.$ref && (B.ignoreKeywordsWithRef || !(0, I1.schemaHasRulesButRef)(J, K))) {
      W.block(() => f3(X, "$ref", K.all.$ref.definition));
      return;
    }
    if (!B.jtd) SA(X, Q);
    W.block(() => {
      for (let L of K.rules) V(L);
      V(K.post);
    });
    function V(L) {
      if (!(0, MY.shouldUseGroup)(J, L)) return;
      if (L.type) {
        if (W.if((0, k8.checkDataType)(L.type, G, B.strictNumbers)), Z3(X, L), Q.length === 1 && Q[0] === L.type && $) W.else(), (0, k8.reportTypeError)(X);
        W.endIf();
      } else Z3(X, L);
      if (!H) W.if(_._`${u.default.errors} === ${Y || 0}`);
    }
  }
  function Z3(X, Q) {
    let { gen: $, schema: Y, opts: { useDefaults: W } } = X;
    if (W) (0, LA.assignDefaults)(X, Q.type);
    $.block(() => {
      for (let J of Q.rules) if ((0, MY.shouldUseRule)(Y, J)) f3(X, J.keyword, J.definition, Q.type);
    });
  }
  function SA(X, Q) {
    if (X.schemaEnv.meta || !X.opts.strictTypes) return;
    if (ZA(X, Q), !X.opts.allowUnionTypes) CA(X, Q);
    kA(X, X.dataTypes);
  }
  function ZA(X, Q) {
    if (!Q.length) return;
    if (!X.dataTypes.length) {
      X.dataTypes = Q;
      return;
    }
    Q.forEach(($) => {
      if (!g3(X.dataTypes, $)) jY(X, `type "${$}" not allowed by context "${X.dataTypes.join(",")}"`);
    }), TA(X, Q);
  }
  function CA(X, Q) {
    if (Q.length > 1 && !(Q.length === 2 && Q.includes("null"))) jY(X, "use allowUnionTypes to allow union type keyword");
  }
  function kA(X, Q) {
    let $ = X.self.RULES.all;
    for (let Y in $) {
      let W = $[Y];
      if (typeof W == "object" && (0, MY.shouldUseRule)(X.schema, W)) {
        let { type: J } = W.definition;
        if (J.length && !J.some((G) => vA(Q, G))) jY(X, `missing type "${J.join(",")}" for keyword "${Y}"`);
      }
    }
  }
  function vA(X, Q) {
    return X.includes(Q) || Q === "number" && X.includes("integer");
  }
  function g3(X, Q) {
    return X.includes(Q) || Q === "integer" && X.includes("number");
  }
  function TA(X, Q) {
    let $ = [];
    for (let Y of X.dataTypes) if (g3(Q, Y)) $.push(Y);
    else if (Q.includes("integer") && Y === "number") $.push("integer");
    X.dataTypes = $;
  }
  function jY(X, Q) {
    let $ = X.schemaEnv.baseId + X.errSchemaPath;
    Q += ` at "${$}" (strictTypes)`, (0, I1.checkStrictMode)(X, Q, X.opts.strictTypes);
  }
  class RY {
    constructor(X, Q, $) {
      if ((0, dX.validateKeywordUsage)(X, Q, $), this.gen = X.gen, this.allErrors = X.allErrors, this.keyword = $, this.data = X.data, this.schema = X.schema[$], this.$data = Q.$data && X.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, I1.schemaRefOrVal)(X, this.schema, $, this.$data), this.schemaType = Q.schemaType, this.parentSchema = X.schema, this.params = {}, this.it = X, this.def = Q, this.$data) this.schemaCode = X.gen.const("vSchema", h3(this.$data, X));
      else if (this.schemaCode = this.schemaValue, !(0, dX.validSchemaType)(this.schema, Q.schemaType, Q.allowUndefined)) throw Error(`${$} value must be ${JSON.stringify(Q.schemaType)}`);
      if ("code" in Q ? Q.trackErrors : Q.errors !== false) this.errsCount = X.gen.const("_errs", u.default.errors);
    }
    result(X, Q, $) {
      this.failResult((0, _.not)(X), Q, $);
    }
    failResult(X, Q, $) {
      if (this.gen.if(X), $) $();
      else this.error();
      if (Q) {
        if (this.gen.else(), Q(), this.allErrors) this.gen.endIf();
      } else if (this.allErrors) this.gen.endIf();
      else this.gen.else();
    }
    pass(X, Q) {
      this.failResult((0, _.not)(X), void 0, Q);
    }
    fail(X) {
      if (X === void 0) {
        if (this.error(), !this.allErrors) this.gen.if(false);
        return;
      }
      if (this.gen.if(X), this.error(), this.allErrors) this.gen.endIf();
      else this.gen.else();
    }
    fail$data(X) {
      if (!this.$data) return this.fail(X);
      let { schemaCode: Q } = this;
      this.fail(_._`${Q} !== undefined && (${(0, _.or)(this.invalid$data(), X)})`);
    }
    error(X, Q, $) {
      if (Q) {
        this.setParams(Q), this._error(X, $), this.setParams({});
        return;
      }
      this._error(X, $);
    }
    _error(X, Q) {
      (X ? pX.reportExtraError : pX.reportError)(this, this.def.error, Q);
    }
    $dataError() {
      (0, pX.reportError)(this, this.def.$dataError || pX.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0) throw Error('add "trackErrors" to keyword definition');
      (0, pX.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(X) {
      if (!this.allErrors) this.gen.if(X);
    }
    setParams(X, Q) {
      if (Q) Object.assign(this.params, X);
      else this.params = X;
    }
    block$data(X, Q, $ = _.nil) {
      this.gen.block(() => {
        this.check$data(X, $), Q();
      });
    }
    check$data(X = _.nil, Q = _.nil) {
      if (!this.$data) return;
      let { gen: $, schemaCode: Y, schemaType: W, def: J } = this;
      if ($.if((0, _.or)(_._`${Y} === undefined`, Q)), X !== _.nil) $.assign(X, true);
      if (W.length || J.validateSchema) {
        if ($.elseIf(this.invalid$data()), this.$dataError(), X !== _.nil) $.assign(X, false);
      }
      $.else();
    }
    invalid$data() {
      let { gen: X, schemaCode: Q, schemaType: $, def: Y, it: W } = this;
      return (0, _.or)(J(), G());
      function J() {
        if ($.length) {
          if (!(Q instanceof _.Name)) throw Error("ajv implementation error");
          let H = Array.isArray($) ? $ : [$];
          return _._`${(0, k8.checkDataTypes)(H, Q, W.opts.strictNumbers, k8.DataType.Wrong)}`;
        }
        return _.nil;
      }
      function G() {
        if (Y.validateSchema) {
          let H = X.scopeValue("validate$data", { ref: Y.validateSchema });
          return _._`!${H}(${Q})`;
        }
        return _.nil;
      }
    }
    subschema(X, Q) {
      let $ = (0, wY.getSubschema)(this.it, X);
      (0, wY.extendSubschemaData)($, this.it, X), (0, wY.extendSubschemaMode)($, X);
      let Y = { ...this.it, ...$, items: void 0, props: void 0 };
      return wA(Y, Q), Y;
    }
    mergeEvaluated(X, Q) {
      let { it: $, gen: Y } = this;
      if (!$.opts.unevaluated) return;
      if ($.props !== true && X.props !== void 0) $.props = I1.mergeEvaluated.props(Y, X.props, $.props, Q);
      if ($.items !== true && X.items !== void 0) $.items = I1.mergeEvaluated.items(Y, X.items, $.items, Q);
    }
    mergeValidEvaluated(X, Q) {
      let { it: $, gen: Y } = this;
      if ($.opts.unevaluated && ($.props !== true || $.items !== true)) return Y.if(Q, () => this.mergeEvaluated(X, _.Name)), true;
    }
  }
  u3.KeywordCxt = RY;
  function f3(X, Q, $, Y) {
    let W = new RY(X, $, Q);
    if ("code" in $) $.code(W, Y);
    else if (W.$data && $.validate) (0, dX.funcKeywordCode)(W, $);
    else if ("macro" in $) (0, dX.macroKeywordCode)(W, $);
    else if ($.compile || $.validate) (0, dX.funcKeywordCode)(W, $);
  }
  var _A = /^\/(?:[^~]|~0|~1)*$/, xA = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function h3(X, { dataLevel: Q, dataNames: $, dataPathArr: Y }) {
    let W, J;
    if (X === "") return u.default.rootData;
    if (X[0] === "/") {
      if (!_A.test(X)) throw Error(`Invalid JSON-pointer: ${X}`);
      W = X, J = u.default.rootData;
    } else {
      let z = xA.exec(X);
      if (!z) throw Error(`Invalid JSON-pointer: ${X}`);
      let K = +z[1];
      if (W = z[2], W === "#") {
        if (K >= Q) throw Error(B("property/index", K));
        return Y[Q - K];
      }
      if (K > Q) throw Error(B("data", K));
      if (J = $[Q - K], !W) return J;
    }
    let G = J, H = W.split("/");
    for (let z of H) if (z) J = _._`${J}${(0, _.getProperty)((0, I1.unescapeJsonPointer)(z))}`, G = _._`${G} && ${J}`;
    return G;
    function B(z, K) {
      return `Cannot access ${z} ${K} levels up, current level is ${Q}`;
    }
  }
  u3.getData = h3;
});
var v8 = P((c3) => {
  Object.defineProperty(c3, "__esModule", { value: true });
  class m3 extends Error {
    constructor(X) {
      super("validation failed");
      this.errors = X, this.ajv = this.validation = true;
    }
  }
  c3.default = m3;
});
var nX = P((d3) => {
  Object.defineProperty(d3, "__esModule", { value: true });
  var IY = cX();
  class p3 extends Error {
    constructor(X, Q, $, Y) {
      super(Y || `can't resolve reference ${$} from id ${Q}`);
      this.missingRef = (0, IY.resolveUrl)(X, Q, $), this.missingSchema = (0, IY.normalizeId)((0, IY.getFullPath)(X, this.missingRef));
    }
  }
  d3.default = p3;
});
var _8 = P((r3) => {
  Object.defineProperty(r3, "__esModule", { value: true });
  r3.resolveSchema = r3.getCompilingSchema = r3.resolveRef = r3.compileSchema = r3.SchemaEnv = void 0;
  var X1 = c(), uA = v8(), B6 = R1(), Q1 = cX(), i3 = e(), lA = iX();
  class rX {
    constructor(X) {
      var Q;
      this.refs = {}, this.dynamicAnchors = {};
      let $;
      if (typeof X.schema == "object") $ = X.schema;
      this.schema = X.schema, this.schemaId = X.schemaId, this.root = X.root || this, this.baseId = (Q = X.baseId) !== null && Q !== void 0 ? Q : (0, Q1.normalizeId)($ === null || $ === void 0 ? void 0 : $[X.schemaId || "$id"]), this.schemaPath = X.schemaPath, this.localRefs = X.localRefs, this.meta = X.meta, this.$async = $ === null || $ === void 0 ? void 0 : $.$async, this.refs = {};
    }
  }
  r3.SchemaEnv = rX;
  function bY(X) {
    let Q = n3.call(this, X);
    if (Q) return Q;
    let $ = (0, Q1.getFullPath)(this.opts.uriResolver, X.root.baseId), { es5: Y, lines: W } = this.opts.code, { ownProperties: J } = this.opts, G = new X1.CodeGen(this.scope, { es5: Y, lines: W, ownProperties: J }), H;
    if (X.$async) H = G.scopeValue("Error", { ref: uA.default, code: X1._`require("ajv/dist/runtime/validation_error").default` });
    let B = G.scopeName("validate");
    X.validateName = B;
    let z = { gen: G, allErrors: this.opts.allErrors, data: B6.default.data, parentData: B6.default.parentData, parentDataProperty: B6.default.parentDataProperty, dataNames: [B6.default.data], dataPathArr: [X1.nil], dataLevel: 0, dataTypes: [], definedProperties: /* @__PURE__ */ new Set(), topSchemaRef: G.scopeValue("schema", this.opts.code.source === true ? { ref: X.schema, code: (0, X1.stringify)(X.schema) } : { ref: X.schema }), validateName: B, ValidationError: H, schema: X.schema, schemaEnv: X, rootId: $, baseId: X.baseId || $, schemaPath: X1.nil, errSchemaPath: X.schemaPath || (this.opts.jtd ? "" : "#"), errorPath: X1._`""`, opts: this.opts, self: this }, K;
    try {
      this._compilations.add(X), (0, lA.validateFunctionCode)(z), G.optimize(this.opts.code.optimize);
      let V = G.toString();
      if (K = `${G.scopeRefs(B6.default.scope)}return ${V}`, this.opts.code.process) K = this.opts.code.process(K, X);
      let U = Function(`${B6.default.self}`, `${B6.default.scope}`, K)(this, this.scope.get());
      if (this.scope.value(B, { ref: U }), U.errors = null, U.schema = X.schema, U.schemaEnv = X, X.$async) U.$async = true;
      if (this.opts.code.source === true) U.source = { validateName: B, validateCode: V, scopeValues: G._values };
      if (this.opts.unevaluated) {
        let { props: F, items: q } = z;
        if (U.evaluated = { props: F instanceof X1.Name ? void 0 : F, items: q instanceof X1.Name ? void 0 : q, dynamicProps: F instanceof X1.Name, dynamicItems: q instanceof X1.Name }, U.source) U.source.evaluated = (0, X1.stringify)(U.evaluated);
      }
      return X.validate = U, X;
    } catch (V) {
      if (delete X.validate, delete X.validateName, K) this.logger.error("Error compiling schema, function code:", K);
      throw V;
    } finally {
      this._compilations.delete(X);
    }
  }
  r3.compileSchema = bY;
  function mA(X, Q, $) {
    var Y;
    $ = (0, Q1.resolveUrl)(this.opts.uriResolver, Q, $);
    let W = X.refs[$];
    if (W) return W;
    let J = dA.call(this, X, $);
    if (J === void 0) {
      let G = (Y = X.localRefs) === null || Y === void 0 ? void 0 : Y[$], { schemaId: H } = this.opts;
      if (G) J = new rX({ schema: G, schemaId: H, root: X, baseId: Q });
    }
    if (J === void 0) return;
    return X.refs[$] = cA.call(this, J);
  }
  r3.resolveRef = mA;
  function cA(X) {
    if ((0, Q1.inlineRef)(X.schema, this.opts.inlineRefs)) return X.schema;
    return X.validate ? X : bY.call(this, X);
  }
  function n3(X) {
    for (let Q of this._compilations) if (pA(Q, X)) return Q;
  }
  r3.getCompilingSchema = n3;
  function pA(X, Q) {
    return X.schema === Q.schema && X.root === Q.root && X.baseId === Q.baseId;
  }
  function dA(X, Q) {
    let $;
    while (typeof ($ = this.refs[Q]) == "string") Q = $;
    return $ || this.schemas[Q] || T8.call(this, X, Q);
  }
  function T8(X, Q) {
    let $ = this.opts.uriResolver.parse(Q), Y = (0, Q1._getFullPath)(this.opts.uriResolver, $), W = (0, Q1.getFullPath)(this.opts.uriResolver, X.baseId, void 0);
    if (Object.keys(X.schema).length > 0 && Y === W) return EY.call(this, $, X);
    let J = (0, Q1.normalizeId)(Y), G = this.refs[J] || this.schemas[J];
    if (typeof G == "string") {
      let H = T8.call(this, X, G);
      if (typeof (H === null || H === void 0 ? void 0 : H.schema) !== "object") return;
      return EY.call(this, $, H);
    }
    if (typeof (G === null || G === void 0 ? void 0 : G.schema) !== "object") return;
    if (!G.validate) bY.call(this, G);
    if (J === (0, Q1.normalizeId)(Q)) {
      let { schema: H } = G, { schemaId: B } = this.opts, z = H[B];
      if (z) W = (0, Q1.resolveUrl)(this.opts.uriResolver, W, z);
      return new rX({ schema: H, schemaId: B, root: X, baseId: W });
    }
    return EY.call(this, $, G);
  }
  r3.resolveSchema = T8;
  var iA = /* @__PURE__ */ new Set(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
  function EY(X, { baseId: Q, schema: $, root: Y }) {
    var W;
    if (((W = X.fragment) === null || W === void 0 ? void 0 : W[0]) !== "/") return;
    for (let H of X.fragment.slice(1).split("/")) {
      if (typeof $ === "boolean") return;
      let B = $[(0, i3.unescapeFragment)(H)];
      if (B === void 0) return;
      $ = B;
      let z = typeof $ === "object" && $[this.opts.schemaId];
      if (!iA.has(H) && z) Q = (0, Q1.resolveUrl)(this.opts.uriResolver, Q, z);
    }
    let J;
    if (typeof $ != "boolean" && $.$ref && !(0, i3.schemaHasRulesButRef)($, this.RULES)) {
      let H = (0, Q1.resolveUrl)(this.opts.uriResolver, Q, $.$ref);
      J = T8.call(this, Y, H);
    }
    let { schemaId: G } = this.opts;
    if (J = J || new rX({ schema: $, schemaId: G, root: Y, baseId: Q }), J.schema !== J.root.schema) return J;
    return;
  }
});
var t3 = P((GT, aA) => {
  aA.exports = { $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", description: "Meta-schema for $data reference (JSON AnySchema extension proposal)", type: "object", required: ["$data"], properties: { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, additionalProperties: false };
});
var s3 = P((HT, a3) => {
  var sA = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  a3.exports = { HEX: sA };
});
var GH = P((BT, JH) => {
  var { HEX: eA } = s3(), Xw = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
  function $H(X) {
    if (WH(X, ".") < 3) return { host: X, isIPV4: false };
    let Q = X.match(Xw) || [], [$] = Q;
    if ($) return { host: $w($, "."), isIPV4: true };
    else return { host: X, isIPV4: false };
  }
  function PY(X, Q = false) {
    let $ = "", Y = true;
    for (let W of X) {
      if (eA[W] === void 0) return;
      if (W !== "0" && Y === true) Y = false;
      if (!Y) $ += W;
    }
    if (Q && $.length === 0) $ = "0";
    return $;
  }
  function Qw(X) {
    let Q = 0, $ = { error: false, address: "", zone: "" }, Y = [], W = [], J = false, G = false, H = false;
    function B() {
      if (W.length) {
        if (J === false) {
          let z = PY(W);
          if (z !== void 0) Y.push(z);
          else return $.error = true, false;
        }
        W.length = 0;
      }
      return true;
    }
    for (let z = 0; z < X.length; z++) {
      let K = X[z];
      if (K === "[" || K === "]") continue;
      if (K === ":") {
        if (G === true) H = true;
        if (!B()) break;
        if (Q++, Y.push(":"), Q > 7) {
          $.error = true;
          break;
        }
        if (z - 1 >= 0 && X[z - 1] === ":") G = true;
        continue;
      } else if (K === "%") {
        if (!B()) break;
        J = true;
      } else {
        W.push(K);
        continue;
      }
    }
    if (W.length) if (J) $.zone = W.join("");
    else if (H) Y.push(W.join(""));
    else Y.push(PY(W));
    return $.address = Y.join(""), $;
  }
  function YH(X) {
    if (WH(X, ":") < 2) return { host: X, isIPV6: false };
    let Q = Qw(X);
    if (!Q.error) {
      let { address: $, address: Y } = Q;
      if (Q.zone) $ += "%" + Q.zone, Y += "%25" + Q.zone;
      return { host: $, escapedHost: Y, isIPV6: true };
    } else return { host: X, isIPV6: false };
  }
  function $w(X, Q) {
    let $ = "", Y = true, W = X.length;
    for (let J = 0; J < W; J++) {
      let G = X[J];
      if (G === "0" && Y) {
        if (J + 1 <= W && X[J + 1] === Q || J + 1 === W) $ += G, Y = false;
      } else {
        if (G === Q) Y = true;
        else Y = false;
        $ += G;
      }
    }
    return $;
  }
  function WH(X, Q) {
    let $ = 0;
    for (let Y = 0; Y < X.length; Y++) if (X[Y] === Q) $++;
    return $;
  }
  var e3 = /^\.\.?\//u, XH = /^\/\.(?:\/|$)/u, QH = /^\/\.\.(?:\/|$)/u, Yw = /^\/?(?:.|\n)*?(?=\/|$)/u;
  function Ww(X) {
    let Q = [];
    while (X.length) if (X.match(e3)) X = X.replace(e3, "");
    else if (X.match(XH)) X = X.replace(XH, "/");
    else if (X.match(QH)) X = X.replace(QH, "/"), Q.pop();
    else if (X === "." || X === "..") X = "";
    else {
      let $ = X.match(Yw);
      if ($) {
        let Y = $[0];
        X = X.slice(Y.length), Q.push(Y);
      } else throw Error("Unexpected dot segment condition");
    }
    return Q.join("");
  }
  function Jw(X, Q) {
    let $ = Q !== true ? escape : unescape;
    if (X.scheme !== void 0) X.scheme = $(X.scheme);
    if (X.userinfo !== void 0) X.userinfo = $(X.userinfo);
    if (X.host !== void 0) X.host = $(X.host);
    if (X.path !== void 0) X.path = $(X.path);
    if (X.query !== void 0) X.query = $(X.query);
    if (X.fragment !== void 0) X.fragment = $(X.fragment);
    return X;
  }
  function Gw(X) {
    let Q = [];
    if (X.userinfo !== void 0) Q.push(X.userinfo), Q.push("@");
    if (X.host !== void 0) {
      let $ = unescape(X.host), Y = $H($);
      if (Y.isIPV4) $ = Y.host;
      else {
        let W = YH(Y.host);
        if (W.isIPV6 === true) $ = `[${W.escapedHost}]`;
        else $ = X.host;
      }
      Q.push($);
    }
    if (typeof X.port === "number" || typeof X.port === "string") Q.push(":"), Q.push(String(X.port));
    return Q.length ? Q.join("") : void 0;
  }
  JH.exports = { recomposeAuthority: Gw, normalizeComponentEncoding: Jw, removeDotSegments: Ww, normalizeIPv4: $H, normalizeIPv6: YH, stringArrayToHexStripped: PY };
});
var VH = P((zT, UH) => {
  var Hw = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu, Bw = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
  function HH(X) {
    return typeof X.secure === "boolean" ? X.secure : String(X.scheme).toLowerCase() === "wss";
  }
  function BH(X) {
    if (!X.host) X.error = X.error || "HTTP URIs must have a host.";
    return X;
  }
  function zH(X) {
    let Q = String(X.scheme).toLowerCase() === "https";
    if (X.port === (Q ? 443 : 80) || X.port === "") X.port = void 0;
    if (!X.path) X.path = "/";
    return X;
  }
  function zw(X) {
    return X.secure = HH(X), X.resourceName = (X.path || "/") + (X.query ? "?" + X.query : ""), X.path = void 0, X.query = void 0, X;
  }
  function Kw(X) {
    if (X.port === (HH(X) ? 443 : 80) || X.port === "") X.port = void 0;
    if (typeof X.secure === "boolean") X.scheme = X.secure ? "wss" : "ws", X.secure = void 0;
    if (X.resourceName) {
      let [Q, $] = X.resourceName.split("?");
      X.path = Q && Q !== "/" ? Q : void 0, X.query = $, X.resourceName = void 0;
    }
    return X.fragment = void 0, X;
  }
  function Uw(X, Q) {
    if (!X.path) return X.error = "URN can not be parsed", X;
    let $ = X.path.match(Bw);
    if ($) {
      let Y = Q.scheme || X.scheme || "urn";
      X.nid = $[1].toLowerCase(), X.nss = $[2];
      let W = `${Y}:${Q.nid || X.nid}`, J = SY[W];
      if (X.path = void 0, J) X = J.parse(X, Q);
    } else X.error = X.error || "URN can not be parsed.";
    return X;
  }
  function Vw(X, Q) {
    let $ = Q.scheme || X.scheme || "urn", Y = X.nid.toLowerCase(), W = `${$}:${Q.nid || Y}`, J = SY[W];
    if (J) X = J.serialize(X, Q);
    let G = X, H = X.nss;
    return G.path = `${Y || Q.nid}:${H}`, Q.skipEscape = true, G;
  }
  function Lw(X, Q) {
    let $ = X;
    if ($.uuid = $.nss, $.nss = void 0, !Q.tolerant && (!$.uuid || !Hw.test($.uuid))) $.error = $.error || "UUID is not valid.";
    return $;
  }
  function qw(X) {
    let Q = X;
    return Q.nss = (X.uuid || "").toLowerCase(), Q;
  }
  var KH = { scheme: "http", domainHost: true, parse: BH, serialize: zH }, Fw = { scheme: "https", domainHost: KH.domainHost, parse: BH, serialize: zH }, x8 = { scheme: "ws", domainHost: true, parse: zw, serialize: Kw }, Nw = { scheme: "wss", domainHost: x8.domainHost, parse: x8.parse, serialize: x8.serialize }, Ow = { scheme: "urn", parse: Uw, serialize: Vw, skipNormalize: true }, Dw = { scheme: "urn:uuid", parse: Lw, serialize: qw, skipNormalize: true }, SY = { http: KH, https: Fw, ws: x8, wss: Nw, urn: Ow, "urn:uuid": Dw };
  UH.exports = SY;
});
var qH = P((KT, g8) => {
  var { normalizeIPv6: Aw, normalizeIPv4: ww, removeDotSegments: oX, recomposeAuthority: Mw, normalizeComponentEncoding: y8 } = GH(), ZY = VH();
  function jw(X, Q) {
    if (typeof X === "string") X = V1(E1(X, Q), Q);
    else if (typeof X === "object") X = E1(V1(X, Q), Q);
    return X;
  }
  function Rw(X, Q, $) {
    let Y = Object.assign({ scheme: "null" }, $), W = LH(E1(X, Y), E1(Q, Y), Y, true);
    return V1(W, { ...Y, skipEscape: true });
  }
  function LH(X, Q, $, Y) {
    let W = {};
    if (!Y) X = E1(V1(X, $), $), Q = E1(V1(Q, $), $);
    if ($ = $ || {}, !$.tolerant && Q.scheme) W.scheme = Q.scheme, W.userinfo = Q.userinfo, W.host = Q.host, W.port = Q.port, W.path = oX(Q.path || ""), W.query = Q.query;
    else {
      if (Q.userinfo !== void 0 || Q.host !== void 0 || Q.port !== void 0) W.userinfo = Q.userinfo, W.host = Q.host, W.port = Q.port, W.path = oX(Q.path || ""), W.query = Q.query;
      else {
        if (!Q.path) if (W.path = X.path, Q.query !== void 0) W.query = Q.query;
        else W.query = X.query;
        else {
          if (Q.path.charAt(0) === "/") W.path = oX(Q.path);
          else {
            if ((X.userinfo !== void 0 || X.host !== void 0 || X.port !== void 0) && !X.path) W.path = "/" + Q.path;
            else if (!X.path) W.path = Q.path;
            else W.path = X.path.slice(0, X.path.lastIndexOf("/") + 1) + Q.path;
            W.path = oX(W.path);
          }
          W.query = Q.query;
        }
        W.userinfo = X.userinfo, W.host = X.host, W.port = X.port;
      }
      W.scheme = X.scheme;
    }
    return W.fragment = Q.fragment, W;
  }
  function Iw(X, Q, $) {
    if (typeof X === "string") X = unescape(X), X = V1(y8(E1(X, $), true), { ...$, skipEscape: true });
    else if (typeof X === "object") X = V1(y8(X, true), { ...$, skipEscape: true });
    if (typeof Q === "string") Q = unescape(Q), Q = V1(y8(E1(Q, $), true), { ...$, skipEscape: true });
    else if (typeof Q === "object") Q = V1(y8(Q, true), { ...$, skipEscape: true });
    return X.toLowerCase() === Q.toLowerCase();
  }
  function V1(X, Q) {
    let $ = { host: X.host, scheme: X.scheme, userinfo: X.userinfo, port: X.port, path: X.path, query: X.query, nid: X.nid, nss: X.nss, uuid: X.uuid, fragment: X.fragment, reference: X.reference, resourceName: X.resourceName, secure: X.secure, error: "" }, Y = Object.assign({}, Q), W = [], J = ZY[(Y.scheme || $.scheme || "").toLowerCase()];
    if (J && J.serialize) J.serialize($, Y);
    if ($.path !== void 0) if (!Y.skipEscape) {
      if ($.path = escape($.path), $.scheme !== void 0) $.path = $.path.split("%3A").join(":");
    } else $.path = unescape($.path);
    if (Y.reference !== "suffix" && $.scheme) W.push($.scheme, ":");
    let G = Mw($);
    if (G !== void 0) {
      if (Y.reference !== "suffix") W.push("//");
      if (W.push(G), $.path && $.path.charAt(0) !== "/") W.push("/");
    }
    if ($.path !== void 0) {
      let H = $.path;
      if (!Y.absolutePath && (!J || !J.absolutePath)) H = oX(H);
      if (G === void 0) H = H.replace(/^\/\//u, "/%2F");
      W.push(H);
    }
    if ($.query !== void 0) W.push("?", $.query);
    if ($.fragment !== void 0) W.push("#", $.fragment);
    return W.join("");
  }
  var Ew = Array.from({ length: 127 }, (X, Q) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(Q)));
  function bw(X) {
    let Q = 0;
    for (let $ = 0, Y = X.length; $ < Y; ++$) if (Q = X.charCodeAt($), Q > 126 || Ew[Q]) return true;
    return false;
  }
  var Pw = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function E1(X, Q) {
    let $ = Object.assign({}, Q), Y = { scheme: void 0, userinfo: void 0, host: "", port: void 0, path: "", query: void 0, fragment: void 0 }, W = X.indexOf("%") !== -1, J = false;
    if ($.reference === "suffix") X = ($.scheme ? $.scheme + ":" : "") + "//" + X;
    let G = X.match(Pw);
    if (G) {
      if (Y.scheme = G[1], Y.userinfo = G[3], Y.host = G[4], Y.port = parseInt(G[5], 10), Y.path = G[6] || "", Y.query = G[7], Y.fragment = G[8], isNaN(Y.port)) Y.port = G[5];
      if (Y.host) {
        let B = ww(Y.host);
        if (B.isIPV4 === false) {
          let z = Aw(B.host);
          Y.host = z.host.toLowerCase(), J = z.isIPV6;
        } else Y.host = B.host, J = true;
      }
      if (Y.scheme === void 0 && Y.userinfo === void 0 && Y.host === void 0 && Y.port === void 0 && Y.query === void 0 && !Y.path) Y.reference = "same-document";
      else if (Y.scheme === void 0) Y.reference = "relative";
      else if (Y.fragment === void 0) Y.reference = "absolute";
      else Y.reference = "uri";
      if ($.reference && $.reference !== "suffix" && $.reference !== Y.reference) Y.error = Y.error || "URI is not a " + $.reference + " reference.";
      let H = ZY[($.scheme || Y.scheme || "").toLowerCase()];
      if (!$.unicodeSupport && (!H || !H.unicodeSupport)) {
        if (Y.host && ($.domainHost || H && H.domainHost) && J === false && bw(Y.host)) try {
          Y.host = URL.domainToASCII(Y.host.toLowerCase());
        } catch (B) {
          Y.error = Y.error || "Host's domain name can not be converted to ASCII: " + B;
        }
      }
      if (!H || H && !H.skipNormalize) {
        if (W && Y.scheme !== void 0) Y.scheme = unescape(Y.scheme);
        if (W && Y.host !== void 0) Y.host = unescape(Y.host);
        if (Y.path) Y.path = escape(unescape(Y.path));
        if (Y.fragment) Y.fragment = encodeURI(decodeURIComponent(Y.fragment));
      }
      if (H && H.parse) H.parse(Y, $);
    } else Y.error = Y.error || "URI can not be parsed.";
    return Y;
  }
  var CY = { SCHEMES: ZY, normalize: jw, resolve: Rw, resolveComponents: LH, equal: Iw, serialize: V1, parse: E1 };
  g8.exports = CY;
  g8.exports.default = CY;
  g8.exports.fastUri = CY;
});
var OH = P((NH) => {
  Object.defineProperty(NH, "__esModule", { value: true });
  var FH = qH();
  FH.code = 'require("ajv/dist/runtime/uri").default';
  NH.default = FH;
});
var EH = P((b1) => {
  Object.defineProperty(b1, "__esModule", { value: true });
  b1.CodeGen = b1.Name = b1.nil = b1.stringify = b1.str = b1._ = b1.KeywordCxt = void 0;
  var Zw = iX();
  Object.defineProperty(b1, "KeywordCxt", { enumerable: true, get: function() {
    return Zw.KeywordCxt;
  } });
  var p6 = c();
  Object.defineProperty(b1, "_", { enumerable: true, get: function() {
    return p6._;
  } });
  Object.defineProperty(b1, "str", { enumerable: true, get: function() {
    return p6.str;
  } });
  Object.defineProperty(b1, "stringify", { enumerable: true, get: function() {
    return p6.stringify;
  } });
  Object.defineProperty(b1, "nil", { enumerable: true, get: function() {
    return p6.nil;
  } });
  Object.defineProperty(b1, "Name", { enumerable: true, get: function() {
    return p6.Name;
  } });
  Object.defineProperty(b1, "CodeGen", { enumerable: true, get: function() {
    return p6.CodeGen;
  } });
  var Cw = v8(), jH = nX(), kw = KY(), tX = _8(), vw = c(), aX = cX(), f8 = mX(), vY = e(), DH = t3(), Tw = OH(), RH = (X, Q) => new RegExp(X, Q);
  RH.code = "new RegExp";
  var _w = ["removeAdditional", "useDefaults", "coerceTypes"], xw = /* @__PURE__ */ new Set(["validate", "serialize", "parse", "wrapper", "root", "schema", "keyword", "pattern", "formats", "validate$data", "func", "obj", "Error"]), yw = { errorDataPath: "", format: "`validateFormats: false` can be used instead.", nullable: '"nullable" keyword is supported by default.', jsonPointers: "Deprecated jsPropertySyntax can be used instead.", extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.", missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.", processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`", sourceCode: "Use option `code: {source: true}`", strictDefaults: "It is default now, see option `strict`.", strictKeywords: "It is default now, see option `strict`.", uniqueItems: '"uniqueItems" keyword is always validated.', unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).", cache: "Map is used as cache, schema object as key.", serialize: "Map is used as cache, schema object as key.", ajvErrors: "It is default now." }, gw = { ignoreKeywordsWithRef: "", jsPropertySyntax: "", unicode: '"minLength"/"maxLength" account for unicode characters by default.' }, AH = 200;
  function fw(X) {
    var Q, $, Y, W, J, G, H, B, z, K, V, L, U, F, q, N, A, M, R, S, C, K0, U0, s, D0;
    let q0 = X.strict, W1 = (Q = X.code) === null || Q === void 0 ? void 0 : Q.optimize, P1 = W1 === true || W1 === void 0 ? 1 : W1 || 0, U6 = (Y = ($ = X.code) === null || $ === void 0 ? void 0 : $.regExp) !== null && Y !== void 0 ? Y : RH, d = (W = X.uriResolver) !== null && W !== void 0 ? W : Tw.default;
    return { strictSchema: (G = (J = X.strictSchema) !== null && J !== void 0 ? J : q0) !== null && G !== void 0 ? G : true, strictNumbers: (B = (H = X.strictNumbers) !== null && H !== void 0 ? H : q0) !== null && B !== void 0 ? B : true, strictTypes: (K = (z = X.strictTypes) !== null && z !== void 0 ? z : q0) !== null && K !== void 0 ? K : "log", strictTuples: (L = (V = X.strictTuples) !== null && V !== void 0 ? V : q0) !== null && L !== void 0 ? L : "log", strictRequired: (F = (U = X.strictRequired) !== null && U !== void 0 ? U : q0) !== null && F !== void 0 ? F : false, code: X.code ? { ...X.code, optimize: P1, regExp: U6 } : { optimize: P1, regExp: U6 }, loopRequired: (q = X.loopRequired) !== null && q !== void 0 ? q : AH, loopEnum: (N = X.loopEnum) !== null && N !== void 0 ? N : AH, meta: (A = X.meta) !== null && A !== void 0 ? A : true, messages: (M = X.messages) !== null && M !== void 0 ? M : true, inlineRefs: (R = X.inlineRefs) !== null && R !== void 0 ? R : true, schemaId: (S = X.schemaId) !== null && S !== void 0 ? S : "$id", addUsedSchema: (C = X.addUsedSchema) !== null && C !== void 0 ? C : true, validateSchema: (K0 = X.validateSchema) !== null && K0 !== void 0 ? K0 : true, validateFormats: (U0 = X.validateFormats) !== null && U0 !== void 0 ? U0 : true, unicodeRegExp: (s = X.unicodeRegExp) !== null && s !== void 0 ? s : true, int32range: (D0 = X.int32range) !== null && D0 !== void 0 ? D0 : true, uriResolver: d };
  }
  class h8 {
    constructor(X = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), X = this.opts = { ...X, ...fw(X) };
      let { es5: Q, lines: $ } = this.opts.code;
      this.scope = new vw.ValueScope({ scope: {}, prefixes: xw, es5: Q, lines: $ }), this.logger = pw(X.logger);
      let Y = X.validateFormats;
      if (X.validateFormats = false, this.RULES = (0, kw.getRules)(), wH.call(this, yw, X, "NOT SUPPORTED"), wH.call(this, gw, X, "DEPRECATED", "warn"), this._metaOpts = mw.call(this), X.formats) uw.call(this);
      if (this._addVocabularies(), this._addDefaultMetaSchema(), X.keywords) lw.call(this, X.keywords);
      if (typeof X.meta == "object") this.addMetaSchema(X.meta);
      hw.call(this), X.validateFormats = Y;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      let { $data: X, meta: Q, schemaId: $ } = this.opts, Y = DH;
      if ($ === "id") Y = { ...DH }, Y.id = Y.$id, delete Y.$id;
      if (Q && X) this.addMetaSchema(Y, Y[$], false);
    }
    defaultMeta() {
      let { meta: X, schemaId: Q } = this.opts;
      return this.opts.defaultMeta = typeof X == "object" ? X[Q] || X : void 0;
    }
    validate(X, Q) {
      let $;
      if (typeof X == "string") {
        if ($ = this.getSchema(X), !$) throw Error(`no schema with key or ref "${X}"`);
      } else $ = this.compile(X);
      let Y = $(Q);
      if (!("$async" in $)) this.errors = $.errors;
      return Y;
    }
    compile(X, Q) {
      let $ = this._addSchema(X, Q);
      return $.validate || this._compileSchemaEnv($);
    }
    compileAsync(X, Q) {
      if (typeof this.opts.loadSchema != "function") throw Error("options.loadSchema should be a function");
      let { loadSchema: $ } = this.opts;
      return Y.call(this, X, Q);
      async function Y(z, K) {
        await W.call(this, z.$schema);
        let V = this._addSchema(z, K);
        return V.validate || J.call(this, V);
      }
      async function W(z) {
        if (z && !this.getSchema(z)) await Y.call(this, { $ref: z }, true);
      }
      async function J(z) {
        try {
          return this._compileSchemaEnv(z);
        } catch (K) {
          if (!(K instanceof jH.default)) throw K;
          return G.call(this, K), await H.call(this, K.missingSchema), J.call(this, z);
        }
      }
      function G({ missingSchema: z, missingRef: K }) {
        if (this.refs[z]) throw Error(`AnySchema ${z} is loaded but ${K} cannot be resolved`);
      }
      async function H(z) {
        let K = await B.call(this, z);
        if (!this.refs[z]) await W.call(this, K.$schema);
        if (!this.refs[z]) this.addSchema(K, z, Q);
      }
      async function B(z) {
        let K = this._loading[z];
        if (K) return K;
        try {
          return await (this._loading[z] = $(z));
        } finally {
          delete this._loading[z];
        }
      }
    }
    addSchema(X, Q, $, Y = this.opts.validateSchema) {
      if (Array.isArray(X)) {
        for (let J of X) this.addSchema(J, void 0, $, Y);
        return this;
      }
      let W;
      if (typeof X === "object") {
        let { schemaId: J } = this.opts;
        if (W = X[J], W !== void 0 && typeof W != "string") throw Error(`schema ${J} must be string`);
      }
      return Q = (0, aX.normalizeId)(Q || W), this._checkUnique(Q), this.schemas[Q] = this._addSchema(X, $, Q, Y, true), this;
    }
    addMetaSchema(X, Q, $ = this.opts.validateSchema) {
      return this.addSchema(X, Q, true, $), this;
    }
    validateSchema(X, Q) {
      if (typeof X == "boolean") return true;
      let $;
      if ($ = X.$schema, $ !== void 0 && typeof $ != "string") throw Error("$schema must be a string");
      if ($ = $ || this.opts.defaultMeta || this.defaultMeta(), !$) return this.logger.warn("meta-schema not available"), this.errors = null, true;
      let Y = this.validate($, X);
      if (!Y && Q) {
        let W = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log") this.logger.error(W);
        else throw Error(W);
      }
      return Y;
    }
    getSchema(X) {
      let Q;
      while (typeof (Q = MH.call(this, X)) == "string") X = Q;
      if (Q === void 0) {
        let { schemaId: $ } = this.opts, Y = new tX.SchemaEnv({ schema: {}, schemaId: $ });
        if (Q = tX.resolveSchema.call(this, Y, X), !Q) return;
        this.refs[X] = Q;
      }
      return Q.validate || this._compileSchemaEnv(Q);
    }
    removeSchema(X) {
      if (X instanceof RegExp) return this._removeAllSchemas(this.schemas, X), this._removeAllSchemas(this.refs, X), this;
      switch (typeof X) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          let Q = MH.call(this, X);
          if (typeof Q == "object") this._cache.delete(Q.schema);
          return delete this.schemas[X], delete this.refs[X], this;
        }
        case "object": {
          let Q = X;
          this._cache.delete(Q);
          let $ = X[this.opts.schemaId];
          if ($) $ = (0, aX.normalizeId)($), delete this.schemas[$], delete this.refs[$];
          return this;
        }
        default:
          throw Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(X) {
      for (let Q of X) this.addKeyword(Q);
      return this;
    }
    addKeyword(X, Q) {
      let $;
      if (typeof X == "string") {
        if ($ = X, typeof Q == "object") this.logger.warn("these parameters are deprecated, see docs for addKeyword"), Q.keyword = $;
      } else if (typeof X == "object" && Q === void 0) {
        if (Q = X, $ = Q.keyword, Array.isArray($) && !$.length) throw Error("addKeywords: keyword must be string or non-empty array");
      } else throw Error("invalid addKeywords parameters");
      if (iw.call(this, $, Q), !Q) return (0, vY.eachItem)($, (W) => kY.call(this, W)), this;
      rw.call(this, Q);
      let Y = { ...Q, type: (0, f8.getJSONTypes)(Q.type), schemaType: (0, f8.getJSONTypes)(Q.schemaType) };
      return (0, vY.eachItem)($, Y.type.length === 0 ? (W) => kY.call(this, W, Y) : (W) => Y.type.forEach((J) => kY.call(this, W, Y, J))), this;
    }
    getKeyword(X) {
      let Q = this.RULES.all[X];
      return typeof Q == "object" ? Q.definition : !!Q;
    }
    removeKeyword(X) {
      let { RULES: Q } = this;
      delete Q.keywords[X], delete Q.all[X];
      for (let $ of Q.rules) {
        let Y = $.rules.findIndex((W) => W.keyword === X);
        if (Y >= 0) $.rules.splice(Y, 1);
      }
      return this;
    }
    addFormat(X, Q) {
      if (typeof Q == "string") Q = new RegExp(Q);
      return this.formats[X] = Q, this;
    }
    errorsText(X = this.errors, { separator: Q = ", ", dataVar: $ = "data" } = {}) {
      if (!X || X.length === 0) return "No errors";
      return X.map((Y) => `${$}${Y.instancePath} ${Y.message}`).reduce((Y, W) => Y + Q + W);
    }
    $dataMetaSchema(X, Q) {
      let $ = this.RULES.all;
      X = JSON.parse(JSON.stringify(X));
      for (let Y of Q) {
        let W = Y.split("/").slice(1), J = X;
        for (let G of W) J = J[G];
        for (let G in $) {
          let H = $[G];
          if (typeof H != "object") continue;
          let { $data: B } = H.definition, z = J[G];
          if (B && z) J[G] = IH(z);
        }
      }
      return X;
    }
    _removeAllSchemas(X, Q) {
      for (let $ in X) {
        let Y = X[$];
        if (!Q || Q.test($)) {
          if (typeof Y == "string") delete X[$];
          else if (Y && !Y.meta) this._cache.delete(Y.schema), delete X[$];
        }
      }
    }
    _addSchema(X, Q, $, Y = this.opts.validateSchema, W = this.opts.addUsedSchema) {
      let J, { schemaId: G } = this.opts;
      if (typeof X == "object") J = X[G];
      else if (this.opts.jtd) throw Error("schema must be object");
      else if (typeof X != "boolean") throw Error("schema must be object or boolean");
      let H = this._cache.get(X);
      if (H !== void 0) return H;
      $ = (0, aX.normalizeId)(J || $);
      let B = aX.getSchemaRefs.call(this, X, $);
      if (H = new tX.SchemaEnv({ schema: X, schemaId: G, meta: Q, baseId: $, localRefs: B }), this._cache.set(H.schema, H), W && !$.startsWith("#")) {
        if ($) this._checkUnique($);
        this.refs[$] = H;
      }
      if (Y) this.validateSchema(X, true);
      return H;
    }
    _checkUnique(X) {
      if (this.schemas[X] || this.refs[X]) throw Error(`schema with key or id "${X}" already exists`);
    }
    _compileSchemaEnv(X) {
      if (X.meta) this._compileMetaSchema(X);
      else tX.compileSchema.call(this, X);
      if (!X.validate) throw Error("ajv implementation error");
      return X.validate;
    }
    _compileMetaSchema(X) {
      let Q = this.opts;
      this.opts = this._metaOpts;
      try {
        tX.compileSchema.call(this, X);
      } finally {
        this.opts = Q;
      }
    }
  }
  h8.ValidationError = Cw.default;
  h8.MissingRefError = jH.default;
  b1.default = h8;
  function wH(X, Q, $, Y = "error") {
    for (let W in X) {
      let J = W;
      if (J in Q) this.logger[Y](`${$}: option ${W}. ${X[J]}`);
    }
  }
  function MH(X) {
    return X = (0, aX.normalizeId)(X), this.schemas[X] || this.refs[X];
  }
  function hw() {
    let X = this.opts.schemas;
    if (!X) return;
    if (Array.isArray(X)) this.addSchema(X);
    else for (let Q in X) this.addSchema(X[Q], Q);
  }
  function uw() {
    for (let X in this.opts.formats) {
      let Q = this.opts.formats[X];
      if (Q) this.addFormat(X, Q);
    }
  }
  function lw(X) {
    if (Array.isArray(X)) {
      this.addVocabulary(X);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (let Q in X) {
      let $ = X[Q];
      if (!$.keyword) $.keyword = Q;
      this.addKeyword($);
    }
  }
  function mw() {
    let X = { ...this.opts };
    for (let Q of _w) delete X[Q];
    return X;
  }
  var cw = { log() {
  }, warn() {
  }, error() {
  } };
  function pw(X) {
    if (X === false) return cw;
    if (X === void 0) return console;
    if (X.log && X.warn && X.error) return X;
    throw Error("logger must implement log, warn and error methods");
  }
  var dw = /^[a-z_$][a-z0-9_$:-]*$/i;
  function iw(X, Q) {
    let { RULES: $ } = this;
    if ((0, vY.eachItem)(X, (Y) => {
      if ($.keywords[Y]) throw Error(`Keyword ${Y} is already defined`);
      if (!dw.test(Y)) throw Error(`Keyword ${Y} has invalid name`);
    }), !Q) return;
    if (Q.$data && !("code" in Q || "validate" in Q)) throw Error('$data keyword must have "code" or "validate" function');
  }
  function kY(X, Q, $) {
    var Y;
    let W = Q === null || Q === void 0 ? void 0 : Q.post;
    if ($ && W) throw Error('keyword with "post" flag cannot have "type"');
    let { RULES: J } = this, G = W ? J.post : J.rules.find(({ type: B }) => B === $);
    if (!G) G = { type: $, rules: [] }, J.rules.push(G);
    if (J.keywords[X] = true, !Q) return;
    let H = { keyword: X, definition: { ...Q, type: (0, f8.getJSONTypes)(Q.type), schemaType: (0, f8.getJSONTypes)(Q.schemaType) } };
    if (Q.before) nw.call(this, G, H, Q.before);
    else G.rules.push(H);
    J.all[X] = H, (Y = Q.implements) === null || Y === void 0 || Y.forEach((B) => this.addKeyword(B));
  }
  function nw(X, Q, $) {
    let Y = X.rules.findIndex((W) => W.keyword === $);
    if (Y >= 0) X.rules.splice(Y, 0, Q);
    else X.rules.push(Q), this.logger.warn(`rule ${$} is not defined`);
  }
  function rw(X) {
    let { metaSchema: Q } = X;
    if (Q === void 0) return;
    if (X.$data && this.opts.$data) Q = IH(Q);
    X.validateSchema = this.compile(Q, true);
  }
  var ow = { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" };
  function IH(X) {
    return { anyOf: [X, ow] };
  }
});
var PH = P((bH) => {
  Object.defineProperty(bH, "__esModule", { value: true });
  var sw = { keyword: "id", code() {
    throw Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  } };
  bH.default = sw;
});
var TH = P((kH) => {
  Object.defineProperty(kH, "__esModule", { value: true });
  kH.callRef = kH.getValidate = void 0;
  var XM = nX(), SH = d0(), g0 = c(), d6 = R1(), ZH = _8(), u8 = e(), QM = { keyword: "$ref", schemaType: "string", code(X) {
    let { gen: Q, schema: $, it: Y } = X, { baseId: W, schemaEnv: J, validateName: G, opts: H, self: B } = Y, { root: z } = J;
    if (($ === "#" || $ === "#/") && W === z.baseId) return V();
    let K = ZH.resolveRef.call(B, z, W, $);
    if (K === void 0) throw new XM.default(Y.opts.uriResolver, W, $);
    if (K instanceof ZH.SchemaEnv) return L(K);
    return U(K);
    function V() {
      if (J === z) return l8(X, G, J, J.$async);
      let F = Q.scopeValue("root", { ref: z });
      return l8(X, g0._`${F}.validate`, z, z.$async);
    }
    function L(F) {
      let q = CH(X, F);
      l8(X, q, F, F.$async);
    }
    function U(F) {
      let q = Q.scopeValue("schema", H.code.source === true ? { ref: F, code: (0, g0.stringify)(F) } : { ref: F }), N = Q.name("valid"), A = X.subschema({ schema: F, dataTypes: [], schemaPath: g0.nil, topSchemaRef: q, errSchemaPath: $ }, N);
      X.mergeEvaluated(A), X.ok(N);
    }
  } };
  function CH(X, Q) {
    let { gen: $ } = X;
    return Q.validate ? $.scopeValue("validate", { ref: Q.validate }) : g0._`${$.scopeValue("wrapper", { ref: Q })}.validate`;
  }
  kH.getValidate = CH;
  function l8(X, Q, $, Y) {
    let { gen: W, it: J } = X, { allErrors: G, schemaEnv: H, opts: B } = J, z = B.passContext ? d6.default.this : g0.nil;
    if (Y) K();
    else V();
    function K() {
      if (!H.$async) throw Error("async schema referenced by sync schema");
      let F = W.let("valid");
      W.try(() => {
        if (W.code(g0._`await ${(0, SH.callValidateCode)(X, Q, z)}`), U(Q), !G) W.assign(F, true);
      }, (q) => {
        if (W.if(g0._`!(${q} instanceof ${J.ValidationError})`, () => W.throw(q)), L(q), !G) W.assign(F, false);
      }), X.ok(F);
    }
    function V() {
      X.result((0, SH.callValidateCode)(X, Q, z), () => U(Q), () => L(Q));
    }
    function L(F) {
      let q = g0._`${F}.errors`;
      W.assign(d6.default.vErrors, g0._`${d6.default.vErrors} === null ? ${q} : ${d6.default.vErrors}.concat(${q})`), W.assign(d6.default.errors, g0._`${d6.default.vErrors}.length`);
    }
    function U(F) {
      var q;
      if (!J.opts.unevaluated) return;
      let N = (q = $ === null || $ === void 0 ? void 0 : $.validate) === null || q === void 0 ? void 0 : q.evaluated;
      if (J.props !== true) if (N && !N.dynamicProps) {
        if (N.props !== void 0) J.props = u8.mergeEvaluated.props(W, N.props, J.props);
      } else {
        let A = W.var("props", g0._`${F}.evaluated.props`);
        J.props = u8.mergeEvaluated.props(W, A, J.props, g0.Name);
      }
      if (J.items !== true) if (N && !N.dynamicItems) {
        if (N.items !== void 0) J.items = u8.mergeEvaluated.items(W, N.items, J.items);
      } else {
        let A = W.var("items", g0._`${F}.evaluated.items`);
        J.items = u8.mergeEvaluated.items(W, A, J.items, g0.Name);
      }
    }
  }
  kH.callRef = l8;
  kH.default = QM;
});
var xH = P((_H) => {
  Object.defineProperty(_H, "__esModule", { value: true });
  var WM = PH(), JM = TH(), GM = ["$schema", "$id", "$defs", "$vocabulary", { keyword: "$comment" }, "definitions", WM.default, JM.default];
  _H.default = GM;
});
var gH = P((yH) => {
  Object.defineProperty(yH, "__esModule", { value: true });
  var m8 = c(), i1 = m8.operators, c8 = { maximum: { okStr: "<=", ok: i1.LTE, fail: i1.GT }, minimum: { okStr: ">=", ok: i1.GTE, fail: i1.LT }, exclusiveMaximum: { okStr: "<", ok: i1.LT, fail: i1.GTE }, exclusiveMinimum: { okStr: ">", ok: i1.GT, fail: i1.LTE } }, BM = { message: ({ keyword: X, schemaCode: Q }) => m8.str`must be ${c8[X].okStr} ${Q}`, params: ({ keyword: X, schemaCode: Q }) => m8._`{comparison: ${c8[X].okStr}, limit: ${Q}}` }, zM = { keyword: Object.keys(c8), type: "number", schemaType: "number", $data: true, error: BM, code(X) {
    let { keyword: Q, data: $, schemaCode: Y } = X;
    X.fail$data(m8._`${$} ${c8[Q].fail} ${Y} || isNaN(${$})`);
  } };
  yH.default = zM;
});
var hH = P((fH) => {
  Object.defineProperty(fH, "__esModule", { value: true });
  var sX = c(), UM = { message: ({ schemaCode: X }) => sX.str`must be multiple of ${X}`, params: ({ schemaCode: X }) => sX._`{multipleOf: ${X}}` }, VM = { keyword: "multipleOf", type: "number", schemaType: "number", $data: true, error: UM, code(X) {
    let { gen: Q, data: $, schemaCode: Y, it: W } = X, J = W.opts.multipleOfPrecision, G = Q.let("res"), H = J ? sX._`Math.abs(Math.round(${G}) - ${G}) > 1e-${J}` : sX._`${G} !== parseInt(${G})`;
    X.fail$data(sX._`(${Y} === 0 || (${G} = ${$}/${Y}, ${H}))`);
  } };
  fH.default = VM;
});
var mH = P((lH) => {
  Object.defineProperty(lH, "__esModule", { value: true });
  function uH(X) {
    let Q = X.length, $ = 0, Y = 0, W;
    while (Y < Q) if ($++, W = X.charCodeAt(Y++), W >= 55296 && W <= 56319 && Y < Q) {
      if (W = X.charCodeAt(Y), (W & 64512) === 56320) Y++;
    }
    return $;
  }
  lH.default = uH;
  uH.code = 'require("ajv/dist/runtime/ucs2length").default';
});
var pH = P((cH) => {
  Object.defineProperty(cH, "__esModule", { value: true });
  var z6 = c(), FM = e(), NM = mH(), OM = { message({ keyword: X, schemaCode: Q }) {
    let $ = X === "maxLength" ? "more" : "fewer";
    return z6.str`must NOT have ${$} than ${Q} characters`;
  }, params: ({ schemaCode: X }) => z6._`{limit: ${X}}` }, DM = { keyword: ["maxLength", "minLength"], type: "string", schemaType: "number", $data: true, error: OM, code(X) {
    let { keyword: Q, data: $, schemaCode: Y, it: W } = X, J = Q === "maxLength" ? z6.operators.GT : z6.operators.LT, G = W.opts.unicode === false ? z6._`${$}.length` : z6._`${(0, FM.useFunc)(X.gen, NM.default)}(${$})`;
    X.fail$data(z6._`${G} ${J} ${Y}`);
  } };
  cH.default = DM;
});
var iH = P((dH) => {
  Object.defineProperty(dH, "__esModule", { value: true });
  var wM = d0(), p8 = c(), MM = { message: ({ schemaCode: X }) => p8.str`must match pattern "${X}"`, params: ({ schemaCode: X }) => p8._`{pattern: ${X}}` }, jM = { keyword: "pattern", type: "string", schemaType: "string", $data: true, error: MM, code(X) {
    let { data: Q, $data: $, schema: Y, schemaCode: W, it: J } = X, G = J.opts.unicodeRegExp ? "u" : "", H = $ ? p8._`(new RegExp(${W}, ${G}))` : (0, wM.usePattern)(X, Y);
    X.fail$data(p8._`!${H}.test(${Q})`);
  } };
  dH.default = jM;
});
var rH = P((nH) => {
  Object.defineProperty(nH, "__esModule", { value: true });
  var eX = c(), IM = { message({ keyword: X, schemaCode: Q }) {
    let $ = X === "maxProperties" ? "more" : "fewer";
    return eX.str`must NOT have ${$} than ${Q} properties`;
  }, params: ({ schemaCode: X }) => eX._`{limit: ${X}}` }, EM = { keyword: ["maxProperties", "minProperties"], type: "object", schemaType: "number", $data: true, error: IM, code(X) {
    let { keyword: Q, data: $, schemaCode: Y } = X, W = Q === "maxProperties" ? eX.operators.GT : eX.operators.LT;
    X.fail$data(eX._`Object.keys(${$}).length ${W} ${Y}`);
  } };
  nH.default = EM;
});
var tH = P((oH) => {
  Object.defineProperty(oH, "__esModule", { value: true });
  var X4 = d0(), Q4 = c(), PM = e(), SM = { message: ({ params: { missingProperty: X } }) => Q4.str`must have required property '${X}'`, params: ({ params: { missingProperty: X } }) => Q4._`{missingProperty: ${X}}` }, ZM = { keyword: "required", type: "object", schemaType: "array", $data: true, error: SM, code(X) {
    let { gen: Q, schema: $, schemaCode: Y, data: W, $data: J, it: G } = X, { opts: H } = G;
    if (!J && $.length === 0) return;
    let B = $.length >= H.loopRequired;
    if (G.allErrors) z();
    else K();
    if (H.strictRequired) {
      let U = X.parentSchema.properties, { definedProperties: F } = X.it;
      for (let q of $) if ((U === null || U === void 0 ? void 0 : U[q]) === void 0 && !F.has(q)) {
        let N = G.schemaEnv.baseId + G.errSchemaPath, A = `required property "${q}" is not defined at "${N}" (strictRequired)`;
        (0, PM.checkStrictMode)(G, A, G.opts.strictRequired);
      }
    }
    function z() {
      if (B || J) X.block$data(Q4.nil, V);
      else for (let U of $) (0, X4.checkReportMissingProp)(X, U);
    }
    function K() {
      let U = Q.let("missing");
      if (B || J) {
        let F = Q.let("valid", true);
        X.block$data(F, () => L(U, F)), X.ok(F);
      } else Q.if((0, X4.checkMissingProp)(X, $, U)), (0, X4.reportMissingProp)(X, U), Q.else();
    }
    function V() {
      Q.forOf("prop", Y, (U) => {
        X.setParams({ missingProperty: U }), Q.if((0, X4.noPropertyInData)(Q, W, U, H.ownProperties), () => X.error());
      });
    }
    function L(U, F) {
      X.setParams({ missingProperty: U }), Q.forOf(U, Y, () => {
        Q.assign(F, (0, X4.propertyInData)(Q, W, U, H.ownProperties)), Q.if((0, Q4.not)(F), () => {
          X.error(), Q.break();
        });
      }, Q4.nil);
    }
  } };
  oH.default = ZM;
});
var sH = P((aH) => {
  Object.defineProperty(aH, "__esModule", { value: true });
  var $4 = c(), kM = { message({ keyword: X, schemaCode: Q }) {
    let $ = X === "maxItems" ? "more" : "fewer";
    return $4.str`must NOT have ${$} than ${Q} items`;
  }, params: ({ schemaCode: X }) => $4._`{limit: ${X}}` }, vM = { keyword: ["maxItems", "minItems"], type: "array", schemaType: "number", $data: true, error: kM, code(X) {
    let { keyword: Q, data: $, schemaCode: Y } = X, W = Q === "maxItems" ? $4.operators.GT : $4.operators.LT;
    X.fail$data($4._`${$}.length ${W} ${Y}`);
  } };
  aH.default = vM;
});
var d8 = P((XB) => {
  Object.defineProperty(XB, "__esModule", { value: true });
  var eH = DY();
  eH.code = 'require("ajv/dist/runtime/equal").default';
  XB.default = eH;
});
var $B = P((QB) => {
  Object.defineProperty(QB, "__esModule", { value: true });
  var TY = mX(), I0 = c(), xM = e(), yM = d8(), gM = { message: ({ params: { i: X, j: Q } }) => I0.str`must NOT have duplicate items (items ## ${Q} and ${X} are identical)`, params: ({ params: { i: X, j: Q } }) => I0._`{i: ${X}, j: ${Q}}` }, fM = { keyword: "uniqueItems", type: "array", schemaType: "boolean", $data: true, error: gM, code(X) {
    let { gen: Q, data: $, $data: Y, schema: W, parentSchema: J, schemaCode: G, it: H } = X;
    if (!Y && !W) return;
    let B = Q.let("valid"), z = J.items ? (0, TY.getSchemaTypes)(J.items) : [];
    X.block$data(B, K, I0._`${G} === false`), X.ok(B);
    function K() {
      let F = Q.let("i", I0._`${$}.length`), q = Q.let("j");
      X.setParams({ i: F, j: q }), Q.assign(B, true), Q.if(I0._`${F} > 1`, () => (V() ? L : U)(F, q));
    }
    function V() {
      return z.length > 0 && !z.some((F) => F === "object" || F === "array");
    }
    function L(F, q) {
      let N = Q.name("item"), A = (0, TY.checkDataTypes)(z, N, H.opts.strictNumbers, TY.DataType.Wrong), M = Q.const("indices", I0._`{}`);
      Q.for(I0._`;${F}--;`, () => {
        if (Q.let(N, I0._`${$}[${F}]`), Q.if(A, I0._`continue`), z.length > 1) Q.if(I0._`typeof ${N} == "string"`, I0._`${N} += "_"`);
        Q.if(I0._`typeof ${M}[${N}] == "number"`, () => {
          Q.assign(q, I0._`${M}[${N}]`), X.error(), Q.assign(B, false).break();
        }).code(I0._`${M}[${N}] = ${F}`);
      });
    }
    function U(F, q) {
      let N = (0, xM.useFunc)(Q, yM.default), A = Q.name("outer");
      Q.label(A).for(I0._`;${F}--;`, () => Q.for(I0._`${q} = ${F}; ${q}--;`, () => Q.if(I0._`${N}(${$}[${F}], ${$}[${q}])`, () => {
        X.error(), Q.assign(B, false).break(A);
      })));
    }
  } };
  QB.default = fM;
});
var WB = P((YB) => {
  Object.defineProperty(YB, "__esModule", { value: true });
  var _Y = c(), uM = e(), lM = d8(), mM = { message: "must be equal to constant", params: ({ schemaCode: X }) => _Y._`{allowedValue: ${X}}` }, cM = { keyword: "const", $data: true, error: mM, code(X) {
    let { gen: Q, data: $, $data: Y, schemaCode: W, schema: J } = X;
    if (Y || J && typeof J == "object") X.fail$data(_Y._`!${(0, uM.useFunc)(Q, lM.default)}(${$}, ${W})`);
    else X.fail(_Y._`${J} !== ${$}`);
  } };
  YB.default = cM;
});
var GB = P((JB) => {
  Object.defineProperty(JB, "__esModule", { value: true });
  var Y4 = c(), dM = e(), iM = d8(), nM = { message: "must be equal to one of the allowed values", params: ({ schemaCode: X }) => Y4._`{allowedValues: ${X}}` }, rM = { keyword: "enum", schemaType: "array", $data: true, error: nM, code(X) {
    let { gen: Q, data: $, $data: Y, schema: W, schemaCode: J, it: G } = X;
    if (!Y && W.length === 0) throw Error("enum must have non-empty array");
    let H = W.length >= G.opts.loopEnum, B, z = () => B !== null && B !== void 0 ? B : B = (0, dM.useFunc)(Q, iM.default), K;
    if (H || Y) K = Q.let("valid"), X.block$data(K, V);
    else {
      if (!Array.isArray(W)) throw Error("ajv implementation error");
      let U = Q.const("vSchema", J);
      K = (0, Y4.or)(...W.map((F, q) => L(U, q)));
    }
    X.pass(K);
    function V() {
      Q.assign(K, false), Q.forOf("v", J, (U) => Q.if(Y4._`${z()}(${$}, ${U})`, () => Q.assign(K, true).break()));
    }
    function L(U, F) {
      let q = W[F];
      return typeof q === "object" && q !== null ? Y4._`${z()}(${$}, ${U}[${F}])` : Y4._`${$} === ${q}`;
    }
  } };
  JB.default = rM;
});
var BB = P((HB) => {
  Object.defineProperty(HB, "__esModule", { value: true });
  var tM = gH(), aM = hH(), sM = pH(), eM = iH(), Xj = rH(), Qj = tH(), $j = sH(), Yj = $B(), Wj = WB(), Jj = GB(), Gj = [tM.default, aM.default, sM.default, eM.default, Xj.default, Qj.default, $j.default, Yj.default, { keyword: "type", schemaType: ["string", "array"] }, { keyword: "nullable", schemaType: "boolean" }, Wj.default, Jj.default];
  HB.default = Gj;
});
var yY = P((KB) => {
  Object.defineProperty(KB, "__esModule", { value: true });
  KB.validateAdditionalItems = void 0;
  var K6 = c(), xY = e(), Bj = { message: ({ params: { len: X } }) => K6.str`must NOT have more than ${X} items`, params: ({ params: { len: X } }) => K6._`{limit: ${X}}` }, zj = { keyword: "additionalItems", type: "array", schemaType: ["boolean", "object"], before: "uniqueItems", error: Bj, code(X) {
    let { parentSchema: Q, it: $ } = X, { items: Y } = Q;
    if (!Array.isArray(Y)) {
      (0, xY.checkStrictMode)($, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    zB(X, Y);
  } };
  function zB(X, Q) {
    let { gen: $, schema: Y, data: W, keyword: J, it: G } = X;
    G.items = true;
    let H = $.const("len", K6._`${W}.length`);
    if (Y === false) X.setParams({ len: Q.length }), X.pass(K6._`${H} <= ${Q.length}`);
    else if (typeof Y == "object" && !(0, xY.alwaysValidSchema)(G, Y)) {
      let z = $.var("valid", K6._`${H} <= ${Q.length}`);
      $.if((0, K6.not)(z), () => B(z)), X.ok(z);
    }
    function B(z) {
      $.forRange("i", Q.length, H, (K) => {
        if (X.subschema({ keyword: J, dataProp: K, dataPropType: xY.Type.Num }, z), !G.allErrors) $.if((0, K6.not)(z), () => $.break());
      });
    }
  }
  KB.validateAdditionalItems = zB;
  KB.default = zj;
});
var gY = P((qB) => {
  Object.defineProperty(qB, "__esModule", { value: true });
  qB.validateTuple = void 0;
  var VB = c(), i8 = e(), Uj = d0(), Vj = { keyword: "items", type: "array", schemaType: ["object", "array", "boolean"], before: "uniqueItems", code(X) {
    let { schema: Q, it: $ } = X;
    if (Array.isArray(Q)) return LB(X, "additionalItems", Q);
    if ($.items = true, (0, i8.alwaysValidSchema)($, Q)) return;
    X.ok((0, Uj.validateArray)(X));
  } };
  function LB(X, Q, $ = X.schema) {
    let { gen: Y, parentSchema: W, data: J, keyword: G, it: H } = X;
    if (K(W), H.opts.unevaluated && $.length && H.items !== true) H.items = i8.mergeEvaluated.items(Y, $.length, H.items);
    let B = Y.name("valid"), z = Y.const("len", VB._`${J}.length`);
    $.forEach((V, L) => {
      if ((0, i8.alwaysValidSchema)(H, V)) return;
      Y.if(VB._`${z} > ${L}`, () => X.subschema({ keyword: G, schemaProp: L, dataProp: L }, B)), X.ok(B);
    });
    function K(V) {
      let { opts: L, errSchemaPath: U } = H, F = $.length, q = F === V.minItems && (F === V.maxItems || V[Q] === false);
      if (L.strictTuples && !q) {
        let N = `"${G}" is ${F}-tuple, but minItems or maxItems/${Q} are not specified or different at path "${U}"`;
        (0, i8.checkStrictMode)(H, N, L.strictTuples);
      }
    }
  }
  qB.validateTuple = LB;
  qB.default = Vj;
});
var OB = P((NB) => {
  Object.defineProperty(NB, "__esModule", { value: true });
  var qj = gY(), Fj = { keyword: "prefixItems", type: "array", schemaType: ["array"], before: "uniqueItems", code: (X) => (0, qj.validateTuple)(X, "items") };
  NB.default = Fj;
});
var wB = P((AB) => {
  Object.defineProperty(AB, "__esModule", { value: true });
  var DB = c(), Oj = e(), Dj = d0(), Aj = yY(), wj = { message: ({ params: { len: X } }) => DB.str`must NOT have more than ${X} items`, params: ({ params: { len: X } }) => DB._`{limit: ${X}}` }, Mj = { keyword: "items", type: "array", schemaType: ["object", "boolean"], before: "uniqueItems", error: wj, code(X) {
    let { schema: Q, parentSchema: $, it: Y } = X, { prefixItems: W } = $;
    if (Y.items = true, (0, Oj.alwaysValidSchema)(Y, Q)) return;
    if (W) (0, Aj.validateAdditionalItems)(X, W);
    else X.ok((0, Dj.validateArray)(X));
  } };
  AB.default = Mj;
});
var jB = P((MB) => {
  Object.defineProperty(MB, "__esModule", { value: true });
  var i0 = c(), n8 = e(), Rj = { message: ({ params: { min: X, max: Q } }) => Q === void 0 ? i0.str`must contain at least ${X} valid item(s)` : i0.str`must contain at least ${X} and no more than ${Q} valid item(s)`, params: ({ params: { min: X, max: Q } }) => Q === void 0 ? i0._`{minContains: ${X}}` : i0._`{minContains: ${X}, maxContains: ${Q}}` }, Ij = { keyword: "contains", type: "array", schemaType: ["object", "boolean"], before: "uniqueItems", trackErrors: true, error: Rj, code(X) {
    let { gen: Q, schema: $, parentSchema: Y, data: W, it: J } = X, G, H, { minContains: B, maxContains: z } = Y;
    if (J.opts.next) G = B === void 0 ? 1 : B, H = z;
    else G = 1;
    let K = Q.const("len", i0._`${W}.length`);
    if (X.setParams({ min: G, max: H }), H === void 0 && G === 0) {
      (0, n8.checkStrictMode)(J, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (H !== void 0 && G > H) {
      (0, n8.checkStrictMode)(J, '"minContains" > "maxContains" is always invalid'), X.fail();
      return;
    }
    if ((0, n8.alwaysValidSchema)(J, $)) {
      let q = i0._`${K} >= ${G}`;
      if (H !== void 0) q = i0._`${q} && ${K} <= ${H}`;
      X.pass(q);
      return;
    }
    J.items = true;
    let V = Q.name("valid");
    if (H === void 0 && G === 1) U(V, () => Q.if(V, () => Q.break()));
    else if (G === 0) {
      if (Q.let(V, true), H !== void 0) Q.if(i0._`${W}.length > 0`, L);
    } else Q.let(V, false), L();
    X.result(V, () => X.reset());
    function L() {
      let q = Q.name("_valid"), N = Q.let("count", 0);
      U(q, () => Q.if(q, () => F(N)));
    }
    function U(q, N) {
      Q.forRange("i", 0, K, (A) => {
        X.subschema({ keyword: "contains", dataProp: A, dataPropType: n8.Type.Num, compositeRule: true }, q), N();
      });
    }
    function F(q) {
      if (Q.code(i0._`${q}++`), H === void 0) Q.if(i0._`${q} >= ${G}`, () => Q.assign(V, true).break());
      else if (Q.if(i0._`${q} > ${H}`, () => Q.assign(V, false).break()), G === 1) Q.assign(V, true);
      else Q.if(i0._`${q} >= ${G}`, () => Q.assign(V, true));
    }
  } };
  MB.default = Ij;
});
var SB = P((EB) => {
  Object.defineProperty(EB, "__esModule", { value: true });
  EB.validateSchemaDeps = EB.validatePropertyDeps = EB.error = void 0;
  var fY = c(), bj = e(), W4 = d0();
  EB.error = { message: ({ params: { property: X, depsCount: Q, deps: $ } }) => {
    let Y = Q === 1 ? "property" : "properties";
    return fY.str`must have ${Y} ${$} when property ${X} is present`;
  }, params: ({ params: { property: X, depsCount: Q, deps: $, missingProperty: Y } }) => fY._`{property: ${X},
    missingProperty: ${Y},
    depsCount: ${Q},
    deps: ${$}}` };
  var Pj = { keyword: "dependencies", type: "object", schemaType: "object", error: EB.error, code(X) {
    let [Q, $] = Sj(X);
    RB(X, Q), IB(X, $);
  } };
  function Sj({ schema: X }) {
    let Q = {}, $ = {};
    for (let Y in X) {
      if (Y === "__proto__") continue;
      let W = Array.isArray(X[Y]) ? Q : $;
      W[Y] = X[Y];
    }
    return [Q, $];
  }
  function RB(X, Q = X.schema) {
    let { gen: $, data: Y, it: W } = X;
    if (Object.keys(Q).length === 0) return;
    let J = $.let("missing");
    for (let G in Q) {
      let H = Q[G];
      if (H.length === 0) continue;
      let B = (0, W4.propertyInData)($, Y, G, W.opts.ownProperties);
      if (X.setParams({ property: G, depsCount: H.length, deps: H.join(", ") }), W.allErrors) $.if(B, () => {
        for (let z of H) (0, W4.checkReportMissingProp)(X, z);
      });
      else $.if(fY._`${B} && (${(0, W4.checkMissingProp)(X, H, J)})`), (0, W4.reportMissingProp)(X, J), $.else();
    }
  }
  EB.validatePropertyDeps = RB;
  function IB(X, Q = X.schema) {
    let { gen: $, data: Y, keyword: W, it: J } = X, G = $.name("valid");
    for (let H in Q) {
      if ((0, bj.alwaysValidSchema)(J, Q[H])) continue;
      $.if((0, W4.propertyInData)($, Y, H, J.opts.ownProperties), () => {
        let B = X.subschema({ keyword: W, schemaProp: H }, G);
        X.mergeValidEvaluated(B, G);
      }, () => $.var(G, true)), X.ok(G);
    }
  }
  EB.validateSchemaDeps = IB;
  EB.default = Pj;
});
var kB = P((CB) => {
  Object.defineProperty(CB, "__esModule", { value: true });
  var ZB = c(), kj = e(), vj = { message: "property name must be valid", params: ({ params: X }) => ZB._`{propertyName: ${X.propertyName}}` }, Tj = { keyword: "propertyNames", type: "object", schemaType: ["object", "boolean"], error: vj, code(X) {
    let { gen: Q, schema: $, data: Y, it: W } = X;
    if ((0, kj.alwaysValidSchema)(W, $)) return;
    let J = Q.name("valid");
    Q.forIn("key", Y, (G) => {
      X.setParams({ propertyName: G }), X.subschema({ keyword: "propertyNames", data: G, dataTypes: ["string"], propertyName: G, compositeRule: true }, J), Q.if((0, ZB.not)(J), () => {
        if (X.error(true), !W.allErrors) Q.break();
      });
    }), X.ok(J);
  } };
  CB.default = Tj;
});
var hY = P((vB) => {
  Object.defineProperty(vB, "__esModule", { value: true });
  var r8 = d0(), $1 = c(), xj = R1(), o8 = e(), yj = { message: "must NOT have additional properties", params: ({ params: X }) => $1._`{additionalProperty: ${X.additionalProperty}}` }, gj = { keyword: "additionalProperties", type: ["object"], schemaType: ["boolean", "object"], allowUndefined: true, trackErrors: true, error: yj, code(X) {
    let { gen: Q, schema: $, parentSchema: Y, data: W, errsCount: J, it: G } = X;
    if (!J) throw Error("ajv implementation error");
    let { allErrors: H, opts: B } = G;
    if (G.props = true, B.removeAdditional !== "all" && (0, o8.alwaysValidSchema)(G, $)) return;
    let z = (0, r8.allSchemaProperties)(Y.properties), K = (0, r8.allSchemaProperties)(Y.patternProperties);
    V(), X.ok($1._`${J} === ${xj.default.errors}`);
    function V() {
      Q.forIn("key", W, (N) => {
        if (!z.length && !K.length) F(N);
        else Q.if(L(N), () => F(N));
      });
    }
    function L(N) {
      let A;
      if (z.length > 8) {
        let M = (0, o8.schemaRefOrVal)(G, Y.properties, "properties");
        A = (0, r8.isOwnProperty)(Q, M, N);
      } else if (z.length) A = (0, $1.or)(...z.map((M) => $1._`${N} === ${M}`));
      else A = $1.nil;
      if (K.length) A = (0, $1.or)(A, ...K.map((M) => $1._`${(0, r8.usePattern)(X, M)}.test(${N})`));
      return (0, $1.not)(A);
    }
    function U(N) {
      Q.code($1._`delete ${W}[${N}]`);
    }
    function F(N) {
      if (B.removeAdditional === "all" || B.removeAdditional && $ === false) {
        U(N);
        return;
      }
      if ($ === false) {
        if (X.setParams({ additionalProperty: N }), X.error(), !H) Q.break();
        return;
      }
      if (typeof $ == "object" && !(0, o8.alwaysValidSchema)(G, $)) {
        let A = Q.name("valid");
        if (B.removeAdditional === "failing") q(N, A, false), Q.if((0, $1.not)(A), () => {
          X.reset(), U(N);
        });
        else if (q(N, A), !H) Q.if((0, $1.not)(A), () => Q.break());
      }
    }
    function q(N, A, M) {
      let R = { keyword: "additionalProperties", dataProp: N, dataPropType: o8.Type.Str };
      if (M === false) Object.assign(R, { compositeRule: true, createErrors: false, allErrors: false });
      X.subschema(R, A);
    }
  } };
  vB.default = gj;
});
var yB = P((xB) => {
  Object.defineProperty(xB, "__esModule", { value: true });
  var hj = iX(), TB = d0(), uY = e(), _B = hY(), uj = { keyword: "properties", type: "object", schemaType: "object", code(X) {
    let { gen: Q, schema: $, parentSchema: Y, data: W, it: J } = X;
    if (J.opts.removeAdditional === "all" && Y.additionalProperties === void 0) _B.default.code(new hj.KeywordCxt(J, _B.default, "additionalProperties"));
    let G = (0, TB.allSchemaProperties)($);
    for (let V of G) J.definedProperties.add(V);
    if (J.opts.unevaluated && G.length && J.props !== true) J.props = uY.mergeEvaluated.props(Q, (0, uY.toHash)(G), J.props);
    let H = G.filter((V) => !(0, uY.alwaysValidSchema)(J, $[V]));
    if (H.length === 0) return;
    let B = Q.name("valid");
    for (let V of H) {
      if (z(V)) K(V);
      else {
        if (Q.if((0, TB.propertyInData)(Q, W, V, J.opts.ownProperties)), K(V), !J.allErrors) Q.else().var(B, true);
        Q.endIf();
      }
      X.it.definedProperties.add(V), X.ok(B);
    }
    function z(V) {
      return J.opts.useDefaults && !J.compositeRule && $[V].default !== void 0;
    }
    function K(V) {
      X.subschema({ keyword: "properties", schemaProp: V, dataProp: V }, B);
    }
  } };
  xB.default = uj;
});
var lB = P((uB) => {
  Object.defineProperty(uB, "__esModule", { value: true });
  var gB = d0(), t8 = c(), fB = e(), hB = e(), mj = { keyword: "patternProperties", type: "object", schemaType: "object", code(X) {
    let { gen: Q, schema: $, data: Y, parentSchema: W, it: J } = X, { opts: G } = J, H = (0, gB.allSchemaProperties)($), B = H.filter((q) => (0, fB.alwaysValidSchema)(J, $[q]));
    if (H.length === 0 || B.length === H.length && (!J.opts.unevaluated || J.props === true)) return;
    let z = G.strictSchema && !G.allowMatchingProperties && W.properties, K = Q.name("valid");
    if (J.props !== true && !(J.props instanceof t8.Name)) J.props = (0, hB.evaluatedPropsToName)(Q, J.props);
    let { props: V } = J;
    L();
    function L() {
      for (let q of H) {
        if (z) U(q);
        if (J.allErrors) F(q);
        else Q.var(K, true), F(q), Q.if(K);
      }
    }
    function U(q) {
      for (let N in z) if (new RegExp(q).test(N)) (0, fB.checkStrictMode)(J, `property ${N} matches pattern ${q} (use allowMatchingProperties)`);
    }
    function F(q) {
      Q.forIn("key", Y, (N) => {
        Q.if(t8._`${(0, gB.usePattern)(X, q)}.test(${N})`, () => {
          let A = B.includes(q);
          if (!A) X.subschema({ keyword: "patternProperties", schemaProp: q, dataProp: N, dataPropType: hB.Type.Str }, K);
          if (J.opts.unevaluated && V !== true) Q.assign(t8._`${V}[${N}]`, true);
          else if (!A && !J.allErrors) Q.if((0, t8.not)(K), () => Q.break());
        });
      });
    }
  } };
  uB.default = mj;
});
var cB = P((mB) => {
  Object.defineProperty(mB, "__esModule", { value: true });
  var pj = e(), dj = { keyword: "not", schemaType: ["object", "boolean"], trackErrors: true, code(X) {
    let { gen: Q, schema: $, it: Y } = X;
    if ((0, pj.alwaysValidSchema)(Y, $)) {
      X.fail();
      return;
    }
    let W = Q.name("valid");
    X.subschema({ keyword: "not", compositeRule: true, createErrors: false, allErrors: false }, W), X.failResult(W, () => X.reset(), () => X.error());
  }, error: { message: "must NOT be valid" } };
  mB.default = dj;
});
var dB = P((pB) => {
  Object.defineProperty(pB, "__esModule", { value: true });
  var nj = d0(), rj = { keyword: "anyOf", schemaType: "array", trackErrors: true, code: nj.validateUnion, error: { message: "must match a schema in anyOf" } };
  pB.default = rj;
});
var nB = P((iB) => {
  Object.defineProperty(iB, "__esModule", { value: true });
  var a8 = c(), tj = e(), aj = { message: "must match exactly one schema in oneOf", params: ({ params: X }) => a8._`{passingSchemas: ${X.passing}}` }, sj = { keyword: "oneOf", schemaType: "array", trackErrors: true, error: aj, code(X) {
    let { gen: Q, schema: $, parentSchema: Y, it: W } = X;
    if (!Array.isArray($)) throw Error("ajv implementation error");
    if (W.opts.discriminator && Y.discriminator) return;
    let J = $, G = Q.let("valid", false), H = Q.let("passing", null), B = Q.name("_valid");
    X.setParams({ passing: H }), Q.block(z), X.result(G, () => X.reset(), () => X.error(true));
    function z() {
      J.forEach((K, V) => {
        let L;
        if ((0, tj.alwaysValidSchema)(W, K)) Q.var(B, true);
        else L = X.subschema({ keyword: "oneOf", schemaProp: V, compositeRule: true }, B);
        if (V > 0) Q.if(a8._`${B} && ${G}`).assign(G, false).assign(H, a8._`[${H}, ${V}]`).else();
        Q.if(B, () => {
          if (Q.assign(G, true), Q.assign(H, V), L) X.mergeEvaluated(L, a8.Name);
        });
      });
    }
  } };
  iB.default = sj;
});
var oB = P((rB) => {
  Object.defineProperty(rB, "__esModule", { value: true });
  var XR = e(), QR = { keyword: "allOf", schemaType: "array", code(X) {
    let { gen: Q, schema: $, it: Y } = X;
    if (!Array.isArray($)) throw Error("ajv implementation error");
    let W = Q.name("valid");
    $.forEach((J, G) => {
      if ((0, XR.alwaysValidSchema)(Y, J)) return;
      let H = X.subschema({ keyword: "allOf", schemaProp: G }, W);
      X.ok(W), X.mergeEvaluated(H);
    });
  } };
  rB.default = QR;
});
var eB = P((sB) => {
  Object.defineProperty(sB, "__esModule", { value: true });
  var s8 = c(), aB = e(), YR = { message: ({ params: X }) => s8.str`must match "${X.ifClause}" schema`, params: ({ params: X }) => s8._`{failingKeyword: ${X.ifClause}}` }, WR = { keyword: "if", schemaType: ["object", "boolean"], trackErrors: true, error: YR, code(X) {
    let { gen: Q, parentSchema: $, it: Y } = X;
    if ($.then === void 0 && $.else === void 0) (0, aB.checkStrictMode)(Y, '"if" without "then" and "else" is ignored');
    let W = tB(Y, "then"), J = tB(Y, "else");
    if (!W && !J) return;
    let G = Q.let("valid", true), H = Q.name("_valid");
    if (B(), X.reset(), W && J) {
      let K = Q.let("ifClause");
      X.setParams({ ifClause: K }), Q.if(H, z("then", K), z("else", K));
    } else if (W) Q.if(H, z("then"));
    else Q.if((0, s8.not)(H), z("else"));
    X.pass(G, () => X.error(true));
    function B() {
      let K = X.subschema({ keyword: "if", compositeRule: true, createErrors: false, allErrors: false }, H);
      X.mergeEvaluated(K);
    }
    function z(K, V) {
      return () => {
        let L = X.subschema({ keyword: K }, H);
        if (Q.assign(G, H), X.mergeValidEvaluated(L, G), V) Q.assign(V, s8._`${K}`);
        else X.setParams({ ifClause: K });
      };
    }
  } };
  function tB(X, Q) {
    let $ = X.schema[Q];
    return $ !== void 0 && !(0, aB.alwaysValidSchema)(X, $);
  }
  sB.default = WR;
});
var Qz = P((Xz) => {
  Object.defineProperty(Xz, "__esModule", { value: true });
  var GR = e(), HR = { keyword: ["then", "else"], schemaType: ["object", "boolean"], code({ keyword: X, parentSchema: Q, it: $ }) {
    if (Q.if === void 0) (0, GR.checkStrictMode)($, `"${X}" without "if" is ignored`);
  } };
  Xz.default = HR;
});
var Yz = P(($z) => {
  Object.defineProperty($z, "__esModule", { value: true });
  var zR = yY(), KR = OB(), UR = gY(), VR = wB(), LR = jB(), qR = SB(), FR = kB(), NR = hY(), OR = yB(), DR = lB(), AR = cB(), wR = dB(), MR = nB(), jR = oB(), RR = eB(), IR = Qz();
  function ER(X = false) {
    let Q = [AR.default, wR.default, MR.default, jR.default, RR.default, IR.default, FR.default, NR.default, qR.default, OR.default, DR.default];
    if (X) Q.push(KR.default, VR.default);
    else Q.push(zR.default, UR.default);
    return Q.push(LR.default), Q;
  }
  $z.default = ER;
});
var Jz = P((Wz) => {
  Object.defineProperty(Wz, "__esModule", { value: true });
  var L0 = c(), PR = { message: ({ schemaCode: X }) => L0.str`must match format "${X}"`, params: ({ schemaCode: X }) => L0._`{format: ${X}}` }, SR = { keyword: "format", type: ["number", "string"], schemaType: "string", $data: true, error: PR, code(X, Q) {
    let { gen: $, data: Y, $data: W, schema: J, schemaCode: G, it: H } = X, { opts: B, errSchemaPath: z, schemaEnv: K, self: V } = H;
    if (!B.validateFormats) return;
    if (W) L();
    else U();
    function L() {
      let F = $.scopeValue("formats", { ref: V.formats, code: B.code.formats }), q = $.const("fDef", L0._`${F}[${G}]`), N = $.let("fType"), A = $.let("format");
      $.if(L0._`typeof ${q} == "object" && !(${q} instanceof RegExp)`, () => $.assign(N, L0._`${q}.type || "string"`).assign(A, L0._`${q}.validate`), () => $.assign(N, L0._`"string"`).assign(A, q)), X.fail$data((0, L0.or)(M(), R()));
      function M() {
        if (B.strictSchema === false) return L0.nil;
        return L0._`${G} && !${A}`;
      }
      function R() {
        let S = K.$async ? L0._`(${q}.async ? await ${A}(${Y}) : ${A}(${Y}))` : L0._`${A}(${Y})`, C = L0._`(typeof ${A} == "function" ? ${S} : ${A}.test(${Y}))`;
        return L0._`${A} && ${A} !== true && ${N} === ${Q} && !${C}`;
      }
    }
    function U() {
      let F = V.formats[J];
      if (!F) {
        M();
        return;
      }
      if (F === true) return;
      let [q, N, A] = R(F);
      if (q === Q) X.pass(S());
      function M() {
        if (B.strictSchema === false) {
          V.logger.warn(C());
          return;
        }
        throw Error(C());
        function C() {
          return `unknown format "${J}" ignored in schema at path "${z}"`;
        }
      }
      function R(C) {
        let K0 = C instanceof RegExp ? (0, L0.regexpCode)(C) : B.code.formats ? L0._`${B.code.formats}${(0, L0.getProperty)(J)}` : void 0, U0 = $.scopeValue("formats", { key: J, ref: C, code: K0 });
        if (typeof C == "object" && !(C instanceof RegExp)) return [C.type || "string", C.validate, L0._`${U0}.validate`];
        return ["string", C, U0];
      }
      function S() {
        if (typeof F == "object" && !(F instanceof RegExp) && F.async) {
          if (!K.$async) throw Error("async format in sync schema");
          return L0._`await ${A}(${Y})`;
        }
        return typeof N == "function" ? L0._`${A}(${Y})` : L0._`${A}.test(${Y})`;
      }
    }
  } };
  Wz.default = SR;
});
var Hz = P((Gz) => {
  Object.defineProperty(Gz, "__esModule", { value: true });
  var CR = Jz(), kR = [CR.default];
  Gz.default = kR;
});
var Kz = P((Bz) => {
  Object.defineProperty(Bz, "__esModule", { value: true });
  Bz.contentVocabulary = Bz.metadataVocabulary = void 0;
  Bz.metadataVocabulary = ["title", "description", "default", "deprecated", "readOnly", "writeOnly", "examples"];
  Bz.contentVocabulary = ["contentMediaType", "contentEncoding", "contentSchema"];
});
var Lz = P((Vz) => {
  Object.defineProperty(Vz, "__esModule", { value: true });
  var _R = xH(), xR = BB(), yR = Yz(), gR = Hz(), Uz = Kz(), fR = [_R.default, xR.default, (0, yR.default)(), gR.default, Uz.metadataVocabulary, Uz.contentVocabulary];
  Vz.default = fR;
});
var Oz = P((Fz) => {
  Object.defineProperty(Fz, "__esModule", { value: true });
  Fz.DiscrError = void 0;
  var qz;
  (function(X) {
    X.Tag = "tag", X.Mapping = "mapping";
  })(qz || (Fz.DiscrError = qz = {}));
});
var wz = P((Az) => {
  Object.defineProperty(Az, "__esModule", { value: true });
  var i6 = c(), lY = Oz(), Dz = _8(), uR = nX(), lR = e(), mR = { message: ({ params: { discrError: X, tagName: Q } }) => X === lY.DiscrError.Tag ? `tag "${Q}" must be string` : `value of tag "${Q}" must be in oneOf`, params: ({ params: { discrError: X, tag: Q, tagName: $ } }) => i6._`{error: ${X}, tag: ${$}, tagValue: ${Q}}` }, cR = { keyword: "discriminator", type: "object", schemaType: "object", error: mR, code(X) {
    let { gen: Q, data: $, schema: Y, parentSchema: W, it: J } = X, { oneOf: G } = W;
    if (!J.opts.discriminator) throw Error("discriminator: requires discriminator option");
    let H = Y.propertyName;
    if (typeof H != "string") throw Error("discriminator: requires propertyName");
    if (Y.mapping) throw Error("discriminator: mapping is not supported");
    if (!G) throw Error("discriminator: requires oneOf keyword");
    let B = Q.let("valid", false), z = Q.const("tag", i6._`${$}${(0, i6.getProperty)(H)}`);
    Q.if(i6._`typeof ${z} == "string"`, () => K(), () => X.error(false, { discrError: lY.DiscrError.Tag, tag: z, tagName: H })), X.ok(B);
    function K() {
      let U = L();
      Q.if(false);
      for (let F in U) Q.elseIf(i6._`${z} === ${F}`), Q.assign(B, V(U[F]));
      Q.else(), X.error(false, { discrError: lY.DiscrError.Mapping, tag: z, tagName: H }), Q.endIf();
    }
    function V(U) {
      let F = Q.name("valid"), q = X.subschema({ keyword: "oneOf", schemaProp: U }, F);
      return X.mergeEvaluated(q, i6.Name), F;
    }
    function L() {
      var U;
      let F = {}, q = A(W), N = true;
      for (let S = 0; S < G.length; S++) {
        let C = G[S];
        if ((C === null || C === void 0 ? void 0 : C.$ref) && !(0, lR.schemaHasRulesButRef)(C, J.self.RULES)) {
          let U0 = C.$ref;
          if (C = Dz.resolveRef.call(J.self, J.schemaEnv.root, J.baseId, U0), C instanceof Dz.SchemaEnv) C = C.schema;
          if (C === void 0) throw new uR.default(J.opts.uriResolver, J.baseId, U0);
        }
        let K0 = (U = C === null || C === void 0 ? void 0 : C.properties) === null || U === void 0 ? void 0 : U[H];
        if (typeof K0 != "object") throw Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${H}"`);
        N = N && (q || A(C)), M(K0, S);
      }
      if (!N) throw Error(`discriminator: "${H}" must be required`);
      return F;
      function A({ required: S }) {
        return Array.isArray(S) && S.includes(H);
      }
      function M(S, C) {
        if (S.const) R(S.const, C);
        else if (S.enum) for (let K0 of S.enum) R(K0, C);
        else throw Error(`discriminator: "properties/${H}" must have "const" or "enum"`);
      }
      function R(S, C) {
        if (typeof S != "string" || S in F) throw Error(`discriminator: "${H}" values must be unique strings`);
        F[S] = C;
      }
    }
  } };
  Az.default = cR;
});
var Mz = P((W_, dR) => {
  dR.exports = { $schema: "http://json-schema.org/draft-07/schema#", $id: "http://json-schema.org/draft-07/schema#", title: "Core schema meta-schema", definitions: { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: true, default: [] } }, type: ["object", "boolean"], properties: { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: true, readOnly: { type: "boolean", default: false }, examples: { type: "array", items: true }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: true }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: false }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: true, enum: { type: "array", items: true, minItems: 1, uniqueItems: true }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: true }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, default: true };
});
var cY = P((f0, mY) => {
  Object.defineProperty(f0, "__esModule", { value: true });
  f0.MissingRefError = f0.ValidationError = f0.CodeGen = f0.Name = f0.nil = f0.stringify = f0.str = f0._ = f0.KeywordCxt = f0.Ajv = void 0;
  var iR = EH(), nR = Lz(), rR = wz(), jz = Mz(), oR = ["/properties"], e8 = "http://json-schema.org/draft-07/schema";
  class J4 extends iR.default {
    _addVocabularies() {
      if (super._addVocabularies(), nR.default.forEach((X) => this.addVocabulary(X)), this.opts.discriminator) this.addKeyword(rR.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta) return;
      let X = this.opts.$data ? this.$dataMetaSchema(jz, oR) : jz;
      this.addMetaSchema(X, e8, false), this.refs["http://json-schema.org/schema"] = e8;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(e8) ? e8 : void 0);
    }
  }
  f0.Ajv = J4;
  mY.exports = f0 = J4;
  mY.exports.Ajv = J4;
  Object.defineProperty(f0, "__esModule", { value: true });
  f0.default = J4;
  var tR = iX();
  Object.defineProperty(f0, "KeywordCxt", { enumerable: true, get: function() {
    return tR.KeywordCxt;
  } });
  var n6 = c();
  Object.defineProperty(f0, "_", { enumerable: true, get: function() {
    return n6._;
  } });
  Object.defineProperty(f0, "str", { enumerable: true, get: function() {
    return n6.str;
  } });
  Object.defineProperty(f0, "stringify", { enumerable: true, get: function() {
    return n6.stringify;
  } });
  Object.defineProperty(f0, "nil", { enumerable: true, get: function() {
    return n6.nil;
  } });
  Object.defineProperty(f0, "Name", { enumerable: true, get: function() {
    return n6.Name;
  } });
  Object.defineProperty(f0, "CodeGen", { enumerable: true, get: function() {
    return n6.CodeGen;
  } });
  var aR = v8();
  Object.defineProperty(f0, "ValidationError", { enumerable: true, get: function() {
    return aR.default;
  } });
  var sR = nX();
  Object.defineProperty(f0, "MissingRefError", { enumerable: true, get: function() {
    return sR.default;
  } });
});
var vz = P((Cz) => {
  Object.defineProperty(Cz, "__esModule", { value: true });
  Cz.formatNames = Cz.fastFormats = Cz.fullFormats = void 0;
  function L1(X, Q) {
    return { validate: X, compare: Q };
  }
  Cz.fullFormats = { date: L1(bz, nY), time: L1(dY(true), rY), "date-time": L1(Rz(true), Sz), "iso-time": L1(dY(), Pz), "iso-date-time": L1(Rz(), Zz), duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/, uri: GI, "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/, ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, regex: LI, uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/, "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, byte: HI, int32: { type: "number", validate: KI }, int64: { type: "number", validate: UI }, float: { type: "number", validate: Ez }, double: { type: "number", validate: Ez }, password: true, binary: true };
  Cz.fastFormats = { ...Cz.fullFormats, date: L1(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, nY), time: L1(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, rY), "date-time": L1(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, Sz), "iso-time": L1(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, Pz), "iso-date-time": L1(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, Zz), uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i, "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i, email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i };
  Cz.formatNames = Object.keys(Cz.fullFormats);
  function QI(X) {
    return X % 4 === 0 && (X % 100 !== 0 || X % 400 === 0);
  }
  var $I = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, YI = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function bz(X) {
    let Q = $I.exec(X);
    if (!Q) return false;
    let $ = +Q[1], Y = +Q[2], W = +Q[3];
    return Y >= 1 && Y <= 12 && W >= 1 && W <= (Y === 2 && QI($) ? 29 : YI[Y]);
  }
  function nY(X, Q) {
    if (!(X && Q)) return;
    if (X > Q) return 1;
    if (X < Q) return -1;
    return 0;
  }
  var pY = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
  function dY(X) {
    return function($) {
      let Y = pY.exec($);
      if (!Y) return false;
      let W = +Y[1], J = +Y[2], G = +Y[3], H = Y[4], B = Y[5] === "-" ? -1 : 1, z = +(Y[6] || 0), K = +(Y[7] || 0);
      if (z > 23 || K > 59 || X && !H) return false;
      if (W <= 23 && J <= 59 && G < 60) return true;
      let V = J - K * B, L = W - z * B - (V < 0 ? 1 : 0);
      return (L === 23 || L === -1) && (V === 59 || V === -1) && G < 61;
    };
  }
  function rY(X, Q) {
    if (!(X && Q)) return;
    let $ = (/* @__PURE__ */ new Date("2020-01-01T" + X)).valueOf(), Y = (/* @__PURE__ */ new Date("2020-01-01T" + Q)).valueOf();
    if (!($ && Y)) return;
    return $ - Y;
  }
  function Pz(X, Q) {
    if (!(X && Q)) return;
    let $ = pY.exec(X), Y = pY.exec(Q);
    if (!($ && Y)) return;
    if (X = $[1] + $[2] + $[3], Q = Y[1] + Y[2] + Y[3], X > Q) return 1;
    if (X < Q) return -1;
    return 0;
  }
  var iY = /t|\s/i;
  function Rz(X) {
    let Q = dY(X);
    return function(Y) {
      let W = Y.split(iY);
      return W.length === 2 && bz(W[0]) && Q(W[1]);
    };
  }
  function Sz(X, Q) {
    if (!(X && Q)) return;
    let $ = new Date(X).valueOf(), Y = new Date(Q).valueOf();
    if (!($ && Y)) return;
    return $ - Y;
  }
  function Zz(X, Q) {
    if (!(X && Q)) return;
    let [$, Y] = X.split(iY), [W, J] = Q.split(iY), G = nY($, W);
    if (G === void 0) return;
    return G || rY(Y, J);
  }
  var WI = /\/|:/, JI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function GI(X) {
    return WI.test(X) && JI.test(X);
  }
  var Iz = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function HI(X) {
    return Iz.lastIndex = 0, Iz.test(X);
  }
  var BI = -2147483648, zI = 2147483647;
  function KI(X) {
    return Number.isInteger(X) && X <= zI && X >= BI;
  }
  function UI(X) {
    return Number.isInteger(X);
  }
  function Ez() {
    return true;
  }
  var VI = /[^\\]\\Z/;
  function LI(X) {
    if (VI.test(X)) return false;
    try {
      return new RegExp(X), true;
    } catch (Q) {
      return false;
    }
  }
});
var _z = P((Tz) => {
  Object.defineProperty(Tz, "__esModule", { value: true });
  Tz.formatLimitDefinition = void 0;
  var FI = cY(), Y1 = c(), n1 = Y1.operators, X9 = { formatMaximum: { okStr: "<=", ok: n1.LTE, fail: n1.GT }, formatMinimum: { okStr: ">=", ok: n1.GTE, fail: n1.LT }, formatExclusiveMaximum: { okStr: "<", ok: n1.LT, fail: n1.GTE }, formatExclusiveMinimum: { okStr: ">", ok: n1.GT, fail: n1.LTE } }, NI = { message: ({ keyword: X, schemaCode: Q }) => Y1.str`should be ${X9[X].okStr} ${Q}`, params: ({ keyword: X, schemaCode: Q }) => Y1._`{comparison: ${X9[X].okStr}, limit: ${Q}}` };
  Tz.formatLimitDefinition = { keyword: Object.keys(X9), type: "string", schemaType: "string", $data: true, error: NI, code(X) {
    let { gen: Q, data: $, schemaCode: Y, keyword: W, it: J } = X, { opts: G, self: H } = J;
    if (!G.validateFormats) return;
    let B = new FI.KeywordCxt(J, H.RULES.all.format.definition, "format");
    if (B.$data) z();
    else K();
    function z() {
      let L = Q.scopeValue("formats", { ref: H.formats, code: G.code.formats }), U = Q.const("fmt", Y1._`${L}[${B.schemaCode}]`);
      X.fail$data((0, Y1.or)(Y1._`typeof ${U} != "object"`, Y1._`${U} instanceof RegExp`, Y1._`typeof ${U}.compare != "function"`, V(U)));
    }
    function K() {
      let L = B.schema, U = H.formats[L];
      if (!U || U === true) return;
      if (typeof U != "object" || U instanceof RegExp || typeof U.compare != "function") throw Error(`"${W}": format "${L}" does not define "compare" function`);
      let F = Q.scopeValue("formats", { key: L, ref: U, code: G.code.formats ? Y1._`${G.code.formats}${(0, Y1.getProperty)(L)}` : void 0 });
      X.fail$data(V(F));
    }
    function V(L) {
      return Y1._`${L}.compare(${$}, ${Y}) ${X9[W].fail} 0`;
    }
  }, dependencies: ["format"] };
  var OI = (X) => {
    return X.addKeyword(Tz.formatLimitDefinition), X;
  };
  Tz.default = OI;
});
var fz = P((G4, gz) => {
  Object.defineProperty(G4, "__esModule", { value: true });
  var r6 = vz(), AI = _z(), aY = c(), xz = new aY.Name("fullFormats"), wI = new aY.Name("fastFormats"), sY = (X, Q = { keywords: true }) => {
    if (Array.isArray(Q)) return yz(X, Q, r6.fullFormats, xz), X;
    let [$, Y] = Q.mode === "fast" ? [r6.fastFormats, wI] : [r6.fullFormats, xz], W = Q.formats || r6.formatNames;
    if (yz(X, W, $, Y), Q.keywords) (0, AI.default)(X);
    return X;
  };
  sY.get = (X, Q = "full") => {
    let Y = (Q === "fast" ? r6.fastFormats : r6.fullFormats)[X];
    if (!Y) throw Error(`Unknown format "${X}"`);
    return Y;
  };
  function yz(X, Q, $, Y) {
    var W, J;
    (W = (J = X.opts.code).formats) !== null && W !== void 0 || (J.formats = aY._`require("ajv-formats/dist/formats").${Y}`);
    for (let G of Q) X.addFormat(G, $[G]);
  }
  gz.exports = G4 = sY;
  Object.defineProperty(G4, "__esModule", { value: true });
  G4.default = sY;
});
var zK = 50;
function N6(X = zK) {
  let Q = new AbortController();
  return (0, import_events.setMaxListeners)(X, Q.signal), Q;
}
var KK = typeof global == "object" && global && global.Object === Object && global;
var q7 = KK;
var UK = typeof self == "object" && self && self.Object === Object && self;
var VK = q7 || UK || Function("return this")();
var O6 = VK;
var LK = O6.Symbol;
var D6 = LK;
var F7 = Object.prototype;
var qK = F7.hasOwnProperty;
var FK = F7.toString;
var e6 = D6 ? D6.toStringTag : void 0;
function NK(X) {
  var Q = qK.call(X, e6), $ = X[e6];
  try {
    X[e6] = void 0;
    var Y = true;
  } catch (J) {
  }
  var W = FK.call(X);
  if (Y) if (Q) X[e6] = $;
  else delete X[e6];
  return W;
}
var N7 = NK;
var OK = Object.prototype;
var DK = OK.toString;
function AK(X) {
  return DK.call(X);
}
var O7 = AK;
var wK = "[object Null]";
var MK = "[object Undefined]";
var D7 = D6 ? D6.toStringTag : void 0;
function jK(X) {
  if (X == null) return X === void 0 ? MK : wK;
  return D7 && D7 in Object(X) ? N7(X) : O7(X);
}
var A7 = jK;
function RK(X) {
  var Q = typeof X;
  return X != null && (Q == "object" || Q == "function");
}
var z4 = RK;
var IK = "[object AsyncFunction]";
var EK = "[object Function]";
var bK = "[object GeneratorFunction]";
var PK = "[object Proxy]";
function SK(X) {
  if (!z4(X)) return false;
  var Q = A7(X);
  return Q == EK || Q == bK || Q == IK || Q == PK;
}
var w7 = SK;
var ZK = O6["__core-js_shared__"];
var K4 = ZK;
var M7 = function() {
  var X = /[^.]+$/.exec(K4 && K4.keys && K4.keys.IE_PROTO || "");
  return X ? "Symbol(src)_1." + X : "";
}();
function CK(X) {
  return !!M7 && M7 in X;
}
var j7 = CK;
var kK = Function.prototype;
var vK = kK.toString;
function TK(X) {
  if (X != null) {
    try {
      return vK.call(X);
    } catch (Q) {
    }
    try {
      return X + "";
    } catch (Q) {
    }
  }
  return "";
}
var R7 = TK;
var _K = /[\\^$.*+?()[\]{}|]/g;
var xK = /^\[object .+?Constructor\]$/;
var yK = Function.prototype;
var gK = Object.prototype;
var fK = yK.toString;
var hK = gK.hasOwnProperty;
var uK = RegExp("^" + fK.call(hK).replace(_K, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function lK(X) {
  if (!z4(X) || j7(X)) return false;
  var Q = w7(X) ? uK : xK;
  return Q.test(R7(X));
}
var I7 = lK;
function mK(X, Q) {
  return X == null ? void 0 : X[Q];
}
var E7 = mK;
function cK(X, Q) {
  var $ = E7(X, Q);
  return I7($) ? $ : void 0;
}
var U4 = cK;
var pK = U4(Object, "create");
var q1 = pK;
function dK() {
  this.__data__ = q1 ? q1(null) : {}, this.size = 0;
}
var b7 = dK;
function iK(X) {
  var Q = this.has(X) && delete this.__data__[X];
  return this.size -= Q ? 1 : 0, Q;
}
var P7 = iK;
var nK = "__lodash_hash_undefined__";
var rK = Object.prototype;
var oK = rK.hasOwnProperty;
function tK(X) {
  var Q = this.__data__;
  if (q1) {
    var $ = Q[X];
    return $ === nK ? void 0 : $;
  }
  return oK.call(Q, X) ? Q[X] : void 0;
}
var S7 = tK;
var aK = Object.prototype;
var sK = aK.hasOwnProperty;
function eK(X) {
  var Q = this.__data__;
  return q1 ? Q[X] !== void 0 : sK.call(Q, X);
}
var Z7 = eK;
var XU = "__lodash_hash_undefined__";
function QU(X, Q) {
  var $ = this.__data__;
  return this.size += this.has(X) ? 0 : 1, $[X] = q1 && Q === void 0 ? XU : Q, this;
}
var C7 = QU;
function A6(X) {
  var Q = -1, $ = X == null ? 0 : X.length;
  this.clear();
  while (++Q < $) {
    var Y = X[Q];
    this.set(Y[0], Y[1]);
  }
}
A6.prototype.clear = b7;
A6.prototype.delete = P7;
A6.prototype.get = S7;
A6.prototype.has = Z7;
A6.prototype.set = C7;
var W9 = A6;
function $U() {
  this.__data__ = [], this.size = 0;
}
var k7 = $U;
function YU(X, Q) {
  return X === Q || X !== X && Q !== Q;
}
var v7 = YU;
function WU(X, Q) {
  var $ = X.length;
  while ($--) if (v7(X[$][0], Q)) return $;
  return -1;
}
var Z1 = WU;
var JU = Array.prototype;
var GU = JU.splice;
function HU(X) {
  var Q = this.__data__, $ = Z1(Q, X);
  if ($ < 0) return false;
  var Y = Q.length - 1;
  if ($ == Y) Q.pop();
  else GU.call(Q, $, 1);
  return --this.size, true;
}
var T7 = HU;
function BU(X) {
  var Q = this.__data__, $ = Z1(Q, X);
  return $ < 0 ? void 0 : Q[$][1];
}
var _7 = BU;
function zU(X) {
  return Z1(this.__data__, X) > -1;
}
var x7 = zU;
function KU(X, Q) {
  var $ = this.__data__, Y = Z1($, X);
  if (Y < 0) ++this.size, $.push([X, Q]);
  else $[Y][1] = Q;
  return this;
}
var y7 = KU;
function w6(X) {
  var Q = -1, $ = X == null ? 0 : X.length;
  this.clear();
  while (++Q < $) {
    var Y = X[Q];
    this.set(Y[0], Y[1]);
  }
}
w6.prototype.clear = k7;
w6.prototype.delete = T7;
w6.prototype.get = _7;
w6.prototype.has = x7;
w6.prototype.set = y7;
var g7 = w6;
var UU = U4(O6, "Map");
var f7 = UU;
function VU() {
  this.size = 0, this.__data__ = { hash: new W9(), map: new (f7 || g7)(), string: new W9() };
}
var h7 = VU;
function LU(X) {
  var Q = typeof X;
  return Q == "string" || Q == "number" || Q == "symbol" || Q == "boolean" ? X !== "__proto__" : X === null;
}
var u7 = LU;
function qU(X, Q) {
  var $ = X.__data__;
  return u7(Q) ? $[typeof Q == "string" ? "string" : "hash"] : $.map;
}
var C1 = qU;
function FU(X) {
  var Q = C1(this, X).delete(X);
  return this.size -= Q ? 1 : 0, Q;
}
var l7 = FU;
function NU(X) {
  return C1(this, X).get(X);
}
var m7 = NU;
function OU(X) {
  return C1(this, X).has(X);
}
var c7 = OU;
function DU(X, Q) {
  var $ = C1(this, X), Y = $.size;
  return $.set(X, Q), this.size += $.size == Y ? 0 : 1, this;
}
var p7 = DU;
function M6(X) {
  var Q = -1, $ = X == null ? 0 : X.length;
  this.clear();
  while (++Q < $) {
    var Y = X[Q];
    this.set(Y[0], Y[1]);
  }
}
M6.prototype.clear = h7;
M6.prototype.delete = l7;
M6.prototype.get = m7;
M6.prototype.has = c7;
M6.prototype.set = p7;
var J9 = M6;
var AU = "Expected a function";
function G9(X, Q) {
  if (typeof X != "function" || Q != null && typeof Q != "function") throw TypeError(AU);
  var $ = function() {
    var Y = arguments, W = Q ? Q.apply(this, Y) : Y[0], J = $.cache;
    if (J.has(W)) return J.get(W);
    var G = X.apply(this, Y);
    return $.cache = J.set(W, G) || J, G;
  };
  return $.cache = new (G9.Cache || J9)(), $;
}
G9.Cache = J9;
var k1 = G9;
function wU(X, Q) {
  if (X.destroyed) return;
  X.write(Q);
}
function d7(X) {
  wU(process.stderr, X);
}
var i7 = k1((X) => {
  if (!X || X.trim() === "") return null;
  let Q = X.split(",").map((J) => J.trim()).filter(Boolean);
  if (Q.length === 0) return null;
  let $ = Q.some((J) => J.startsWith("!")), Y = Q.some((J) => !J.startsWith("!"));
  if ($ && Y) return null;
  let W = Q.map((J) => J.replace(/^!/, "").toLowerCase());
  return { include: $ ? [] : W, exclude: $ ? W : [], isExclusive: $ };
});
function MU(X) {
  let Q = [], $ = X.match(/^MCP server ["']([^"']+)["']/);
  if ($ && $[1]) Q.push("mcp"), Q.push($[1].toLowerCase());
  else {
    let J = X.match(/^([^:[]+):/);
    if (J && J[1]) Q.push(J[1].trim().toLowerCase());
  }
  let Y = X.match(/^\[([^\]]+)]/);
  if (Y && Y[1]) Q.push(Y[1].trim().toLowerCase());
  if (X.toLowerCase().includes("statsig event:")) Q.push("statsig");
  let W = X.match(/:\s*([^:]+?)(?:\s+(?:type|mode|status|event))?:/);
  if (W && W[1]) {
    let J = W[1].trim().toLowerCase();
    if (J.length < 30 && !J.includes(" ")) Q.push(J);
  }
  return Array.from(new Set(Q));
}
function jU(X, Q) {
  if (!Q) return true;
  if (X.length === 0) return false;
  if (Q.isExclusive) return !X.some(($) => Q.exclude.includes($));
  else return X.some(($) => Q.include.includes($));
}
function n7(X, Q) {
  if (!Q) return true;
  let $ = MU(X);
  return jU($, Q);
}
function V4() {
  return process.env.CLAUDE_CONFIG_DIR ?? (0, import_path2.join)((0, import_os.homedir)(), ".claude");
}
function H9(X) {
  if (!X) return false;
  if (typeof X === "boolean") return X;
  let Q = X.toLowerCase().trim();
  return ["1", "true", "yes", "on"].includes(Q);
}
function r7(X) {
  return { name: X, default: 3e4, validate: (Q) => {
    if (!Q) return { effective: 3e4, status: "valid" };
    let $ = parseInt(Q, 10);
    if (isNaN($) || $ <= 0) return { effective: 3e4, status: "invalid", message: `Invalid value "${Q}" (using default: 30000)` };
    if ($ > 15e4) return { effective: 15e4, status: "capped", message: `Capped from ${$} to 150000` };
    return { effective: $, status: "valid" };
  } };
}
var o7 = r7("BASH_MAX_OUTPUT_LENGTH");
var Ib = r7("TASK_MAX_OUTPUT_LENGTH");
var t7 = { name: "CLAUDE_CODE_MAX_OUTPUT_TOKENS", default: 32e3, validate: (X) => {
  if (!X) return { effective: 32e3, status: "valid" };
  let Y = parseInt(X, 10);
  if (isNaN(Y) || Y <= 0) return { effective: 32e3, status: "invalid", message: `Invalid value "${X}" (using default: 32000)` };
  if (Y > 64e3) return { effective: 64e3, status: "capped", message: `Capped from ${Y} to 64000` };
  return { effective: Y, status: "valid" };
} };
function PU() {
  let X = "";
  if (typeof process < "u" && typeof process.cwd === "function" && typeof import_fs.realpathSync === "function") X = (0, import_fs.realpathSync)((0, import_process.cwd)());
  return { originalCwd: X, projectRoot: X, totalCostUSD: 0, totalAPIDuration: 0, totalAPIDurationWithoutRetries: 0, totalToolDuration: 0, startTime: Date.now(), lastInteractionTime: Date.now(), totalLinesAdded: 0, totalLinesRemoved: 0, hasUnknownModelCost: false, cwd: X, modelUsage: {}, mainLoopModelOverride: void 0, initialMainLoopModel: null, modelStrings: null, isInteractive: false, clientType: "cli", sessionIngressToken: void 0, oauthTokenFromFd: void 0, apiKeyFromFd: void 0, flagSettingsPath: void 0, allowedSettingSources: ["userSettings", "projectSettings", "localSettings", "flagSettings", "policySettings"], meter: null, sessionCounter: null, locCounter: null, prCounter: null, commitCounter: null, costCounter: null, tokenCounter: null, codeEditToolDecisionCounter: null, activeTimeCounter: null, sessionId: (0, import_crypto.randomUUID)(), parentSessionId: void 0, loggerProvider: null, eventLogger: null, meterProvider: null, tracerProvider: null, agentColorMap: /* @__PURE__ */ new Map(), agentColorIndex: 0, envVarValidators: [o7, t7], lastAPIRequest: null, inMemoryErrorLog: [], inlinePlugins: [], useCoworkPlugins: false, sessionBypassPermissionsMode: false, sessionTrustAccepted: false, sessionPersistenceDisabled: false, hasExitedPlanMode: false, needsPlanModeExitAttachment: false, hasExitedDelegateMode: false, needsDelegateModeExitAttachment: false, lspRecommendationShownThisSession: false, initJsonSchema: null, registeredHooks: null, planSlugCache: /* @__PURE__ */ new Map(), teleportedSessionInfo: null, invokedSkills: /* @__PURE__ */ new Map(), slowOperations: [], promptCacheBreaks: [], sdkBetas: void 0, mainThreadAgentType: void 0, isRemoteMode: false, directConnectServerUrl: void 0, additionalDirectoriesForClaudeMd: [], resumedTranscriptPath: null };
}
var SU = PU();
function s7() {
  return SU.sessionId;
}
function e7({ writeFn: X, flushIntervalMs: Q = 1e3, maxBufferSize: $ = 100, immediateMode: Y = false }) {
  let W = [], J = null;
  function G() {
    if (J) clearTimeout(J), J = null;
  }
  function H() {
    if (W.length === 0) return;
    X(W.join("")), W = [], G();
  }
  function B() {
    if (!J) J = setTimeout(H, Q);
  }
  return { write(z) {
    if (Y) {
      X(z);
      return;
    }
    if (W.push(z), B(), W.length >= $) H();
  }, flush: H, dispose() {
    H();
  } };
}
var XW = /* @__PURE__ */ new Set();
function QW(X) {
  return XW.add(X), () => XW.delete(X);
}
var B9 = 1 / 0;
function ZU(X) {
  if (X === null) return "null";
  if (X === void 0) return "undefined";
  if (Array.isArray(X)) return `Array[${X.length}]`;
  if (typeof X === "object") return `Object{${Object.keys(X).length} keys}`;
  if (typeof X === "string") return `string(${X.length} chars)`;
  return typeof X;
}
function $W(X, Q) {
  let $ = performance.now();
  try {
    return Q();
  } finally {
    performance.now() - $ > B9;
  }
}
function Z0(X, Q, $) {
  let Y = ZU(X);
  return $W(`JSON.stringify(${Y})`, () => JSON.stringify(X, Q, $));
}
var L4 = (X, Q) => {
  let $ = typeof X === "string" ? X.length : 0;
  return $W(`JSON.parse(${$} chars)`, () => JSON.parse(X, Q));
};
var CU = k1(() => {
  return H9(process.env.DEBUG) || H9(process.env.DEBUG_SDK) || process.argv.includes("--debug") || process.argv.includes("-d") || WW() || process.argv.some((X) => X.startsWith("--debug=")) || JW() !== null;
});
var kU = k1(() => {
  let X = process.argv.find(($) => $.startsWith("--debug="));
  if (!X) return null;
  let Q = X.substring(8);
  return i7(Q);
});
var WW = k1(() => {
  return process.argv.includes("--debug-to-stderr") || process.argv.includes("-d2e");
});
var JW = k1(() => {
  for (let X = 0; X < process.argv.length; X++) {
    let Q = process.argv[X];
    if (Q.startsWith("--debug-file=")) return Q.substring(13);
    if (Q === "--debug-file" && X + 1 < process.argv.length) return process.argv[X + 1];
  }
  return null;
});
function vU(X) {
  if (typeof process > "u" || typeof process.versions > "u" || typeof process.versions.node > "u") return false;
  let Q = kU();
  return n7(X, Q);
}
var TU = false;
var q4 = null;
function _U() {
  if (!q4) q4 = e7({ writeFn: (X) => {
    let Q = GW();
    if (!n0().existsSync((0, import_path3.dirname)(Q))) n0().mkdirSync((0, import_path3.dirname)(Q));
    n0().appendFileSync(Q, X), xU();
  }, flushIntervalMs: 1e3, maxBufferSize: 100, immediateMode: CU() }), QW(async () => q4?.dispose());
  return q4;
}
function v1(X, { level: Q } = { level: "debug" }) {
  if (!vU(X)) return;
  if (TU && X.includes(`
`)) X = Z0(X);
  let Y = `${(/* @__PURE__ */ new Date()).toISOString()} [${Q.toUpperCase()}] ${X.trim()}
`;
  if (WW()) {
    d7(Y);
    return;
  }
  _U().write(Y);
}
function GW() {
  return JW() ?? process.env.CLAUDE_CODE_DEBUG_LOGS_DIR ?? (0, import_path3.join)(V4(), "debug", `${s7()}.txt`);
}
var xU = k1(() => {
  if (process.argv[2] === "--ripgrep") return;
  try {
    let X = GW(), Q = (0, import_path3.dirname)(X), $ = (0, import_path3.join)(Q, "latest");
    if (!n0().existsSync(Q)) n0().mkdirSync(Q);
    if (n0().existsSync($)) try {
      n0().unlinkSync($);
    } catch {
    }
    n0().symlinkSync(X, $);
  } catch {
  }
});
function F0(X, Q) {
  let $ = performance.now();
  try {
    return Q();
  } finally {
    performance.now() - $ > B9;
  }
}
var mU = { cwd() {
  return process.cwd();
}, existsSync(X) {
  return F0(`existsSync(${X})`, () => h.existsSync(X));
}, async stat(X) {
  return (0, import_promises.stat)(X);
}, async readdir(X) {
  return (0, import_promises.readdir)(X, { withFileTypes: true });
}, async unlink(X) {
  return (0, import_promises.unlink)(X);
}, async rmdir(X) {
  return (0, import_promises.rmdir)(X);
}, async rm(X, Q) {
  return (0, import_promises.rm)(X, Q);
}, statSync(X) {
  return F0(`statSync(${X})`, () => h.statSync(X));
}, lstatSync(X) {
  return F0(`lstatSync(${X})`, () => h.lstatSync(X));
}, readFileSync(X, Q) {
  return F0(`readFileSync(${X})`, () => h.readFileSync(X, { encoding: Q.encoding }));
}, readFileBytesSync(X) {
  return F0(`readFileBytesSync(${X})`, () => h.readFileSync(X));
}, readSync(X, Q) {
  return F0(`readSync(${X}, ${Q.length} bytes)`, () => {
    let $ = void 0;
    try {
      $ = h.openSync(X, "r");
      let Y = Buffer.alloc(Q.length), W = h.readSync($, Y, 0, Q.length, 0);
      return { buffer: Y, bytesRead: W };
    } finally {
      if ($) h.closeSync($);
    }
  });
}, appendFileSync(X, Q, $) {
  return F0(`appendFileSync(${X}, ${Q.length} chars)`, () => {
    if (!h.existsSync(X) && $?.mode !== void 0) {
      let Y = h.openSync(X, "a", $.mode);
      try {
        h.appendFileSync(Y, Q);
      } finally {
        h.closeSync(Y);
      }
    } else h.appendFileSync(X, Q);
  });
}, copyFileSync(X, Q) {
  return F0(`copyFileSync(${X} \u2192 ${Q})`, () => h.copyFileSync(X, Q));
}, unlinkSync(X) {
  return F0(`unlinkSync(${X})`, () => h.unlinkSync(X));
}, renameSync(X, Q) {
  return F0(`renameSync(${X} \u2192 ${Q})`, () => h.renameSync(X, Q));
}, linkSync(X, Q) {
  return F0(`linkSync(${X} \u2192 ${Q})`, () => h.linkSync(X, Q));
}, symlinkSync(X, Q) {
  return F0(`symlinkSync(${X} \u2192 ${Q})`, () => h.symlinkSync(X, Q));
}, readlinkSync(X) {
  return F0(`readlinkSync(${X})`, () => h.readlinkSync(X));
}, realpathSync(X) {
  return F0(`realpathSync(${X})`, () => h.realpathSync(X));
}, mkdirSync(X, Q) {
  return F0(`mkdirSync(${X})`, () => {
    if (!h.existsSync(X)) {
      let $ = { recursive: true };
      if (Q?.mode !== void 0) $.mode = Q.mode;
      h.mkdirSync(X, $);
    }
  });
}, readdirSync(X) {
  return F0(`readdirSync(${X})`, () => h.readdirSync(X, { withFileTypes: true }));
}, readdirStringSync(X) {
  return F0(`readdirStringSync(${X})`, () => h.readdirSync(X));
}, isDirEmptySync(X) {
  return F0(`isDirEmptySync(${X})`, () => {
    return this.readdirSync(X).length === 0;
  });
}, rmdirSync(X) {
  return F0(`rmdirSync(${X})`, () => h.rmdirSync(X));
}, rmSync(X, Q) {
  return F0(`rmSync(${X})`, () => h.rmSync(X, Q));
}, createWriteStream(X) {
  return h.createWriteStream(X);
} };
var cU = mU;
function n0() {
  return cU;
}
var F1 = class extends Error {
};
function j6() {
  return process.versions.bun !== void 0;
}
var F4 = null;
var BW = false;
function tU() {
  if (BW) return F4;
  if (BW = true, !process.env.DEBUG_CLAUDE_AGENT_SDK) return null;
  let X = (0, import_path4.join)(V4(), "debug");
  if (F4 = (0, import_path4.join)(X, `sdk-${(0, import_crypto2.randomUUID)()}.txt`), !(0, import_fs2.existsSync)(X)) (0, import_fs2.mkdirSync)(X, { recursive: true });
  return process.stderr.write(`SDK debug logs: ${F4}
`), F4;
}
function N1(X) {
  let Q = tU();
  if (!Q) return;
  let Y = `${(/* @__PURE__ */ new Date()).toISOString()} ${X}
`;
  (0, import_fs2.appendFileSync)(Q, Y);
}
function zW(X, Q) {
  let $ = { ...X };
  if (Q) {
    let Y = { sandbox: Q };
    if ($.settings) try {
      Y = { ...L4($.settings), sandbox: Q };
    } catch {
    }
    $.settings = Z0(Y);
  }
  return $;
}
var XX = class {
  options;
  process;
  processStdin;
  processStdout;
  ready = false;
  abortController;
  exitError;
  exitListeners = [];
  processExitHandler;
  abortHandler;
  constructor(X) {
    this.options = X;
    this.abortController = X.abortController || N6(), this.initialize();
  }
  getDefaultExecutable() {
    return j6() ? "bun" : "node";
  }
  spawnLocalProcess(X) {
    let { command: Q, args: $, cwd: Y, env: W, signal: J } = X, G = W.DEBUG_CLAUDE_AGENT_SDK || this.options.stderr ? "pipe" : "ignore", H = (0, import_child_process.spawn)(Q, $, { cwd: Y, stdio: ["pipe", "pipe", G], signal: J, env: W, windowsHide: true });
    if (W.DEBUG_CLAUDE_AGENT_SDK || this.options.stderr) H.stderr.on("data", (z) => {
      let K = z.toString();
      if (N1(K), this.options.stderr) this.options.stderr(K);
    });
    return { stdin: H.stdin, stdout: H.stdout, get killed() {
      return H.killed;
    }, get exitCode() {
      return H.exitCode;
    }, kill: H.kill.bind(H), on: H.on.bind(H), once: H.once.bind(H), off: H.off.bind(H) };
  }
  initialize() {
    try {
      let { additionalDirectories: X = [], agent: Q, betas: $, cwd: Y, executable: W = this.getDefaultExecutable(), executableArgs: J = [], extraArgs: G = {}, pathToClaudeCodeExecutable: H, env: B = { ...process.env }, maxThinkingTokens: z, maxTurns: K, maxBudgetUsd: V, model: L, fallbackModel: U, jsonSchema: F, permissionMode: q, allowDangerouslySkipPermissions: N, permissionPromptToolName: A, continueConversation: M, resume: R, settingSources: S, allowedTools: C = [], disallowedTools: K0 = [], tools: U0, mcpServers: s, strictMcpConfig: D0, canUseTool: q0, includePartialMessages: W1, plugins: P1, sandbox: U6 } = this.options, d = ["--output-format", "stream-json", "--verbose", "--input-format", "stream-json"];
      if (z !== void 0) d.push("--max-thinking-tokens", z.toString());
      if (K) d.push("--max-turns", K.toString());
      if (V !== void 0) d.push("--max-budget-usd", V.toString());
      if (L) d.push("--model", L);
      if (Q) d.push("--agent", Q);
      if ($ && $.length > 0) d.push("--betas", $.join(","));
      if (F) d.push("--json-schema", Z0(F));
      if (B.DEBUG_CLAUDE_AGENT_SDK) d.push("--debug-to-stderr");
      if (q0) {
        if (A) throw Error("canUseTool callback cannot be used with permissionPromptToolName. Please use one or the other.");
        d.push("--permission-prompt-tool", "stdio");
      } else if (A) d.push("--permission-prompt-tool", A);
      if (M) d.push("--continue");
      if (R) d.push("--resume", R);
      if (C.length > 0) d.push("--allowedTools", C.join(","));
      if (K0.length > 0) d.push("--disallowedTools", K0.join(","));
      if (U0 !== void 0) if (Array.isArray(U0)) if (U0.length === 0) d.push("--tools", "");
      else d.push("--tools", U0.join(","));
      else d.push("--tools", "default");
      if (s && Object.keys(s).length > 0) d.push("--mcp-config", Z0({ mcpServers: s }));
      if (S) d.push("--setting-sources", S.join(","));
      if (D0) d.push("--strict-mcp-config");
      if (q) d.push("--permission-mode", q);
      if (N) d.push("--allow-dangerously-skip-permissions");
      if (U) {
        if (L && U === L) throw Error("Fallback model cannot be the same as the main model. Please specify a different model for fallbackModel option.");
        d.push("--fallback-model", U);
      }
      if (W1) d.push("--include-partial-messages");
      for (let S0 of X) d.push("--add-dir", S0);
      if (P1 && P1.length > 0) for (let S0 of P1) if (S0.type === "local") d.push("--plugin-dir", S0.path);
      else throw Error(`Unsupported plugin type: ${S0.type}`);
      if (this.options.forkSession) d.push("--fork-session");
      if (this.options.resumeSessionAt) d.push("--resume-session-at", this.options.resumeSessionAt);
      if (this.options.persistSession === false) d.push("--no-session-persistence");
      let Q9 = zW(G ?? {}, U6);
      for (let [S0, S1] of Object.entries(Q9)) if (S1 === null) d.push(`--${S0}`);
      else d.push(`--${S0}`, S1);
      if (!B.CLAUDE_CODE_ENTRYPOINT) B.CLAUDE_CODE_ENTRYPOINT = "sdk-ts";
      if (delete B.NODE_OPTIONS, B.DEBUG_CLAUDE_AGENT_SDK) B.DEBUG = "1";
      else delete B.DEBUG;
      let o6 = eU(H), V6 = o6 ? H : W, t6 = o6 ? [...J, ...d] : [...J, H, ...d], a6 = { command: V6, args: t6, cwd: Y, env: B, signal: this.abortController.signal };
      if (this.options.spawnClaudeCodeProcess) N1(`Spawning Claude Code (custom): ${V6} ${t6.join(" ")}`), this.process = this.options.spawnClaudeCodeProcess(a6);
      else {
        if (!n0().existsSync(H)) {
          let S1 = o6 ? `Claude Code native binary not found at ${H}. Please ensure Claude Code is installed via native installer or specify a valid path with options.pathToClaudeCodeExecutable.` : `Claude Code executable not found at ${H}. Is options.pathToClaudeCodeExecutable set?`;
          throw ReferenceError(S1);
        }
        N1(`Spawning Claude Code: ${V6} ${t6.join(" ")}`), this.process = this.spawnLocalProcess(a6);
      }
      this.processStdin = this.process.stdin, this.processStdout = this.process.stdout;
      let B4 = () => {
        if (this.process && !this.process.killed) this.process.kill("SIGTERM");
      };
      this.processExitHandler = B4, this.abortHandler = B4, process.on("exit", this.processExitHandler), this.abortController.signal.addEventListener("abort", this.abortHandler), this.process.on("error", (S0) => {
        if (this.ready = false, this.abortController.signal.aborted) this.exitError = new F1("Claude Code process aborted by user");
        else this.exitError = Error(`Failed to spawn Claude Code process: ${S0.message}`), N1(this.exitError.message);
      }), this.process.on("exit", (S0, S1) => {
        if (this.ready = false, this.abortController.signal.aborted) this.exitError = new F1("Claude Code process aborted by user");
        else {
          let s6 = this.getProcessExitError(S0, S1);
          if (s6) this.exitError = s6, N1(s6.message);
        }
      }), this.ready = true;
    } catch (X) {
      throw this.ready = false, X;
    }
  }
  getProcessExitError(X, Q) {
    if (X !== 0 && X !== null) return Error(`Claude Code process exited with code ${X}`);
    else if (Q) return Error(`Claude Code process terminated by signal ${Q}`);
    return;
  }
  write(X) {
    if (this.abortController.signal.aborted) throw new F1("Operation aborted");
    if (!this.ready || !this.processStdin) throw Error("ProcessTransport is not ready for writing");
    if (this.process?.killed || this.process?.exitCode !== null) throw Error("Cannot write to terminated process");
    if (this.exitError) throw Error(`Cannot write to process that exited with error: ${this.exitError.message}`);
    N1(`[ProcessTransport] Writing to stdin: ${X.substring(0, 100)}`);
    try {
      if (!this.processStdin.write(X)) N1("[ProcessTransport] Write buffer full, data queued");
    } catch (Q) {
      throw this.ready = false, Error(`Failed to write to process stdin: ${Q.message}`);
    }
  }
  close() {
    if (this.processStdin) this.processStdin.end(), this.processStdin = void 0;
    if (this.abortHandler) this.abortController.signal.removeEventListener("abort", this.abortHandler), this.abortHandler = void 0;
    for (let { handler: X } of this.exitListeners) this.process?.off("exit", X);
    if (this.exitListeners = [], this.process && !this.process.killed) this.process.kill("SIGTERM"), setTimeout(() => {
      if (this.process && !this.process.killed) this.process.kill("SIGKILL");
    }, 5e3);
    if (this.ready = false, this.processExitHandler) process.off("exit", this.processExitHandler), this.processExitHandler = void 0;
  }
  isReady() {
    return this.ready;
  }
  async *readMessages() {
    if (!this.processStdout) throw Error("ProcessTransport output stream not available");
    let X = (0, import_readline.createInterface)({ input: this.processStdout });
    try {
      for await (let Q of X) if (Q.trim()) try {
        yield L4(Q);
      } catch ($) {
        throw N1(`Non-JSON stdout: ${Q}`), Error(`CLI output was not valid JSON. This may indicate an error during startup. Output: ${Q.slice(0, 200)}${Q.length > 200 ? "..." : ""}`);
      }
      await this.waitForExit();
    } catch (Q) {
      throw Q;
    } finally {
      X.close();
    }
  }
  endInput() {
    if (this.processStdin) this.processStdin.end();
  }
  getInputStream() {
    return this.processStdin;
  }
  onExit(X) {
    if (!this.process) return () => {
    };
    let Q = ($, Y) => {
      let W = this.getProcessExitError($, Y);
      X(W);
    };
    return this.process.on("exit", Q), this.exitListeners.push({ callback: X, handler: Q }), () => {
      if (this.process) this.process.off("exit", Q);
      let $ = this.exitListeners.findIndex((Y) => Y.handler === Q);
      if ($ !== -1) this.exitListeners.splice($, 1);
    };
  }
  async waitForExit() {
    if (!this.process) {
      if (this.exitError) throw this.exitError;
      return;
    }
    if (this.process.exitCode !== null || this.process.killed) {
      if (this.exitError) throw this.exitError;
      return;
    }
    return new Promise((X, Q) => {
      let $ = (W, J) => {
        if (this.abortController.signal.aborted) {
          Q(new F1("Operation aborted"));
          return;
        }
        let G = this.getProcessExitError(W, J);
        if (G) Q(G);
        else X();
      };
      this.process.once("exit", $);
      let Y = (W) => {
        this.process.off("exit", $), Q(W);
      };
      this.process.once("error", Y), this.process.once("exit", () => {
        this.process.off("error", Y);
      });
    });
  }
};
function eU(X) {
  return ![".js", ".mjs", ".tsx", ".ts", ".jsx"].some(($) => X.endsWith($));
}
var QX = class {
  returned;
  queue = [];
  readResolve;
  readReject;
  isDone = false;
  hasError;
  started = false;
  constructor(X) {
    this.returned = X;
  }
  [Symbol.asyncIterator]() {
    if (this.started) throw Error("Stream can only be iterated once");
    return this.started = true, this;
  }
  next() {
    if (this.queue.length > 0) return Promise.resolve({ done: false, value: this.queue.shift() });
    if (this.isDone) return Promise.resolve({ done: true, value: void 0 });
    if (this.hasError) return Promise.reject(this.hasError);
    return new Promise((X, Q) => {
      this.readResolve = X, this.readReject = Q;
    });
  }
  enqueue(X) {
    if (this.readResolve) {
      let Q = this.readResolve;
      this.readResolve = void 0, this.readReject = void 0, Q({ done: false, value: X });
    } else this.queue.push(X);
  }
  done() {
    if (this.isDone = true, this.readResolve) {
      let X = this.readResolve;
      this.readResolve = void 0, this.readReject = void 0, X({ done: true, value: void 0 });
    }
  }
  error(X) {
    if (this.hasError = X, this.readReject) {
      let Q = this.readReject;
      this.readResolve = void 0, this.readReject = void 0, Q(X);
    }
  }
  return() {
    if (this.isDone = true, this.returned) this.returned();
    return Promise.resolve({ done: true, value: void 0 });
  }
};
var K9 = class {
  sendMcpMessage;
  isClosed = false;
  constructor(X) {
    this.sendMcpMessage = X;
  }
  onclose;
  onerror;
  onmessage;
  async start() {
  }
  async send(X) {
    if (this.isClosed) throw Error("Transport is closed");
    this.sendMcpMessage(X);
  }
  async close() {
    if (this.isClosed) return;
    this.isClosed = true, this.onclose?.();
  }
};
var $X = class {
  transport;
  isSingleUserTurn;
  canUseTool;
  hooks;
  abortController;
  jsonSchema;
  initConfig;
  pendingControlResponses = /* @__PURE__ */ new Map();
  cleanupPerformed = false;
  sdkMessages;
  inputStream = new QX();
  initialization;
  cancelControllers = /* @__PURE__ */ new Map();
  hookCallbacks = /* @__PURE__ */ new Map();
  nextCallbackId = 0;
  sdkMcpTransports = /* @__PURE__ */ new Map();
  sdkMcpServerInstances = /* @__PURE__ */ new Map();
  pendingMcpResponses = /* @__PURE__ */ new Map();
  firstResultReceivedResolve;
  firstResultReceived = false;
  hasBidirectionalNeeds() {
    return this.sdkMcpTransports.size > 0 || this.hooks !== void 0 && Object.keys(this.hooks).length > 0 || this.canUseTool !== void 0;
  }
  constructor(X, Q, $, Y, W, J = /* @__PURE__ */ new Map(), G, H) {
    this.transport = X;
    this.isSingleUserTurn = Q;
    this.canUseTool = $;
    this.hooks = Y;
    this.abortController = W;
    this.jsonSchema = G;
    this.initConfig = H;
    for (let [B, z] of J) this.connectSdkMcpServer(B, z);
    this.sdkMessages = this.readSdkMessages(), this.readMessages(), this.initialization = this.initialize(), this.initialization.catch(() => {
    });
  }
  setError(X) {
    this.inputStream.error(X);
  }
  close() {
    this.cleanup();
  }
  cleanup(X) {
    if (this.cleanupPerformed) return;
    this.cleanupPerformed = true;
    try {
      this.transport.close(), this.pendingControlResponses.clear(), this.pendingMcpResponses.clear(), this.cancelControllers.clear(), this.hookCallbacks.clear();
      for (let Q of this.sdkMcpTransports.values()) try {
        Q.close();
      } catch {
      }
      if (this.sdkMcpTransports.clear(), X) this.inputStream.error(X);
      else this.inputStream.done();
    } catch (Q) {
    }
  }
  next(...[X]) {
    return this.sdkMessages.next(...[X]);
  }
  return(X) {
    return this.sdkMessages.return(X);
  }
  throw(X) {
    return this.sdkMessages.throw(X);
  }
  [Symbol.asyncIterator]() {
    return this.sdkMessages;
  }
  [Symbol.asyncDispose]() {
    return this.sdkMessages[Symbol.asyncDispose]();
  }
  async readMessages() {
    try {
      for await (let X of this.transport.readMessages()) {
        if (X.type === "control_response") {
          let Q = this.pendingControlResponses.get(X.response.request_id);
          if (Q) Q(X.response);
          continue;
        } else if (X.type === "control_request") {
          this.handleControlRequest(X);
          continue;
        } else if (X.type === "control_cancel_request") {
          this.handleControlCancelRequest(X);
          continue;
        } else if (X.type === "keep_alive") continue;
        if (X.type === "result") {
          if (this.firstResultReceived = true, this.firstResultReceivedResolve) this.firstResultReceivedResolve();
          if (this.isSingleUserTurn) v1("[Query.readMessages] First result received for single-turn query, closing stdin"), this.transport.endInput();
        }
        this.inputStream.enqueue(X);
      }
      if (this.firstResultReceivedResolve) this.firstResultReceivedResolve();
      this.inputStream.done(), this.cleanup();
    } catch (X) {
      if (this.firstResultReceivedResolve) this.firstResultReceivedResolve();
      this.inputStream.error(X), this.cleanup(X);
    }
  }
  async handleControlRequest(X) {
    let Q = new AbortController();
    this.cancelControllers.set(X.request_id, Q);
    try {
      let $ = await this.processControlRequest(X, Q.signal), Y = { type: "control_response", response: { subtype: "success", request_id: X.request_id, response: $ } };
      await Promise.resolve(this.transport.write(Z0(Y) + `
`));
    } catch ($) {
      let Y = { type: "control_response", response: { subtype: "error", request_id: X.request_id, error: $.message || String($) } };
      await Promise.resolve(this.transport.write(Z0(Y) + `
`));
    } finally {
      this.cancelControllers.delete(X.request_id);
    }
  }
  handleControlCancelRequest(X) {
    let Q = this.cancelControllers.get(X.request_id);
    if (Q) Q.abort(), this.cancelControllers.delete(X.request_id);
  }
  async processControlRequest(X, Q) {
    if (X.request.subtype === "can_use_tool") {
      if (!this.canUseTool) throw Error("canUseTool callback is not provided.");
      return { ...await this.canUseTool(X.request.tool_name, X.request.input, { signal: Q, suggestions: X.request.permission_suggestions, blockedPath: X.request.blocked_path, decisionReason: X.request.decision_reason, toolUseID: X.request.tool_use_id, agentID: X.request.agent_id }), toolUseID: X.request.tool_use_id };
    } else if (X.request.subtype === "hook_callback") return await this.handleHookCallbacks(X.request.callback_id, X.request.input, X.request.tool_use_id, Q);
    else if (X.request.subtype === "mcp_message") {
      let $ = X.request, Y = this.sdkMcpTransports.get($.server_name);
      if (!Y) throw Error(`SDK MCP server not found: ${$.server_name}`);
      if ("method" in $.message && "id" in $.message && $.message.id !== null) return { mcp_response: await this.handleMcpControlRequest($.server_name, $, Y) };
      else {
        if (Y.onmessage) Y.onmessage($.message);
        return { mcp_response: { jsonrpc: "2.0", result: {}, id: 0 } };
      }
    }
    throw Error("Unsupported control request subtype: " + X.request.subtype);
  }
  async *readSdkMessages() {
    for await (let X of this.inputStream) yield X;
  }
  async initialize() {
    let X;
    if (this.hooks) {
      X = {};
      for (let [W, J] of Object.entries(this.hooks)) if (J.length > 0) X[W] = J.map((G) => {
        let H = [];
        for (let B of G.hooks) {
          let z = `hook_${this.nextCallbackId++}`;
          this.hookCallbacks.set(z, B), H.push(z);
        }
        return { matcher: G.matcher, hookCallbackIds: H, timeout: G.timeout };
      });
    }
    let Q = this.sdkMcpTransports.size > 0 ? Array.from(this.sdkMcpTransports.keys()) : void 0, $ = { subtype: "initialize", hooks: X, sdkMcpServers: Q, jsonSchema: this.jsonSchema, systemPrompt: this.initConfig?.systemPrompt, appendSystemPrompt: this.initConfig?.appendSystemPrompt, agents: this.initConfig?.agents };
    return (await this.request($)).response;
  }
  async interrupt() {
    await this.request({ subtype: "interrupt" });
  }
  async setPermissionMode(X) {
    await this.request({ subtype: "set_permission_mode", mode: X });
  }
  async setModel(X) {
    await this.request({ subtype: "set_model", model: X });
  }
  async setMaxThinkingTokens(X) {
    await this.request({ subtype: "set_max_thinking_tokens", max_thinking_tokens: X });
  }
  async rewindFiles(X, Q) {
    return (await this.request({ subtype: "rewind_files", user_message_id: X, dry_run: Q?.dryRun })).response;
  }
  async processPendingPermissionRequests(X) {
    for (let Q of X) if (Q.request.subtype === "can_use_tool") this.handleControlRequest(Q).catch(() => {
    });
  }
  request(X) {
    let Q = Math.random().toString(36).substring(2, 15), $ = { request_id: Q, type: "control_request", request: X };
    return new Promise((Y, W) => {
      this.pendingControlResponses.set(Q, (J) => {
        if (J.subtype === "success") Y(J);
        else if (W(Error(J.error)), J.pending_permission_requests) this.processPendingPermissionRequests(J.pending_permission_requests);
      }), Promise.resolve(this.transport.write(Z0($) + `
`));
    });
  }
  async supportedCommands() {
    return (await this.initialization).commands;
  }
  async supportedModels() {
    return (await this.initialization).models;
  }
  async reconnectMcpServer(X) {
    await this.request({ subtype: "mcp_reconnect", serverName: X });
  }
  async toggleMcpServer(X, Q) {
    await this.request({ subtype: "mcp_toggle", serverName: X, enabled: Q });
  }
  async mcpServerStatus() {
    return (await this.request({ subtype: "mcp_status" })).response.mcpServers;
  }
  async setMcpServers(X) {
    let Q = {}, $ = {};
    for (let [H, B] of Object.entries(X)) if (B.type === "sdk" && "instance" in B) Q[H] = B.instance;
    else $[H] = B;
    let Y = new Set(this.sdkMcpServerInstances.keys()), W = new Set(Object.keys(Q));
    for (let H of Y) if (!W.has(H)) await this.disconnectSdkMcpServer(H);
    for (let [H, B] of Object.entries(Q)) if (!Y.has(H)) this.connectSdkMcpServer(H, B);
    let J = {};
    for (let H of Object.keys(Q)) J[H] = { type: "sdk", name: H };
    return (await this.request({ subtype: "mcp_set_servers", servers: { ...$, ...J } })).response;
  }
  async accountInfo() {
    return (await this.initialization).account;
  }
  async streamInput(X) {
    v1("[Query.streamInput] Starting to process input stream");
    try {
      let Q = 0;
      for await (let $ of X) {
        if (Q++, v1(`[Query.streamInput] Processing message ${Q}: ${$.type}`), this.abortController?.signal.aborted) break;
        await Promise.resolve(this.transport.write(Z0($) + `
`));
      }
      if (v1(`[Query.streamInput] Finished processing ${Q} messages from input stream`), Q > 0 && this.hasBidirectionalNeeds()) v1("[Query.streamInput] Has bidirectional needs, waiting for first result"), await this.waitForFirstResult();
      v1("[Query] Calling transport.endInput() to close stdin to CLI process"), this.transport.endInput();
    } catch (Q) {
      if (!(Q instanceof F1)) throw Q;
    }
  }
  waitForFirstResult() {
    if (this.firstResultReceived) return v1("[Query.waitForFirstResult] Result already received, returning immediately"), Promise.resolve();
    return new Promise((X) => {
      if (this.abortController?.signal.aborted) {
        X();
        return;
      }
      this.abortController?.signal.addEventListener("abort", () => X(), { once: true }), this.firstResultReceivedResolve = X;
    });
  }
  handleHookCallbacks(X, Q, $, Y) {
    let W = this.hookCallbacks.get(X);
    if (!W) throw Error(`No hook callback found for ID: ${X}`);
    return W(Q, $, { signal: Y });
  }
  connectSdkMcpServer(X, Q) {
    let $ = new K9((Y) => this.sendMcpServerMessageToCli(X, Y));
    this.sdkMcpTransports.set(X, $), this.sdkMcpServerInstances.set(X, Q), Q.connect($);
  }
  async disconnectSdkMcpServer(X) {
    let Q = this.sdkMcpTransports.get(X);
    if (Q) await Q.close(), this.sdkMcpTransports.delete(X);
    this.sdkMcpServerInstances.delete(X);
  }
  sendMcpServerMessageToCli(X, Q) {
    if ("id" in Q && Q.id !== null && Q.id !== void 0) {
      let Y = `${X}:${Q.id}`, W = this.pendingMcpResponses.get(Y);
      if (W) {
        W.resolve(Q), this.pendingMcpResponses.delete(Y);
        return;
      }
    }
    let $ = { type: "control_request", request_id: (0, import_crypto3.randomUUID)(), request: { subtype: "mcp_message", server_name: X, message: Q } };
    this.transport.write(Z0($) + `
`);
  }
  handleMcpControlRequest(X, Q, $) {
    let Y = "id" in Q.message ? Q.message.id : null, W = `${X}:${Y}`;
    return new Promise((J, G) => {
      let H = () => {
        this.pendingMcpResponses.delete(W);
      }, B = (K) => {
        H(), J(K);
      }, z = (K) => {
        H(), G(K);
      };
      if (this.pendingMcpResponses.set(W, { resolve: B, reject: z }), $.onmessage) $.onmessage(Q.message);
      else {
        H(), G(Error("No message handler registered"));
        return;
      }
    });
  }
};
var n;
(function(X) {
  X.assertEqual = (W) => {
  };
  function Q(W) {
  }
  X.assertIs = Q;
  function $(W) {
    throw Error();
  }
  X.assertNever = $, X.arrayToEnum = (W) => {
    let J = {};
    for (let G of W) J[G] = G;
    return J;
  }, X.getValidEnumValues = (W) => {
    let J = X.objectKeys(W).filter((H) => typeof W[W[H]] !== "number"), G = {};
    for (let H of J) G[H] = W[H];
    return X.objectValues(G);
  }, X.objectValues = (W) => {
    return X.objectKeys(W).map(function(J) {
      return W[J];
    });
  }, X.objectKeys = typeof Object.keys === "function" ? (W) => Object.keys(W) : (W) => {
    let J = [];
    for (let G in W) if (Object.prototype.hasOwnProperty.call(W, G)) J.push(G);
    return J;
  }, X.find = (W, J) => {
    for (let G of W) if (J(G)) return G;
    return;
  }, X.isInteger = typeof Number.isInteger === "function" ? (W) => Number.isInteger(W) : (W) => typeof W === "number" && Number.isFinite(W) && Math.floor(W) === W;
  function Y(W, J = " | ") {
    return W.map((G) => typeof G === "string" ? `'${G}'` : G).join(J);
  }
  X.joinValues = Y, X.jsonStringifyReplacer = (W, J) => {
    if (typeof J === "bigint") return J.toString();
    return J;
  };
})(n || (n = {}));
var VW;
(function(X) {
  X.mergeShapes = (Q, $) => {
    return { ...Q, ...$ };
  };
})(VW || (VW = {}));
var I = n.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]);
var O1 = (X) => {
  switch (typeof X) {
    case "undefined":
      return I.undefined;
    case "string":
      return I.string;
    case "number":
      return Number.isNaN(X) ? I.nan : I.number;
    case "boolean":
      return I.boolean;
    case "function":
      return I.function;
    case "bigint":
      return I.bigint;
    case "symbol":
      return I.symbol;
    case "object":
      if (Array.isArray(X)) return I.array;
      if (X === null) return I.null;
      if (X.then && typeof X.then === "function" && X.catch && typeof X.catch === "function") return I.promise;
      if (typeof Map < "u" && X instanceof Map) return I.map;
      if (typeof Set < "u" && X instanceof Set) return I.set;
      if (typeof Date < "u" && X instanceof Date) return I.date;
      return I.object;
    default:
      return I.unknown;
  }
};
var w = n.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
var h0 = class _h0 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(X) {
    super();
    this.issues = [], this.addIssue = ($) => {
      this.issues = [...this.issues, $];
    }, this.addIssues = ($ = []) => {
      this.issues = [...this.issues, ...$];
    };
    let Q = new.target.prototype;
    if (Object.setPrototypeOf) Object.setPrototypeOf(this, Q);
    else this.__proto__ = Q;
    this.name = "ZodError", this.issues = X;
  }
  format(X) {
    let Q = X || function(W) {
      return W.message;
    }, $ = { _errors: [] }, Y = (W) => {
      for (let J of W.issues) if (J.code === "invalid_union") J.unionErrors.map(Y);
      else if (J.code === "invalid_return_type") Y(J.returnTypeError);
      else if (J.code === "invalid_arguments") Y(J.argumentsError);
      else if (J.path.length === 0) $._errors.push(Q(J));
      else {
        let G = $, H = 0;
        while (H < J.path.length) {
          let B = J.path[H];
          if (H !== J.path.length - 1) G[B] = G[B] || { _errors: [] };
          else G[B] = G[B] || { _errors: [] }, G[B]._errors.push(Q(J));
          G = G[B], H++;
        }
      }
    };
    return Y(this), $;
  }
  static assert(X) {
    if (!(X instanceof _h0)) throw Error(`Not a ZodError: ${X}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, n.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(X = (Q) => Q.message) {
    let Q = {}, $ = [];
    for (let Y of this.issues) if (Y.path.length > 0) {
      let W = Y.path[0];
      Q[W] = Q[W] || [], Q[W].push(X(Y));
    } else $.push(X(Y));
    return { formErrors: $, fieldErrors: Q };
  }
  get formErrors() {
    return this.flatten();
  }
};
h0.create = (X) => {
  return new h0(X);
};
var $V = (X, Q) => {
  let $;
  switch (X.code) {
    case w.invalid_type:
      if (X.received === I.undefined) $ = "Required";
      else $ = `Expected ${X.expected}, received ${X.received}`;
      break;
    case w.invalid_literal:
      $ = `Invalid literal value, expected ${JSON.stringify(X.expected, n.jsonStringifyReplacer)}`;
      break;
    case w.unrecognized_keys:
      $ = `Unrecognized key(s) in object: ${n.joinValues(X.keys, ", ")}`;
      break;
    case w.invalid_union:
      $ = "Invalid input";
      break;
    case w.invalid_union_discriminator:
      $ = `Invalid discriminator value. Expected ${n.joinValues(X.options)}`;
      break;
    case w.invalid_enum_value:
      $ = `Invalid enum value. Expected ${n.joinValues(X.options)}, received '${X.received}'`;
      break;
    case w.invalid_arguments:
      $ = "Invalid function arguments";
      break;
    case w.invalid_return_type:
      $ = "Invalid function return type";
      break;
    case w.invalid_date:
      $ = "Invalid date";
      break;
    case w.invalid_string:
      if (typeof X.validation === "object") if ("includes" in X.validation) {
        if ($ = `Invalid input: must include "${X.validation.includes}"`, typeof X.validation.position === "number") $ = `${$} at one or more positions greater than or equal to ${X.validation.position}`;
      } else if ("startsWith" in X.validation) $ = `Invalid input: must start with "${X.validation.startsWith}"`;
      else if ("endsWith" in X.validation) $ = `Invalid input: must end with "${X.validation.endsWith}"`;
      else n.assertNever(X.validation);
      else if (X.validation !== "regex") $ = `Invalid ${X.validation}`;
      else $ = "Invalid";
      break;
    case w.too_small:
      if (X.type === "array") $ = `Array must contain ${X.exact ? "exactly" : X.inclusive ? "at least" : "more than"} ${X.minimum} element(s)`;
      else if (X.type === "string") $ = `String must contain ${X.exact ? "exactly" : X.inclusive ? "at least" : "over"} ${X.minimum} character(s)`;
      else if (X.type === "number") $ = `Number must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${X.minimum}`;
      else if (X.type === "bigint") $ = `Number must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${X.minimum}`;
      else if (X.type === "date") $ = `Date must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(X.minimum))}`;
      else $ = "Invalid input";
      break;
    case w.too_big:
      if (X.type === "array") $ = `Array must contain ${X.exact ? "exactly" : X.inclusive ? "at most" : "less than"} ${X.maximum} element(s)`;
      else if (X.type === "string") $ = `String must contain ${X.exact ? "exactly" : X.inclusive ? "at most" : "under"} ${X.maximum} character(s)`;
      else if (X.type === "number") $ = `Number must be ${X.exact ? "exactly" : X.inclusive ? "less than or equal to" : "less than"} ${X.maximum}`;
      else if (X.type === "bigint") $ = `BigInt must be ${X.exact ? "exactly" : X.inclusive ? "less than or equal to" : "less than"} ${X.maximum}`;
      else if (X.type === "date") $ = `Date must be ${X.exact ? "exactly" : X.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(X.maximum))}`;
      else $ = "Invalid input";
      break;
    case w.custom:
      $ = "Invalid input";
      break;
    case w.invalid_intersection_types:
      $ = "Intersection results could not be merged";
      break;
    case w.not_multiple_of:
      $ = `Number must be a multiple of ${X.multipleOf}`;
      break;
    case w.not_finite:
      $ = "Number must be finite";
      break;
    default:
      $ = Q.defaultError, n.assertNever(X);
  }
  return { message: $ };
};
var T1 = $V;
var YV = T1;
function YX() {
  return YV;
}
var N4 = (X) => {
  let { data: Q, path: $, errorMaps: Y, issueData: W } = X, J = [...$, ...W.path || []], G = { ...W, path: J };
  if (W.message !== void 0) return { ...W, path: J, message: W.message };
  let H = "", B = Y.filter((z) => !!z).slice().reverse();
  for (let z of B) H = z(G, { data: Q, defaultError: H }).message;
  return { ...W, path: J, message: H };
};
function b(X, Q) {
  let $ = YX(), Y = N4({ issueData: Q, data: X.data, path: X.path, errorMaps: [X.common.contextualErrorMap, X.schemaErrorMap, $, $ === T1 ? void 0 : T1].filter((W) => !!W) });
  X.common.issues.push(Y);
}
var E0 = class _E0 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid") this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted") this.value = "aborted";
  }
  static mergeArray(X, Q) {
    let $ = [];
    for (let Y of Q) {
      if (Y.status === "aborted") return g;
      if (Y.status === "dirty") X.dirty();
      $.push(Y.value);
    }
    return { status: X.value, value: $ };
  }
  static async mergeObjectAsync(X, Q) {
    let $ = [];
    for (let Y of Q) {
      let W = await Y.key, J = await Y.value;
      $.push({ key: W, value: J });
    }
    return _E0.mergeObjectSync(X, $);
  }
  static mergeObjectSync(X, Q) {
    let $ = {};
    for (let Y of Q) {
      let { key: W, value: J } = Y;
      if (W.status === "aborted") return g;
      if (J.status === "aborted") return g;
      if (W.status === "dirty") X.dirty();
      if (J.status === "dirty") X.dirty();
      if (W.value !== "__proto__" && (typeof J.value < "u" || Y.alwaysSet)) $[W.value] = J.value;
    }
    return { status: X.value, value: $ };
  }
};
var g = Object.freeze({ status: "aborted" });
var R6 = (X) => ({ status: "dirty", value: X });
var C0 = (X) => ({ status: "valid", value: X });
var L9 = (X) => X.status === "aborted";
var q9 = (X) => X.status === "dirty";
var o1 = (X) => X.status === "valid";
var WX = (X) => typeof Promise < "u" && X instanceof Promise;
var Z;
(function(X) {
  X.errToObj = (Q) => typeof Q === "string" ? { message: Q } : Q || {}, X.toString = (Q) => typeof Q === "string" ? Q : Q?.message;
})(Z || (Z = {}));
var r0 = class {
  constructor(X, Q, $, Y) {
    this._cachedPath = [], this.parent = X, this.data = Q, this._path = $, this._key = Y;
  }
  get path() {
    if (!this._cachedPath.length) if (Array.isArray(this._key)) this._cachedPath.push(...this._path, ...this._key);
    else this._cachedPath.push(...this._path, this._key);
    return this._cachedPath;
  }
};
var LW = (X, Q) => {
  if (o1(Q)) return { success: true, data: Q.value };
  else {
    if (!X.common.issues.length) throw Error("Validation failed but no issues detected.");
    return { success: false, get error() {
      if (this._error) return this._error;
      let $ = new h0(X.common.issues);
      return this._error = $, this._error;
    } };
  }
};
function l(X) {
  if (!X) return {};
  let { errorMap: Q, invalid_type_error: $, required_error: Y, description: W } = X;
  if (Q && ($ || Y)) throw Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  if (Q) return { errorMap: Q, description: W };
  return { errorMap: (G, H) => {
    let { message: B } = X;
    if (G.code === "invalid_enum_value") return { message: B ?? H.defaultError };
    if (typeof H.data > "u") return { message: B ?? Y ?? H.defaultError };
    if (G.code !== "invalid_type") return { message: H.defaultError };
    return { message: B ?? $ ?? H.defaultError };
  }, description: W };
}
var p = class {
  get description() {
    return this._def.description;
  }
  _getType(X) {
    return O1(X.data);
  }
  _getOrReturnCtx(X, Q) {
    return Q || { common: X.parent.common, data: X.data, parsedType: O1(X.data), schemaErrorMap: this._def.errorMap, path: X.path, parent: X.parent };
  }
  _processInputParams(X) {
    return { status: new E0(), ctx: { common: X.parent.common, data: X.data, parsedType: O1(X.data), schemaErrorMap: this._def.errorMap, path: X.path, parent: X.parent } };
  }
  _parseSync(X) {
    let Q = this._parse(X);
    if (WX(Q)) throw Error("Synchronous parse encountered promise.");
    return Q;
  }
  _parseAsync(X) {
    let Q = this._parse(X);
    return Promise.resolve(Q);
  }
  parse(X, Q) {
    let $ = this.safeParse(X, Q);
    if ($.success) return $.data;
    throw $.error;
  }
  safeParse(X, Q) {
    let $ = { common: { issues: [], async: Q?.async ?? false, contextualErrorMap: Q?.errorMap }, path: Q?.path || [], schemaErrorMap: this._def.errorMap, parent: null, data: X, parsedType: O1(X) }, Y = this._parseSync({ data: X, path: $.path, parent: $ });
    return LW($, Y);
  }
  "~validate"(X) {
    let Q = { common: { issues: [], async: !!this["~standard"].async }, path: [], schemaErrorMap: this._def.errorMap, parent: null, data: X, parsedType: O1(X) };
    if (!this["~standard"].async) try {
      let $ = this._parseSync({ data: X, path: [], parent: Q });
      return o1($) ? { value: $.value } : { issues: Q.common.issues };
    } catch ($) {
      if ($?.message?.toLowerCase()?.includes("encountered")) this["~standard"].async = true;
      Q.common = { issues: [], async: true };
    }
    return this._parseAsync({ data: X, path: [], parent: Q }).then(($) => o1($) ? { value: $.value } : { issues: Q.common.issues });
  }
  async parseAsync(X, Q) {
    let $ = await this.safeParseAsync(X, Q);
    if ($.success) return $.data;
    throw $.error;
  }
  async safeParseAsync(X, Q) {
    let $ = { common: { issues: [], contextualErrorMap: Q?.errorMap, async: true }, path: Q?.path || [], schemaErrorMap: this._def.errorMap, parent: null, data: X, parsedType: O1(X) }, Y = this._parse({ data: X, path: $.path, parent: $ }), W = await (WX(Y) ? Y : Promise.resolve(Y));
    return LW($, W);
  }
  refine(X, Q) {
    let $ = (Y) => {
      if (typeof Q === "string" || typeof Q > "u") return { message: Q };
      else if (typeof Q === "function") return Q(Y);
      else return Q;
    };
    return this._refinement((Y, W) => {
      let J = X(Y), G = () => W.addIssue({ code: w.custom, ...$(Y) });
      if (typeof Promise < "u" && J instanceof Promise) return J.then((H) => {
        if (!H) return G(), false;
        else return true;
      });
      if (!J) return G(), false;
      else return true;
    });
  }
  refinement(X, Q) {
    return this._refinement(($, Y) => {
      if (!X($)) return Y.addIssue(typeof Q === "function" ? Q($, Y) : Q), false;
      else return true;
    });
  }
  _refinement(X) {
    return new H1({ schema: this, typeName: j.ZodEffects, effect: { type: "refinement", refinement: X } });
  }
  superRefine(X) {
    return this._refinement(X);
  }
  constructor(X) {
    this.spa = this.safeParseAsync, this._def = X, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = { version: 1, vendor: "zod", validate: (Q) => this["~validate"](Q) };
  }
  optional() {
    return G1.create(this, this._def);
  }
  nullable() {
    return _1.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return J1.create(this);
  }
  promise() {
    return S6.create(this, this._def);
  }
  or(X) {
    return zX.create([this, X], this._def);
  }
  and(X) {
    return KX.create(this, X, this._def);
  }
  transform(X) {
    return new H1({ ...l(this._def), schema: this, typeName: j.ZodEffects, effect: { type: "transform", transform: X } });
  }
  default(X) {
    let Q = typeof X === "function" ? X : () => X;
    return new qX({ ...l(this._def), innerType: this, defaultValue: Q, typeName: j.ZodDefault });
  }
  brand() {
    return new D9({ typeName: j.ZodBranded, type: this, ...l(this._def) });
  }
  catch(X) {
    let Q = typeof X === "function" ? X : () => X;
    return new FX({ ...l(this._def), innerType: this, catchValue: Q, typeName: j.ZodCatch });
  }
  describe(X) {
    return new this.constructor({ ...this._def, description: X });
  }
  pipe(X) {
    return I4.create(this, X);
  }
  readonly() {
    return NX.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var WV = /^c[^\s-]{8,}$/i;
var JV = /^[0-9a-z]+$/;
var GV = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var HV = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var BV = /^[a-z0-9_-]{21}$/i;
var zV = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var KV = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var UV = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var VV = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
var F9;
var LV = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var qV = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var FV = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var NV = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var OV = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var DV = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var qW = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
var AV = new RegExp(`^${qW}$`);
function FW(X) {
  let Q = "[0-5]\\d";
  if (X.precision) Q = `${Q}\\.\\d{${X.precision}}`;
  else if (X.precision == null) Q = `${Q}(\\.\\d+)?`;
  let $ = X.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${Q})${$}`;
}
function wV(X) {
  return new RegExp(`^${FW(X)}$`);
}
function MV(X) {
  let Q = `${qW}T${FW(X)}`, $ = [];
  if ($.push(X.local ? "Z?" : "Z"), X.offset) $.push("([+-]\\d{2}:?\\d{2})");
  return Q = `${Q}(${$.join("|")})`, new RegExp(`^${Q}$`);
}
function jV(X, Q) {
  if ((Q === "v4" || !Q) && LV.test(X)) return true;
  if ((Q === "v6" || !Q) && FV.test(X)) return true;
  return false;
}
function RV(X, Q) {
  if (!zV.test(X)) return false;
  try {
    let [$] = X.split(".");
    if (!$) return false;
    let Y = $.replace(/-/g, "+").replace(/_/g, "/").padEnd($.length + (4 - $.length % 4) % 4, "="), W = JSON.parse(atob(Y));
    if (typeof W !== "object" || W === null) return false;
    if ("typ" in W && W?.typ !== "JWT") return false;
    if (!W.alg) return false;
    if (Q && W.alg !== Q) return false;
    return true;
  } catch {
    return false;
  }
}
function IV(X, Q) {
  if ((Q === "v4" || !Q) && qV.test(X)) return true;
  if ((Q === "v6" || !Q) && NV.test(X)) return true;
  return false;
}
var A1 = class _A1 extends p {
  _parse(X) {
    if (this._def.coerce) X.data = String(X.data);
    if (this._getType(X) !== I.string) {
      let W = this._getOrReturnCtx(X);
      return b(W, { code: w.invalid_type, expected: I.string, received: W.parsedType }), g;
    }
    let $ = new E0(), Y = void 0;
    for (let W of this._def.checks) if (W.kind === "min") {
      if (X.data.length < W.value) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.too_small, minimum: W.value, type: "string", inclusive: true, exact: false, message: W.message }), $.dirty();
    } else if (W.kind === "max") {
      if (X.data.length > W.value) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.too_big, maximum: W.value, type: "string", inclusive: true, exact: false, message: W.message }), $.dirty();
    } else if (W.kind === "length") {
      let J = X.data.length > W.value, G = X.data.length < W.value;
      if (J || G) {
        if (Y = this._getOrReturnCtx(X, Y), J) b(Y, { code: w.too_big, maximum: W.value, type: "string", inclusive: true, exact: true, message: W.message });
        else if (G) b(Y, { code: w.too_small, minimum: W.value, type: "string", inclusive: true, exact: true, message: W.message });
        $.dirty();
      }
    } else if (W.kind === "email") {
      if (!UV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "email", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "emoji") {
      if (!F9) F9 = new RegExp(VV, "u");
      if (!F9.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "emoji", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "uuid") {
      if (!HV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "uuid", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "nanoid") {
      if (!BV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "nanoid", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "cuid") {
      if (!WV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "cuid", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "cuid2") {
      if (!JV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "cuid2", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "ulid") {
      if (!GV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "ulid", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "url") try {
      new URL(X.data);
    } catch {
      Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "url", code: w.invalid_string, message: W.message }), $.dirty();
    }
    else if (W.kind === "regex") {
      if (W.regex.lastIndex = 0, !W.regex.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "regex", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "trim") X.data = X.data.trim();
    else if (W.kind === "includes") {
      if (!X.data.includes(W.value, W.position)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: { includes: W.value, position: W.position }, message: W.message }), $.dirty();
    } else if (W.kind === "toLowerCase") X.data = X.data.toLowerCase();
    else if (W.kind === "toUpperCase") X.data = X.data.toUpperCase();
    else if (W.kind === "startsWith") {
      if (!X.data.startsWith(W.value)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: { startsWith: W.value }, message: W.message }), $.dirty();
    } else if (W.kind === "endsWith") {
      if (!X.data.endsWith(W.value)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: { endsWith: W.value }, message: W.message }), $.dirty();
    } else if (W.kind === "datetime") {
      if (!MV(W).test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: "datetime", message: W.message }), $.dirty();
    } else if (W.kind === "date") {
      if (!AV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: "date", message: W.message }), $.dirty();
    } else if (W.kind === "time") {
      if (!wV(W).test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.invalid_string, validation: "time", message: W.message }), $.dirty();
    } else if (W.kind === "duration") {
      if (!KV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "duration", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "ip") {
      if (!jV(X.data, W.version)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "ip", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "jwt") {
      if (!RV(X.data, W.alg)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "jwt", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "cidr") {
      if (!IV(X.data, W.version)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "cidr", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "base64") {
      if (!OV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "base64", code: w.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "base64url") {
      if (!DV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "base64url", code: w.invalid_string, message: W.message }), $.dirty();
    } else n.assertNever(W);
    return { status: $.value, value: X.data };
  }
  _regex(X, Q, $) {
    return this.refinement((Y) => X.test(Y), { validation: Q, code: w.invalid_string, ...Z.errToObj($) });
  }
  _addCheck(X) {
    return new _A1({ ...this._def, checks: [...this._def.checks, X] });
  }
  email(X) {
    return this._addCheck({ kind: "email", ...Z.errToObj(X) });
  }
  url(X) {
    return this._addCheck({ kind: "url", ...Z.errToObj(X) });
  }
  emoji(X) {
    return this._addCheck({ kind: "emoji", ...Z.errToObj(X) });
  }
  uuid(X) {
    return this._addCheck({ kind: "uuid", ...Z.errToObj(X) });
  }
  nanoid(X) {
    return this._addCheck({ kind: "nanoid", ...Z.errToObj(X) });
  }
  cuid(X) {
    return this._addCheck({ kind: "cuid", ...Z.errToObj(X) });
  }
  cuid2(X) {
    return this._addCheck({ kind: "cuid2", ...Z.errToObj(X) });
  }
  ulid(X) {
    return this._addCheck({ kind: "ulid", ...Z.errToObj(X) });
  }
  base64(X) {
    return this._addCheck({ kind: "base64", ...Z.errToObj(X) });
  }
  base64url(X) {
    return this._addCheck({ kind: "base64url", ...Z.errToObj(X) });
  }
  jwt(X) {
    return this._addCheck({ kind: "jwt", ...Z.errToObj(X) });
  }
  ip(X) {
    return this._addCheck({ kind: "ip", ...Z.errToObj(X) });
  }
  cidr(X) {
    return this._addCheck({ kind: "cidr", ...Z.errToObj(X) });
  }
  datetime(X) {
    if (typeof X === "string") return this._addCheck({ kind: "datetime", precision: null, offset: false, local: false, message: X });
    return this._addCheck({ kind: "datetime", precision: typeof X?.precision > "u" ? null : X?.precision, offset: X?.offset ?? false, local: X?.local ?? false, ...Z.errToObj(X?.message) });
  }
  date(X) {
    return this._addCheck({ kind: "date", message: X });
  }
  time(X) {
    if (typeof X === "string") return this._addCheck({ kind: "time", precision: null, message: X });
    return this._addCheck({ kind: "time", precision: typeof X?.precision > "u" ? null : X?.precision, ...Z.errToObj(X?.message) });
  }
  duration(X) {
    return this._addCheck({ kind: "duration", ...Z.errToObj(X) });
  }
  regex(X, Q) {
    return this._addCheck({ kind: "regex", regex: X, ...Z.errToObj(Q) });
  }
  includes(X, Q) {
    return this._addCheck({ kind: "includes", value: X, position: Q?.position, ...Z.errToObj(Q?.message) });
  }
  startsWith(X, Q) {
    return this._addCheck({ kind: "startsWith", value: X, ...Z.errToObj(Q) });
  }
  endsWith(X, Q) {
    return this._addCheck({ kind: "endsWith", value: X, ...Z.errToObj(Q) });
  }
  min(X, Q) {
    return this._addCheck({ kind: "min", value: X, ...Z.errToObj(Q) });
  }
  max(X, Q) {
    return this._addCheck({ kind: "max", value: X, ...Z.errToObj(Q) });
  }
  length(X, Q) {
    return this._addCheck({ kind: "length", value: X, ...Z.errToObj(Q) });
  }
  nonempty(X) {
    return this.min(1, Z.errToObj(X));
  }
  trim() {
    return new _A1({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] });
  }
  toLowerCase() {
    return new _A1({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] });
  }
  toUpperCase() {
    return new _A1({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] });
  }
  get isDatetime() {
    return !!this._def.checks.find((X) => X.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((X) => X.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((X) => X.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((X) => X.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((X) => X.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((X) => X.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((X) => X.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((X) => X.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((X) => X.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((X) => X.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((X) => X.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((X) => X.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((X) => X.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((X) => X.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((X) => X.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((X) => X.kind === "base64url");
  }
  get minLength() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "min") {
      if (X === null || Q.value > X) X = Q.value;
    }
    return X;
  }
  get maxLength() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "max") {
      if (X === null || Q.value < X) X = Q.value;
    }
    return X;
  }
};
A1.create = (X) => {
  return new A1({ checks: [], typeName: j.ZodString, coerce: X?.coerce ?? false, ...l(X) });
};
function EV(X, Q) {
  let $ = (X.toString().split(".")[1] || "").length, Y = (Q.toString().split(".")[1] || "").length, W = $ > Y ? $ : Y, J = Number.parseInt(X.toFixed(W).replace(".", "")), G = Number.parseInt(Q.toFixed(W).replace(".", ""));
  return J % G / 10 ** W;
}
var E6 = class _E6 extends p {
  constructor() {
    super(...arguments);
    this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(X) {
    if (this._def.coerce) X.data = Number(X.data);
    if (this._getType(X) !== I.number) {
      let W = this._getOrReturnCtx(X);
      return b(W, { code: w.invalid_type, expected: I.number, received: W.parsedType }), g;
    }
    let $ = void 0, Y = new E0();
    for (let W of this._def.checks) if (W.kind === "int") {
      if (!n.isInteger(X.data)) $ = this._getOrReturnCtx(X, $), b($, { code: w.invalid_type, expected: "integer", received: "float", message: W.message }), Y.dirty();
    } else if (W.kind === "min") {
      if (W.inclusive ? X.data < W.value : X.data <= W.value) $ = this._getOrReturnCtx(X, $), b($, { code: w.too_small, minimum: W.value, type: "number", inclusive: W.inclusive, exact: false, message: W.message }), Y.dirty();
    } else if (W.kind === "max") {
      if (W.inclusive ? X.data > W.value : X.data >= W.value) $ = this._getOrReturnCtx(X, $), b($, { code: w.too_big, maximum: W.value, type: "number", inclusive: W.inclusive, exact: false, message: W.message }), Y.dirty();
    } else if (W.kind === "multipleOf") {
      if (EV(X.data, W.value) !== 0) $ = this._getOrReturnCtx(X, $), b($, { code: w.not_multiple_of, multipleOf: W.value, message: W.message }), Y.dirty();
    } else if (W.kind === "finite") {
      if (!Number.isFinite(X.data)) $ = this._getOrReturnCtx(X, $), b($, { code: w.not_finite, message: W.message }), Y.dirty();
    } else n.assertNever(W);
    return { status: Y.value, value: X.data };
  }
  gte(X, Q) {
    return this.setLimit("min", X, true, Z.toString(Q));
  }
  gt(X, Q) {
    return this.setLimit("min", X, false, Z.toString(Q));
  }
  lte(X, Q) {
    return this.setLimit("max", X, true, Z.toString(Q));
  }
  lt(X, Q) {
    return this.setLimit("max", X, false, Z.toString(Q));
  }
  setLimit(X, Q, $, Y) {
    return new _E6({ ...this._def, checks: [...this._def.checks, { kind: X, value: Q, inclusive: $, message: Z.toString(Y) }] });
  }
  _addCheck(X) {
    return new _E6({ ...this._def, checks: [...this._def.checks, X] });
  }
  int(X) {
    return this._addCheck({ kind: "int", message: Z.toString(X) });
  }
  positive(X) {
    return this._addCheck({ kind: "min", value: 0, inclusive: false, message: Z.toString(X) });
  }
  negative(X) {
    return this._addCheck({ kind: "max", value: 0, inclusive: false, message: Z.toString(X) });
  }
  nonpositive(X) {
    return this._addCheck({ kind: "max", value: 0, inclusive: true, message: Z.toString(X) });
  }
  nonnegative(X) {
    return this._addCheck({ kind: "min", value: 0, inclusive: true, message: Z.toString(X) });
  }
  multipleOf(X, Q) {
    return this._addCheck({ kind: "multipleOf", value: X, message: Z.toString(Q) });
  }
  finite(X) {
    return this._addCheck({ kind: "finite", message: Z.toString(X) });
  }
  safe(X) {
    return this._addCheck({ kind: "min", inclusive: true, value: Number.MIN_SAFE_INTEGER, message: Z.toString(X) })._addCheck({ kind: "max", inclusive: true, value: Number.MAX_SAFE_INTEGER, message: Z.toString(X) });
  }
  get minValue() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "min") {
      if (X === null || Q.value > X) X = Q.value;
    }
    return X;
  }
  get maxValue() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "max") {
      if (X === null || Q.value < X) X = Q.value;
    }
    return X;
  }
  get isInt() {
    return !!this._def.checks.find((X) => X.kind === "int" || X.kind === "multipleOf" && n.isInteger(X.value));
  }
  get isFinite() {
    let X = null, Q = null;
    for (let $ of this._def.checks) if ($.kind === "finite" || $.kind === "int" || $.kind === "multipleOf") return true;
    else if ($.kind === "min") {
      if (Q === null || $.value > Q) Q = $.value;
    } else if ($.kind === "max") {
      if (X === null || $.value < X) X = $.value;
    }
    return Number.isFinite(Q) && Number.isFinite(X);
  }
};
E6.create = (X) => {
  return new E6({ checks: [], typeName: j.ZodNumber, coerce: X?.coerce || false, ...l(X) });
};
var b6 = class _b6 extends p {
  constructor() {
    super(...arguments);
    this.min = this.gte, this.max = this.lte;
  }
  _parse(X) {
    if (this._def.coerce) try {
      X.data = BigInt(X.data);
    } catch {
      return this._getInvalidInput(X);
    }
    if (this._getType(X) !== I.bigint) return this._getInvalidInput(X);
    let $ = void 0, Y = new E0();
    for (let W of this._def.checks) if (W.kind === "min") {
      if (W.inclusive ? X.data < W.value : X.data <= W.value) $ = this._getOrReturnCtx(X, $), b($, { code: w.too_small, type: "bigint", minimum: W.value, inclusive: W.inclusive, message: W.message }), Y.dirty();
    } else if (W.kind === "max") {
      if (W.inclusive ? X.data > W.value : X.data >= W.value) $ = this._getOrReturnCtx(X, $), b($, { code: w.too_big, type: "bigint", maximum: W.value, inclusive: W.inclusive, message: W.message }), Y.dirty();
    } else if (W.kind === "multipleOf") {
      if (X.data % W.value !== BigInt(0)) $ = this._getOrReturnCtx(X, $), b($, { code: w.not_multiple_of, multipleOf: W.value, message: W.message }), Y.dirty();
    } else n.assertNever(W);
    return { status: Y.value, value: X.data };
  }
  _getInvalidInput(X) {
    let Q = this._getOrReturnCtx(X);
    return b(Q, { code: w.invalid_type, expected: I.bigint, received: Q.parsedType }), g;
  }
  gte(X, Q) {
    return this.setLimit("min", X, true, Z.toString(Q));
  }
  gt(X, Q) {
    return this.setLimit("min", X, false, Z.toString(Q));
  }
  lte(X, Q) {
    return this.setLimit("max", X, true, Z.toString(Q));
  }
  lt(X, Q) {
    return this.setLimit("max", X, false, Z.toString(Q));
  }
  setLimit(X, Q, $, Y) {
    return new _b6({ ...this._def, checks: [...this._def.checks, { kind: X, value: Q, inclusive: $, message: Z.toString(Y) }] });
  }
  _addCheck(X) {
    return new _b6({ ...this._def, checks: [...this._def.checks, X] });
  }
  positive(X) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: false, message: Z.toString(X) });
  }
  negative(X) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: false, message: Z.toString(X) });
  }
  nonpositive(X) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: true, message: Z.toString(X) });
  }
  nonnegative(X) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: true, message: Z.toString(X) });
  }
  multipleOf(X, Q) {
    return this._addCheck({ kind: "multipleOf", value: X, message: Z.toString(Q) });
  }
  get minValue() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "min") {
      if (X === null || Q.value > X) X = Q.value;
    }
    return X;
  }
  get maxValue() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "max") {
      if (X === null || Q.value < X) X = Q.value;
    }
    return X;
  }
};
b6.create = (X) => {
  return new b6({ checks: [], typeName: j.ZodBigInt, coerce: X?.coerce ?? false, ...l(X) });
};
var O4 = class extends p {
  _parse(X) {
    if (this._def.coerce) X.data = Boolean(X.data);
    if (this._getType(X) !== I.boolean) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: w.invalid_type, expected: I.boolean, received: $.parsedType }), g;
    }
    return C0(X.data);
  }
};
O4.create = (X) => {
  return new O4({ typeName: j.ZodBoolean, coerce: X?.coerce || false, ...l(X) });
};
var GX = class _GX extends p {
  _parse(X) {
    if (this._def.coerce) X.data = new Date(X.data);
    if (this._getType(X) !== I.date) {
      let W = this._getOrReturnCtx(X);
      return b(W, { code: w.invalid_type, expected: I.date, received: W.parsedType }), g;
    }
    if (Number.isNaN(X.data.getTime())) {
      let W = this._getOrReturnCtx(X);
      return b(W, { code: w.invalid_date }), g;
    }
    let $ = new E0(), Y = void 0;
    for (let W of this._def.checks) if (W.kind === "min") {
      if (X.data.getTime() < W.value) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.too_small, message: W.message, inclusive: true, exact: false, minimum: W.value, type: "date" }), $.dirty();
    } else if (W.kind === "max") {
      if (X.data.getTime() > W.value) Y = this._getOrReturnCtx(X, Y), b(Y, { code: w.too_big, message: W.message, inclusive: true, exact: false, maximum: W.value, type: "date" }), $.dirty();
    } else n.assertNever(W);
    return { status: $.value, value: new Date(X.data.getTime()) };
  }
  _addCheck(X) {
    return new _GX({ ...this._def, checks: [...this._def.checks, X] });
  }
  min(X, Q) {
    return this._addCheck({ kind: "min", value: X.getTime(), message: Z.toString(Q) });
  }
  max(X, Q) {
    return this._addCheck({ kind: "max", value: X.getTime(), message: Z.toString(Q) });
  }
  get minDate() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "min") {
      if (X === null || Q.value > X) X = Q.value;
    }
    return X != null ? new Date(X) : null;
  }
  get maxDate() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "max") {
      if (X === null || Q.value < X) X = Q.value;
    }
    return X != null ? new Date(X) : null;
  }
};
GX.create = (X) => {
  return new GX({ checks: [], coerce: X?.coerce || false, typeName: j.ZodDate, ...l(X) });
};
var D4 = class extends p {
  _parse(X) {
    if (this._getType(X) !== I.symbol) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: w.invalid_type, expected: I.symbol, received: $.parsedType }), g;
    }
    return C0(X.data);
  }
};
D4.create = (X) => {
  return new D4({ typeName: j.ZodSymbol, ...l(X) });
};
var HX = class extends p {
  _parse(X) {
    if (this._getType(X) !== I.undefined) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: w.invalid_type, expected: I.undefined, received: $.parsedType }), g;
    }
    return C0(X.data);
  }
};
HX.create = (X) => {
  return new HX({ typeName: j.ZodUndefined, ...l(X) });
};
var BX = class extends p {
  _parse(X) {
    if (this._getType(X) !== I.null) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: w.invalid_type, expected: I.null, received: $.parsedType }), g;
    }
    return C0(X.data);
  }
};
BX.create = (X) => {
  return new BX({ typeName: j.ZodNull, ...l(X) });
};
var A4 = class extends p {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(X) {
    return C0(X.data);
  }
};
A4.create = (X) => {
  return new A4({ typeName: j.ZodAny, ...l(X) });
};
var t1 = class extends p {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(X) {
    return C0(X.data);
  }
};
t1.create = (X) => {
  return new t1({ typeName: j.ZodUnknown, ...l(X) });
};
var w1 = class extends p {
  _parse(X) {
    let Q = this._getOrReturnCtx(X);
    return b(Q, { code: w.invalid_type, expected: I.never, received: Q.parsedType }), g;
  }
};
w1.create = (X) => {
  return new w1({ typeName: j.ZodNever, ...l(X) });
};
var w4 = class extends p {
  _parse(X) {
    if (this._getType(X) !== I.undefined) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: w.invalid_type, expected: I.void, received: $.parsedType }), g;
    }
    return C0(X.data);
  }
};
w4.create = (X) => {
  return new w4({ typeName: j.ZodVoid, ...l(X) });
};
var J1 = class _J1 extends p {
  _parse(X) {
    let { ctx: Q, status: $ } = this._processInputParams(X), Y = this._def;
    if (Q.parsedType !== I.array) return b(Q, { code: w.invalid_type, expected: I.array, received: Q.parsedType }), g;
    if (Y.exactLength !== null) {
      let J = Q.data.length > Y.exactLength.value, G = Q.data.length < Y.exactLength.value;
      if (J || G) b(Q, { code: J ? w.too_big : w.too_small, minimum: G ? Y.exactLength.value : void 0, maximum: J ? Y.exactLength.value : void 0, type: "array", inclusive: true, exact: true, message: Y.exactLength.message }), $.dirty();
    }
    if (Y.minLength !== null) {
      if (Q.data.length < Y.minLength.value) b(Q, { code: w.too_small, minimum: Y.minLength.value, type: "array", inclusive: true, exact: false, message: Y.minLength.message }), $.dirty();
    }
    if (Y.maxLength !== null) {
      if (Q.data.length > Y.maxLength.value) b(Q, { code: w.too_big, maximum: Y.maxLength.value, type: "array", inclusive: true, exact: false, message: Y.maxLength.message }), $.dirty();
    }
    if (Q.common.async) return Promise.all([...Q.data].map((J, G) => {
      return Y.type._parseAsync(new r0(Q, J, Q.path, G));
    })).then((J) => {
      return E0.mergeArray($, J);
    });
    let W = [...Q.data].map((J, G) => {
      return Y.type._parseSync(new r0(Q, J, Q.path, G));
    });
    return E0.mergeArray($, W);
  }
  get element() {
    return this._def.type;
  }
  min(X, Q) {
    return new _J1({ ...this._def, minLength: { value: X, message: Z.toString(Q) } });
  }
  max(X, Q) {
    return new _J1({ ...this._def, maxLength: { value: X, message: Z.toString(Q) } });
  }
  length(X, Q) {
    return new _J1({ ...this._def, exactLength: { value: X, message: Z.toString(Q) } });
  }
  nonempty(X) {
    return this.min(1, X);
  }
};
J1.create = (X, Q) => {
  return new J1({ type: X, minLength: null, maxLength: null, exactLength: null, typeName: j.ZodArray, ...l(Q) });
};
function I6(X) {
  if (X instanceof V0) {
    let Q = {};
    for (let $ in X.shape) {
      let Y = X.shape[$];
      Q[$] = G1.create(I6(Y));
    }
    return new V0({ ...X._def, shape: () => Q });
  } else if (X instanceof J1) return new J1({ ...X._def, type: I6(X.element) });
  else if (X instanceof G1) return G1.create(I6(X.unwrap()));
  else if (X instanceof _1) return _1.create(I6(X.unwrap()));
  else if (X instanceof M1) return M1.create(X.items.map((Q) => I6(Q)));
  else return X;
}
var V0 = class _V0 extends p {
  constructor() {
    super(...arguments);
    this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    let X = this._def.shape(), Q = n.objectKeys(X);
    return this._cached = { shape: X, keys: Q }, this._cached;
  }
  _parse(X) {
    if (this._getType(X) !== I.object) {
      let B = this._getOrReturnCtx(X);
      return b(B, { code: w.invalid_type, expected: I.object, received: B.parsedType }), g;
    }
    let { status: $, ctx: Y } = this._processInputParams(X), { shape: W, keys: J } = this._getCached(), G = [];
    if (!(this._def.catchall instanceof w1 && this._def.unknownKeys === "strip")) {
      for (let B in Y.data) if (!J.includes(B)) G.push(B);
    }
    let H = [];
    for (let B of J) {
      let z = W[B], K = Y.data[B];
      H.push({ key: { status: "valid", value: B }, value: z._parse(new r0(Y, K, Y.path, B)), alwaysSet: B in Y.data });
    }
    if (this._def.catchall instanceof w1) {
      let B = this._def.unknownKeys;
      if (B === "passthrough") for (let z of G) H.push({ key: { status: "valid", value: z }, value: { status: "valid", value: Y.data[z] } });
      else if (B === "strict") {
        if (G.length > 0) b(Y, { code: w.unrecognized_keys, keys: G }), $.dirty();
      } else if (B === "strip") ;
      else throw Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      let B = this._def.catchall;
      for (let z of G) {
        let K = Y.data[z];
        H.push({ key: { status: "valid", value: z }, value: B._parse(new r0(Y, K, Y.path, z)), alwaysSet: z in Y.data });
      }
    }
    if (Y.common.async) return Promise.resolve().then(async () => {
      let B = [];
      for (let z of H) {
        let K = await z.key, V = await z.value;
        B.push({ key: K, value: V, alwaysSet: z.alwaysSet });
      }
      return B;
    }).then((B) => {
      return E0.mergeObjectSync($, B);
    });
    else return E0.mergeObjectSync($, H);
  }
  get shape() {
    return this._def.shape();
  }
  strict(X) {
    return Z.errToObj, new _V0({ ...this._def, unknownKeys: "strict", ...X !== void 0 ? { errorMap: (Q, $) => {
      let Y = this._def.errorMap?.(Q, $).message ?? $.defaultError;
      if (Q.code === "unrecognized_keys") return { message: Z.errToObj(X).message ?? Y };
      return { message: Y };
    } } : {} });
  }
  strip() {
    return new _V0({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new _V0({ ...this._def, unknownKeys: "passthrough" });
  }
  extend(X) {
    return new _V0({ ...this._def, shape: () => ({ ...this._def.shape(), ...X }) });
  }
  merge(X) {
    return new _V0({ unknownKeys: X._def.unknownKeys, catchall: X._def.catchall, shape: () => ({ ...this._def.shape(), ...X._def.shape() }), typeName: j.ZodObject });
  }
  setKey(X, Q) {
    return this.augment({ [X]: Q });
  }
  catchall(X) {
    return new _V0({ ...this._def, catchall: X });
  }
  pick(X) {
    let Q = {};
    for (let $ of n.objectKeys(X)) if (X[$] && this.shape[$]) Q[$] = this.shape[$];
    return new _V0({ ...this._def, shape: () => Q });
  }
  omit(X) {
    let Q = {};
    for (let $ of n.objectKeys(this.shape)) if (!X[$]) Q[$] = this.shape[$];
    return new _V0({ ...this._def, shape: () => Q });
  }
  deepPartial() {
    return I6(this);
  }
  partial(X) {
    let Q = {};
    for (let $ of n.objectKeys(this.shape)) {
      let Y = this.shape[$];
      if (X && !X[$]) Q[$] = Y;
      else Q[$] = Y.optional();
    }
    return new _V0({ ...this._def, shape: () => Q });
  }
  required(X) {
    let Q = {};
    for (let $ of n.objectKeys(this.shape)) if (X && !X[$]) Q[$] = this.shape[$];
    else {
      let W = this.shape[$];
      while (W instanceof G1) W = W._def.innerType;
      Q[$] = W;
    }
    return new _V0({ ...this._def, shape: () => Q });
  }
  keyof() {
    return NW(n.objectKeys(this.shape));
  }
};
V0.create = (X, Q) => {
  return new V0({ shape: () => X, unknownKeys: "strip", catchall: w1.create(), typeName: j.ZodObject, ...l(Q) });
};
V0.strictCreate = (X, Q) => {
  return new V0({ shape: () => X, unknownKeys: "strict", catchall: w1.create(), typeName: j.ZodObject, ...l(Q) });
};
V0.lazycreate = (X, Q) => {
  return new V0({ shape: X, unknownKeys: "strip", catchall: w1.create(), typeName: j.ZodObject, ...l(Q) });
};
var zX = class extends p {
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X), $ = this._def.options;
    function Y(W) {
      for (let G of W) if (G.result.status === "valid") return G.result;
      for (let G of W) if (G.result.status === "dirty") return Q.common.issues.push(...G.ctx.common.issues), G.result;
      let J = W.map((G) => new h0(G.ctx.common.issues));
      return b(Q, { code: w.invalid_union, unionErrors: J }), g;
    }
    if (Q.common.async) return Promise.all($.map(async (W) => {
      let J = { ...Q, common: { ...Q.common, issues: [] }, parent: null };
      return { result: await W._parseAsync({ data: Q.data, path: Q.path, parent: J }), ctx: J };
    })).then(Y);
    else {
      let W = void 0, J = [];
      for (let H of $) {
        let B = { ...Q, common: { ...Q.common, issues: [] }, parent: null }, z = H._parseSync({ data: Q.data, path: Q.path, parent: B });
        if (z.status === "valid") return z;
        else if (z.status === "dirty" && !W) W = { result: z, ctx: B };
        if (B.common.issues.length) J.push(B.common.issues);
      }
      if (W) return Q.common.issues.push(...W.ctx.common.issues), W.result;
      let G = J.map((H) => new h0(H));
      return b(Q, { code: w.invalid_union, unionErrors: G }), g;
    }
  }
  get options() {
    return this._def.options;
  }
};
zX.create = (X, Q) => {
  return new zX({ options: X, typeName: j.ZodUnion, ...l(Q) });
};
var D1 = (X) => {
  if (X instanceof UX) return D1(X.schema);
  else if (X instanceof H1) return D1(X.innerType());
  else if (X instanceof VX) return [X.value];
  else if (X instanceof a1) return X.options;
  else if (X instanceof LX) return n.objectValues(X.enum);
  else if (X instanceof qX) return D1(X._def.innerType);
  else if (X instanceof HX) return [void 0];
  else if (X instanceof BX) return [null];
  else if (X instanceof G1) return [void 0, ...D1(X.unwrap())];
  else if (X instanceof _1) return [null, ...D1(X.unwrap())];
  else if (X instanceof D9) return D1(X.unwrap());
  else if (X instanceof NX) return D1(X.unwrap());
  else if (X instanceof FX) return D1(X._def.innerType);
  else return [];
};
var O9 = class _O9 extends p {
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X);
    if (Q.parsedType !== I.object) return b(Q, { code: w.invalid_type, expected: I.object, received: Q.parsedType }), g;
    let $ = this.discriminator, Y = Q.data[$], W = this.optionsMap.get(Y);
    if (!W) return b(Q, { code: w.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [$] }), g;
    if (Q.common.async) return W._parseAsync({ data: Q.data, path: Q.path, parent: Q });
    else return W._parseSync({ data: Q.data, path: Q.path, parent: Q });
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(X, Q, $) {
    let Y = /* @__PURE__ */ new Map();
    for (let W of Q) {
      let J = D1(W.shape[X]);
      if (!J.length) throw Error(`A discriminator value for key \`${X}\` could not be extracted from all schema options`);
      for (let G of J) {
        if (Y.has(G)) throw Error(`Discriminator property ${String(X)} has duplicate value ${String(G)}`);
        Y.set(G, W);
      }
    }
    return new _O9({ typeName: j.ZodDiscriminatedUnion, discriminator: X, options: Q, optionsMap: Y, ...l($) });
  }
};
function N9(X, Q) {
  let $ = O1(X), Y = O1(Q);
  if (X === Q) return { valid: true, data: X };
  else if ($ === I.object && Y === I.object) {
    let W = n.objectKeys(Q), J = n.objectKeys(X).filter((H) => W.indexOf(H) !== -1), G = { ...X, ...Q };
    for (let H of J) {
      let B = N9(X[H], Q[H]);
      if (!B.valid) return { valid: false };
      G[H] = B.data;
    }
    return { valid: true, data: G };
  } else if ($ === I.array && Y === I.array) {
    if (X.length !== Q.length) return { valid: false };
    let W = [];
    for (let J = 0; J < X.length; J++) {
      let G = X[J], H = Q[J], B = N9(G, H);
      if (!B.valid) return { valid: false };
      W.push(B.data);
    }
    return { valid: true, data: W };
  } else if ($ === I.date && Y === I.date && +X === +Q) return { valid: true, data: X };
  else return { valid: false };
}
var KX = class extends p {
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X), Y = (W, J) => {
      if (L9(W) || L9(J)) return g;
      let G = N9(W.value, J.value);
      if (!G.valid) return b($, { code: w.invalid_intersection_types }), g;
      if (q9(W) || q9(J)) Q.dirty();
      return { status: Q.value, value: G.data };
    };
    if ($.common.async) return Promise.all([this._def.left._parseAsync({ data: $.data, path: $.path, parent: $ }), this._def.right._parseAsync({ data: $.data, path: $.path, parent: $ })]).then(([W, J]) => Y(W, J));
    else return Y(this._def.left._parseSync({ data: $.data, path: $.path, parent: $ }), this._def.right._parseSync({ data: $.data, path: $.path, parent: $ }));
  }
};
KX.create = (X, Q, $) => {
  return new KX({ left: X, right: Q, typeName: j.ZodIntersection, ...l($) });
};
var M1 = class _M1 extends p {
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X);
    if ($.parsedType !== I.array) return b($, { code: w.invalid_type, expected: I.array, received: $.parsedType }), g;
    if ($.data.length < this._def.items.length) return b($, { code: w.too_small, minimum: this._def.items.length, inclusive: true, exact: false, type: "array" }), g;
    if (!this._def.rest && $.data.length > this._def.items.length) b($, { code: w.too_big, maximum: this._def.items.length, inclusive: true, exact: false, type: "array" }), Q.dirty();
    let W = [...$.data].map((J, G) => {
      let H = this._def.items[G] || this._def.rest;
      if (!H) return null;
      return H._parse(new r0($, J, $.path, G));
    }).filter((J) => !!J);
    if ($.common.async) return Promise.all(W).then((J) => {
      return E0.mergeArray(Q, J);
    });
    else return E0.mergeArray(Q, W);
  }
  get items() {
    return this._def.items;
  }
  rest(X) {
    return new _M1({ ...this._def, rest: X });
  }
};
M1.create = (X, Q) => {
  if (!Array.isArray(X)) throw Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new M1({ items: X, typeName: j.ZodTuple, rest: null, ...l(Q) });
};
var M4 = class _M4 extends p {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X);
    if ($.parsedType !== I.object) return b($, { code: w.invalid_type, expected: I.object, received: $.parsedType }), g;
    let Y = [], W = this._def.keyType, J = this._def.valueType;
    for (let G in $.data) Y.push({ key: W._parse(new r0($, G, $.path, G)), value: J._parse(new r0($, $.data[G], $.path, G)), alwaysSet: G in $.data });
    if ($.common.async) return E0.mergeObjectAsync(Q, Y);
    else return E0.mergeObjectSync(Q, Y);
  }
  get element() {
    return this._def.valueType;
  }
  static create(X, Q, $) {
    if (Q instanceof p) return new _M4({ keyType: X, valueType: Q, typeName: j.ZodRecord, ...l($) });
    return new _M4({ keyType: A1.create(), valueType: X, typeName: j.ZodRecord, ...l(Q) });
  }
};
var j4 = class extends p {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X);
    if ($.parsedType !== I.map) return b($, { code: w.invalid_type, expected: I.map, received: $.parsedType }), g;
    let Y = this._def.keyType, W = this._def.valueType, J = [...$.data.entries()].map(([G, H], B) => {
      return { key: Y._parse(new r0($, G, $.path, [B, "key"])), value: W._parse(new r0($, H, $.path, [B, "value"])) };
    });
    if ($.common.async) {
      let G = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (let H of J) {
          let B = await H.key, z = await H.value;
          if (B.status === "aborted" || z.status === "aborted") return g;
          if (B.status === "dirty" || z.status === "dirty") Q.dirty();
          G.set(B.value, z.value);
        }
        return { status: Q.value, value: G };
      });
    } else {
      let G = /* @__PURE__ */ new Map();
      for (let H of J) {
        let { key: B, value: z } = H;
        if (B.status === "aborted" || z.status === "aborted") return g;
        if (B.status === "dirty" || z.status === "dirty") Q.dirty();
        G.set(B.value, z.value);
      }
      return { status: Q.value, value: G };
    }
  }
};
j4.create = (X, Q, $) => {
  return new j4({ valueType: Q, keyType: X, typeName: j.ZodMap, ...l($) });
};
var P6 = class _P6 extends p {
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X);
    if ($.parsedType !== I.set) return b($, { code: w.invalid_type, expected: I.set, received: $.parsedType }), g;
    let Y = this._def;
    if (Y.minSize !== null) {
      if ($.data.size < Y.minSize.value) b($, { code: w.too_small, minimum: Y.minSize.value, type: "set", inclusive: true, exact: false, message: Y.minSize.message }), Q.dirty();
    }
    if (Y.maxSize !== null) {
      if ($.data.size > Y.maxSize.value) b($, { code: w.too_big, maximum: Y.maxSize.value, type: "set", inclusive: true, exact: false, message: Y.maxSize.message }), Q.dirty();
    }
    let W = this._def.valueType;
    function J(H) {
      let B = /* @__PURE__ */ new Set();
      for (let z of H) {
        if (z.status === "aborted") return g;
        if (z.status === "dirty") Q.dirty();
        B.add(z.value);
      }
      return { status: Q.value, value: B };
    }
    let G = [...$.data.values()].map((H, B) => W._parse(new r0($, H, $.path, B)));
    if ($.common.async) return Promise.all(G).then((H) => J(H));
    else return J(G);
  }
  min(X, Q) {
    return new _P6({ ...this._def, minSize: { value: X, message: Z.toString(Q) } });
  }
  max(X, Q) {
    return new _P6({ ...this._def, maxSize: { value: X, message: Z.toString(Q) } });
  }
  size(X, Q) {
    return this.min(X, Q).max(X, Q);
  }
  nonempty(X) {
    return this.min(1, X);
  }
};
P6.create = (X, Q) => {
  return new P6({ valueType: X, minSize: null, maxSize: null, typeName: j.ZodSet, ...l(Q) });
};
var JX = class _JX extends p {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X);
    if (Q.parsedType !== I.function) return b(Q, { code: w.invalid_type, expected: I.function, received: Q.parsedType }), g;
    function $(G, H) {
      return N4({ data: G, path: Q.path, errorMaps: [Q.common.contextualErrorMap, Q.schemaErrorMap, YX(), T1].filter((B) => !!B), issueData: { code: w.invalid_arguments, argumentsError: H } });
    }
    function Y(G, H) {
      return N4({ data: G, path: Q.path, errorMaps: [Q.common.contextualErrorMap, Q.schemaErrorMap, YX(), T1].filter((B) => !!B), issueData: { code: w.invalid_return_type, returnTypeError: H } });
    }
    let W = { errorMap: Q.common.contextualErrorMap }, J = Q.data;
    if (this._def.returns instanceof S6) {
      let G = this;
      return C0(async function(...H) {
        let B = new h0([]), z = await G._def.args.parseAsync(H, W).catch((L) => {
          throw B.addIssue($(H, L)), B;
        }), K = await Reflect.apply(J, this, z);
        return await G._def.returns._def.type.parseAsync(K, W).catch((L) => {
          throw B.addIssue(Y(K, L)), B;
        });
      });
    } else {
      let G = this;
      return C0(function(...H) {
        let B = G._def.args.safeParse(H, W);
        if (!B.success) throw new h0([$(H, B.error)]);
        let z = Reflect.apply(J, this, B.data), K = G._def.returns.safeParse(z, W);
        if (!K.success) throw new h0([Y(z, K.error)]);
        return K.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...X) {
    return new _JX({ ...this._def, args: M1.create(X).rest(t1.create()) });
  }
  returns(X) {
    return new _JX({ ...this._def, returns: X });
  }
  implement(X) {
    return this.parse(X);
  }
  strictImplement(X) {
    return this.parse(X);
  }
  static create(X, Q, $) {
    return new _JX({ args: X ? X : M1.create([]).rest(t1.create()), returns: Q || t1.create(), typeName: j.ZodFunction, ...l($) });
  }
};
var UX = class extends p {
  get schema() {
    return this._def.getter();
  }
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X);
    return this._def.getter()._parse({ data: Q.data, path: Q.path, parent: Q });
  }
};
UX.create = (X, Q) => {
  return new UX({ getter: X, typeName: j.ZodLazy, ...l(Q) });
};
var VX = class extends p {
  _parse(X) {
    if (X.data !== this._def.value) {
      let Q = this._getOrReturnCtx(X);
      return b(Q, { received: Q.data, code: w.invalid_literal, expected: this._def.value }), g;
    }
    return { status: "valid", value: X.data };
  }
  get value() {
    return this._def.value;
  }
};
VX.create = (X, Q) => {
  return new VX({ value: X, typeName: j.ZodLiteral, ...l(Q) });
};
function NW(X, Q) {
  return new a1({ values: X, typeName: j.ZodEnum, ...l(Q) });
}
var a1 = class _a1 extends p {
  _parse(X) {
    if (typeof X.data !== "string") {
      let Q = this._getOrReturnCtx(X), $ = this._def.values;
      return b(Q, { expected: n.joinValues($), received: Q.parsedType, code: w.invalid_type }), g;
    }
    if (!this._cache) this._cache = new Set(this._def.values);
    if (!this._cache.has(X.data)) {
      let Q = this._getOrReturnCtx(X), $ = this._def.values;
      return b(Q, { received: Q.data, code: w.invalid_enum_value, options: $ }), g;
    }
    return C0(X.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    let X = {};
    for (let Q of this._def.values) X[Q] = Q;
    return X;
  }
  get Values() {
    let X = {};
    for (let Q of this._def.values) X[Q] = Q;
    return X;
  }
  get Enum() {
    let X = {};
    for (let Q of this._def.values) X[Q] = Q;
    return X;
  }
  extract(X, Q = this._def) {
    return _a1.create(X, { ...this._def, ...Q });
  }
  exclude(X, Q = this._def) {
    return _a1.create(this.options.filter(($) => !X.includes($)), { ...this._def, ...Q });
  }
};
a1.create = NW;
var LX = class extends p {
  _parse(X) {
    let Q = n.getValidEnumValues(this._def.values), $ = this._getOrReturnCtx(X);
    if ($.parsedType !== I.string && $.parsedType !== I.number) {
      let Y = n.objectValues(Q);
      return b($, { expected: n.joinValues(Y), received: $.parsedType, code: w.invalid_type }), g;
    }
    if (!this._cache) this._cache = new Set(n.getValidEnumValues(this._def.values));
    if (!this._cache.has(X.data)) {
      let Y = n.objectValues(Q);
      return b($, { received: $.data, code: w.invalid_enum_value, options: Y }), g;
    }
    return C0(X.data);
  }
  get enum() {
    return this._def.values;
  }
};
LX.create = (X, Q) => {
  return new LX({ values: X, typeName: j.ZodNativeEnum, ...l(Q) });
};
var S6 = class extends p {
  unwrap() {
    return this._def.type;
  }
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X);
    if (Q.parsedType !== I.promise && Q.common.async === false) return b(Q, { code: w.invalid_type, expected: I.promise, received: Q.parsedType }), g;
    let $ = Q.parsedType === I.promise ? Q.data : Promise.resolve(Q.data);
    return C0($.then((Y) => {
      return this._def.type.parseAsync(Y, { path: Q.path, errorMap: Q.common.contextualErrorMap });
    }));
  }
};
S6.create = (X, Q) => {
  return new S6({ type: X, typeName: j.ZodPromise, ...l(Q) });
};
var H1 = class extends p {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === j.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X), Y = this._def.effect || null, W = { addIssue: (J) => {
      if (b($, J), J.fatal) Q.abort();
      else Q.dirty();
    }, get path() {
      return $.path;
    } };
    if (W.addIssue = W.addIssue.bind(W), Y.type === "preprocess") {
      let J = Y.transform($.data, W);
      if ($.common.async) return Promise.resolve(J).then(async (G) => {
        if (Q.value === "aborted") return g;
        let H = await this._def.schema._parseAsync({ data: G, path: $.path, parent: $ });
        if (H.status === "aborted") return g;
        if (H.status === "dirty") return R6(H.value);
        if (Q.value === "dirty") return R6(H.value);
        return H;
      });
      else {
        if (Q.value === "aborted") return g;
        let G = this._def.schema._parseSync({ data: J, path: $.path, parent: $ });
        if (G.status === "aborted") return g;
        if (G.status === "dirty") return R6(G.value);
        if (Q.value === "dirty") return R6(G.value);
        return G;
      }
    }
    if (Y.type === "refinement") {
      let J = (G) => {
        let H = Y.refinement(G, W);
        if ($.common.async) return Promise.resolve(H);
        if (H instanceof Promise) throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return G;
      };
      if ($.common.async === false) {
        let G = this._def.schema._parseSync({ data: $.data, path: $.path, parent: $ });
        if (G.status === "aborted") return g;
        if (G.status === "dirty") Q.dirty();
        return J(G.value), { status: Q.value, value: G.value };
      } else return this._def.schema._parseAsync({ data: $.data, path: $.path, parent: $ }).then((G) => {
        if (G.status === "aborted") return g;
        if (G.status === "dirty") Q.dirty();
        return J(G.value).then(() => {
          return { status: Q.value, value: G.value };
        });
      });
    }
    if (Y.type === "transform") if ($.common.async === false) {
      let J = this._def.schema._parseSync({ data: $.data, path: $.path, parent: $ });
      if (!o1(J)) return g;
      let G = Y.transform(J.value, W);
      if (G instanceof Promise) throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
      return { status: Q.value, value: G };
    } else return this._def.schema._parseAsync({ data: $.data, path: $.path, parent: $ }).then((J) => {
      if (!o1(J)) return g;
      return Promise.resolve(Y.transform(J.value, W)).then((G) => ({ status: Q.value, value: G }));
    });
    n.assertNever(Y);
  }
};
H1.create = (X, Q, $) => {
  return new H1({ schema: X, typeName: j.ZodEffects, effect: Q, ...l($) });
};
H1.createWithPreprocess = (X, Q, $) => {
  return new H1({ schema: Q, effect: { type: "preprocess", transform: X }, typeName: j.ZodEffects, ...l($) });
};
var G1 = class extends p {
  _parse(X) {
    if (this._getType(X) === I.undefined) return C0(void 0);
    return this._def.innerType._parse(X);
  }
  unwrap() {
    return this._def.innerType;
  }
};
G1.create = (X, Q) => {
  return new G1({ innerType: X, typeName: j.ZodOptional, ...l(Q) });
};
var _1 = class extends p {
  _parse(X) {
    if (this._getType(X) === I.null) return C0(null);
    return this._def.innerType._parse(X);
  }
  unwrap() {
    return this._def.innerType;
  }
};
_1.create = (X, Q) => {
  return new _1({ innerType: X, typeName: j.ZodNullable, ...l(Q) });
};
var qX = class extends p {
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X), $ = Q.data;
    if (Q.parsedType === I.undefined) $ = this._def.defaultValue();
    return this._def.innerType._parse({ data: $, path: Q.path, parent: Q });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
qX.create = (X, Q) => {
  return new qX({ innerType: X, typeName: j.ZodDefault, defaultValue: typeof Q.default === "function" ? Q.default : () => Q.default, ...l(Q) });
};
var FX = class extends p {
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X), $ = { ...Q, common: { ...Q.common, issues: [] } }, Y = this._def.innerType._parse({ data: $.data, path: $.path, parent: { ...$ } });
    if (WX(Y)) return Y.then((W) => {
      return { status: "valid", value: W.status === "valid" ? W.value : this._def.catchValue({ get error() {
        return new h0($.common.issues);
      }, input: $.data }) };
    });
    else return { status: "valid", value: Y.status === "valid" ? Y.value : this._def.catchValue({ get error() {
      return new h0($.common.issues);
    }, input: $.data }) };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
FX.create = (X, Q) => {
  return new FX({ innerType: X, typeName: j.ZodCatch, catchValue: typeof Q.catch === "function" ? Q.catch : () => Q.catch, ...l(Q) });
};
var R4 = class extends p {
  _parse(X) {
    if (this._getType(X) !== I.nan) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: w.invalid_type, expected: I.nan, received: $.parsedType }), g;
    }
    return { status: "valid", value: X.data };
  }
};
R4.create = (X) => {
  return new R4({ typeName: j.ZodNaN, ...l(X) });
};
var D2 = Symbol("zod_brand");
var D9 = class extends p {
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X), $ = Q.data;
    return this._def.type._parse({ data: $, path: Q.path, parent: Q });
  }
  unwrap() {
    return this._def.type;
  }
};
var I4 = class _I4 extends p {
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X);
    if ($.common.async) return (async () => {
      let W = await this._def.in._parseAsync({ data: $.data, path: $.path, parent: $ });
      if (W.status === "aborted") return g;
      if (W.status === "dirty") return Q.dirty(), R6(W.value);
      else return this._def.out._parseAsync({ data: W.value, path: $.path, parent: $ });
    })();
    else {
      let Y = this._def.in._parseSync({ data: $.data, path: $.path, parent: $ });
      if (Y.status === "aborted") return g;
      if (Y.status === "dirty") return Q.dirty(), { status: "dirty", value: Y.value };
      else return this._def.out._parseSync({ data: Y.value, path: $.path, parent: $ });
    }
  }
  static create(X, Q) {
    return new _I4({ in: X, out: Q, typeName: j.ZodPipeline });
  }
};
var NX = class extends p {
  _parse(X) {
    let Q = this._def.innerType._parse(X), $ = (Y) => {
      if (o1(Y)) Y.value = Object.freeze(Y.value);
      return Y;
    };
    return WX(Q) ? Q.then((Y) => $(Y)) : $(Q);
  }
  unwrap() {
    return this._def.innerType;
  }
};
NX.create = (X, Q) => {
  return new NX({ innerType: X, typeName: j.ZodReadonly, ...l(Q) });
};
var A2 = { object: V0.lazycreate };
var j;
(function(X) {
  X.ZodString = "ZodString", X.ZodNumber = "ZodNumber", X.ZodNaN = "ZodNaN", X.ZodBigInt = "ZodBigInt", X.ZodBoolean = "ZodBoolean", X.ZodDate = "ZodDate", X.ZodSymbol = "ZodSymbol", X.ZodUndefined = "ZodUndefined", X.ZodNull = "ZodNull", X.ZodAny = "ZodAny", X.ZodUnknown = "ZodUnknown", X.ZodNever = "ZodNever", X.ZodVoid = "ZodVoid", X.ZodArray = "ZodArray", X.ZodObject = "ZodObject", X.ZodUnion = "ZodUnion", X.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", X.ZodIntersection = "ZodIntersection", X.ZodTuple = "ZodTuple", X.ZodRecord = "ZodRecord", X.ZodMap = "ZodMap", X.ZodSet = "ZodSet", X.ZodFunction = "ZodFunction", X.ZodLazy = "ZodLazy", X.ZodLiteral = "ZodLiteral", X.ZodEnum = "ZodEnum", X.ZodEffects = "ZodEffects", X.ZodNativeEnum = "ZodNativeEnum", X.ZodOptional = "ZodOptional", X.ZodNullable = "ZodNullable", X.ZodDefault = "ZodDefault", X.ZodCatch = "ZodCatch", X.ZodPromise = "ZodPromise", X.ZodBranded = "ZodBranded", X.ZodPipeline = "ZodPipeline", X.ZodReadonly = "ZodReadonly";
})(j || (j = {}));
var w2 = A1.create;
var M2 = E6.create;
var j2 = R4.create;
var R2 = b6.create;
var I2 = O4.create;
var E2 = GX.create;
var b2 = D4.create;
var P2 = HX.create;
var S2 = BX.create;
var Z2 = A4.create;
var C2 = t1.create;
var k2 = w1.create;
var v2 = w4.create;
var T2 = J1.create;
var OW = V0.create;
var _2 = V0.strictCreate;
var x2 = zX.create;
var y2 = O9.create;
var g2 = KX.create;
var f2 = M1.create;
var h2 = M4.create;
var u2 = j4.create;
var l2 = P6.create;
var m2 = JX.create;
var c2 = UX.create;
var p2 = VX.create;
var d2 = a1.create;
var i2 = LX.create;
var n2 = S6.create;
var r2 = H1.create;
var o2 = G1.create;
var t2 = _1.create;
var a2 = H1.createWithPreprocess;
var s2 = I4.create;
var bV = Object.freeze({ status: "aborted" });
function O(X, Q, $) {
  function Y(H, B) {
    var z;
    Object.defineProperty(H, "_zod", { value: H._zod ?? {}, enumerable: false }), (z = H._zod).traits ?? (z.traits = /* @__PURE__ */ new Set()), H._zod.traits.add(X), Q(H, B);
    for (let K in G.prototype) if (!(K in H)) Object.defineProperty(H, K, { value: G.prototype[K].bind(H) });
    H._zod.constr = G, H._zod.def = B;
  }
  let W = $?.Parent ?? Object;
  class J extends W {
  }
  Object.defineProperty(J, "name", { value: X });
  function G(H) {
    var B;
    let z = $?.Parent ? new J() : this;
    Y(z, H), (B = z._zod).deferred ?? (B.deferred = []);
    for (let K of z._zod.deferred) K();
    return z;
  }
  return Object.defineProperty(G, "init", { value: Y }), Object.defineProperty(G, Symbol.hasInstance, { value: (H) => {
    if ($?.Parent && H instanceof $.Parent) return true;
    return H?._zod?.traits?.has(X);
  } }), Object.defineProperty(G, "name", { value: X }), G;
}
var PV = Symbol("zod_brand");
var x1 = class extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
};
var E4 = {};
function u0(X) {
  if (X) Object.assign(E4, X);
  return E4;
}
var i = {};
U7(i, { unwrapMessage: () => OX, stringifyPrimitive: () => S4, required: () => pV, randomString: () => xV, propertyKeyTypes: () => I9, promiseAllObject: () => _V, primitiveTypes: () => DW, prefixIssues: () => B1, pick: () => hV, partial: () => cV, optionalKeys: () => E9, omit: () => uV, numKeys: () => yV, nullish: () => wX, normalizeParams: () => y, merge: () => mV, jsonStringifyReplacer: () => w9, joinValues: () => b4, issue: () => P9, isPlainObject: () => C6, isObject: () => Z6, getSizableOrigin: () => wW, getParsedType: () => gV, getLengthableOrigin: () => jX, getEnumValues: () => DX, getElementAtPath: () => TV, floatSafeRemainder: () => M9, finalizeIssue: () => o0, extend: () => lV, escapeRegex: () => y1, esc: () => s1, defineLazy: () => Y0, createTransparentProxy: () => fV, clone: () => l0, cleanRegex: () => MX, cleanEnum: () => dV, captureStackTrace: () => P4, cached: () => AX, assignProp: () => j9, assertNotEqual: () => ZV, assertNever: () => kV, assertIs: () => CV, assertEqual: () => SV, assert: () => vV, allowsEval: () => R9, aborted: () => e1, NUMBER_FORMAT_RANGES: () => b9, Class: () => MW, BIGINT_FORMAT_RANGES: () => AW });
function SV(X) {
  return X;
}
function ZV(X) {
  return X;
}
function CV(X) {
}
function kV(X) {
  throw Error();
}
function vV(X) {
}
function DX(X) {
  let Q = Object.values(X).filter((Y) => typeof Y === "number");
  return Object.entries(X).filter(([Y, W]) => Q.indexOf(+Y) === -1).map(([Y, W]) => W);
}
function b4(X, Q = "|") {
  return X.map(($) => S4($)).join(Q);
}
function w9(X, Q) {
  if (typeof Q === "bigint") return Q.toString();
  return Q;
}
function AX(X) {
  return { get value() {
    {
      let $ = X();
      return Object.defineProperty(this, "value", { value: $ }), $;
    }
    throw Error("cached value already set");
  } };
}
function wX(X) {
  return X === null || X === void 0;
}
function MX(X) {
  let Q = X.startsWith("^") ? 1 : 0, $ = X.endsWith("$") ? X.length - 1 : X.length;
  return X.slice(Q, $);
}
function M9(X, Q) {
  let $ = (X.toString().split(".")[1] || "").length, Y = (Q.toString().split(".")[1] || "").length, W = $ > Y ? $ : Y, J = Number.parseInt(X.toFixed(W).replace(".", "")), G = Number.parseInt(Q.toFixed(W).replace(".", ""));
  return J % G / 10 ** W;
}
function Y0(X, Q, $) {
  Object.defineProperty(X, Q, { get() {
    {
      let W = $();
      return X[Q] = W, W;
    }
    throw Error("cached value already set");
  }, set(W) {
    Object.defineProperty(X, Q, { value: W });
  }, configurable: true });
}
function j9(X, Q, $) {
  Object.defineProperty(X, Q, { value: $, writable: true, enumerable: true, configurable: true });
}
function TV(X, Q) {
  if (!Q) return X;
  return Q.reduce(($, Y) => $?.[Y], X);
}
function _V(X) {
  let Q = Object.keys(X), $ = Q.map((Y) => X[Y]);
  return Promise.all($).then((Y) => {
    let W = {};
    for (let J = 0; J < Q.length; J++) W[Q[J]] = Y[J];
    return W;
  });
}
function xV(X = 10) {
  let $ = "";
  for (let Y = 0; Y < X; Y++) $ += "abcdefghijklmnopqrstuvwxyz"[Math.floor(Math.random() * 26)];
  return $;
}
function s1(X) {
  return JSON.stringify(X);
}
var P4 = Error.captureStackTrace ? Error.captureStackTrace : (...X) => {
};
function Z6(X) {
  return typeof X === "object" && X !== null && !Array.isArray(X);
}
var R9 = AX(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare")) return false;
  try {
    return new Function(""), true;
  } catch (X) {
    return false;
  }
});
function C6(X) {
  if (Z6(X) === false) return false;
  let Q = X.constructor;
  if (Q === void 0) return true;
  let $ = Q.prototype;
  if (Z6($) === false) return false;
  if (Object.prototype.hasOwnProperty.call($, "isPrototypeOf") === false) return false;
  return true;
}
function yV(X) {
  let Q = 0;
  for (let $ in X) if (Object.prototype.hasOwnProperty.call(X, $)) Q++;
  return Q;
}
var gV = (X) => {
  let Q = typeof X;
  switch (Q) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(X) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(X)) return "array";
      if (X === null) return "null";
      if (X.then && typeof X.then === "function" && X.catch && typeof X.catch === "function") return "promise";
      if (typeof Map < "u" && X instanceof Map) return "map";
      if (typeof Set < "u" && X instanceof Set) return "set";
      if (typeof Date < "u" && X instanceof Date) return "date";
      if (typeof File < "u" && X instanceof File) return "file";
      return "object";
    default:
      throw Error(`Unknown data type: ${Q}`);
  }
};
var I9 = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var DW = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function y1(X) {
  return X.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function l0(X, Q, $) {
  let Y = new X._zod.constr(Q ?? X._zod.def);
  if (!Q || $?.parent) Y._zod.parent = X;
  return Y;
}
function y(X) {
  let Q = X;
  if (!Q) return {};
  if (typeof Q === "string") return { error: () => Q };
  if (Q?.message !== void 0) {
    if (Q?.error !== void 0) throw Error("Cannot specify both `message` and `error` params");
    Q.error = Q.message;
  }
  if (delete Q.message, typeof Q.error === "string") return { ...Q, error: () => Q.error };
  return Q;
}
function fV(X) {
  let Q;
  return new Proxy({}, { get($, Y, W) {
    return Q ?? (Q = X()), Reflect.get(Q, Y, W);
  }, set($, Y, W, J) {
    return Q ?? (Q = X()), Reflect.set(Q, Y, W, J);
  }, has($, Y) {
    return Q ?? (Q = X()), Reflect.has(Q, Y);
  }, deleteProperty($, Y) {
    return Q ?? (Q = X()), Reflect.deleteProperty(Q, Y);
  }, ownKeys($) {
    return Q ?? (Q = X()), Reflect.ownKeys(Q);
  }, getOwnPropertyDescriptor($, Y) {
    return Q ?? (Q = X()), Reflect.getOwnPropertyDescriptor(Q, Y);
  }, defineProperty($, Y, W) {
    return Q ?? (Q = X()), Reflect.defineProperty(Q, Y, W);
  } });
}
function S4(X) {
  if (typeof X === "bigint") return X.toString() + "n";
  if (typeof X === "string") return `"${X}"`;
  return `${X}`;
}
function E9(X) {
  return Object.keys(X).filter((Q) => {
    return X[Q]._zod.optin === "optional" && X[Q]._zod.optout === "optional";
  });
}
var b9 = { safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], int32: [-2147483648, 2147483647], uint32: [0, 4294967295], float32: [-34028234663852886e22, 34028234663852886e22], float64: [-Number.MAX_VALUE, Number.MAX_VALUE] };
var AW = { int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")], uint64: [BigInt(0), BigInt("18446744073709551615")] };
function hV(X, Q) {
  let $ = {}, Y = X._zod.def;
  for (let W in Q) {
    if (!(W in Y.shape)) throw Error(`Unrecognized key: "${W}"`);
    if (!Q[W]) continue;
    $[W] = Y.shape[W];
  }
  return l0(X, { ...X._zod.def, shape: $, checks: [] });
}
function uV(X, Q) {
  let $ = { ...X._zod.def.shape }, Y = X._zod.def;
  for (let W in Q) {
    if (!(W in Y.shape)) throw Error(`Unrecognized key: "${W}"`);
    if (!Q[W]) continue;
    delete $[W];
  }
  return l0(X, { ...X._zod.def, shape: $, checks: [] });
}
function lV(X, Q) {
  if (!C6(Q)) throw Error("Invalid input to extend: expected a plain object");
  let $ = { ...X._zod.def, get shape() {
    let Y = { ...X._zod.def.shape, ...Q };
    return j9(this, "shape", Y), Y;
  }, checks: [] };
  return l0(X, $);
}
function mV(X, Q) {
  return l0(X, { ...X._zod.def, get shape() {
    let $ = { ...X._zod.def.shape, ...Q._zod.def.shape };
    return j9(this, "shape", $), $;
  }, catchall: Q._zod.def.catchall, checks: [] });
}
function cV(X, Q, $) {
  let Y = Q._zod.def.shape, W = { ...Y };
  if ($) for (let J in $) {
    if (!(J in Y)) throw Error(`Unrecognized key: "${J}"`);
    if (!$[J]) continue;
    W[J] = X ? new X({ type: "optional", innerType: Y[J] }) : Y[J];
  }
  else for (let J in Y) W[J] = X ? new X({ type: "optional", innerType: Y[J] }) : Y[J];
  return l0(Q, { ...Q._zod.def, shape: W, checks: [] });
}
function pV(X, Q, $) {
  let Y = Q._zod.def.shape, W = { ...Y };
  if ($) for (let J in $) {
    if (!(J in W)) throw Error(`Unrecognized key: "${J}"`);
    if (!$[J]) continue;
    W[J] = new X({ type: "nonoptional", innerType: Y[J] });
  }
  else for (let J in Y) W[J] = new X({ type: "nonoptional", innerType: Y[J] });
  return l0(Q, { ...Q._zod.def, shape: W, checks: [] });
}
function e1(X, Q = 0) {
  for (let $ = Q; $ < X.issues.length; $++) if (X.issues[$]?.continue !== true) return true;
  return false;
}
function B1(X, Q) {
  return Q.map(($) => {
    var Y;
    return (Y = $).path ?? (Y.path = []), $.path.unshift(X), $;
  });
}
function OX(X) {
  return typeof X === "string" ? X : X?.message;
}
function o0(X, Q, $) {
  let Y = { ...X, path: X.path ?? [] };
  if (!X.message) {
    let W = OX(X.inst?._zod.def?.error?.(X)) ?? OX(Q?.error?.(X)) ?? OX($.customError?.(X)) ?? OX($.localeError?.(X)) ?? "Invalid input";
    Y.message = W;
  }
  if (delete Y.inst, delete Y.continue, !Q?.reportInput) delete Y.input;
  return Y;
}
function wW(X) {
  if (X instanceof Set) return "set";
  if (X instanceof Map) return "map";
  if (X instanceof File) return "file";
  return "unknown";
}
function jX(X) {
  if (Array.isArray(X)) return "array";
  if (typeof X === "string") return "string";
  return "unknown";
}
function P9(...X) {
  let [Q, $, Y] = X;
  if (typeof Q === "string") return { message: Q, code: "custom", input: $, inst: Y };
  return { ...Q };
}
function dV(X) {
  return Object.entries(X).filter(([Q, $]) => {
    return Number.isNaN(Number.parseInt(Q, 10));
  }).map((Q) => Q[1]);
}
var MW = class {
  constructor(...X) {
  }
};
var jW = (X, Q) => {
  X.name = "$ZodError", Object.defineProperty(X, "_zod", { value: X._zod, enumerable: false }), Object.defineProperty(X, "issues", { value: Q, enumerable: false }), Object.defineProperty(X, "message", { get() {
    return JSON.stringify(Q, w9, 2);
  }, enumerable: true });
};
var Z4 = O("$ZodError", jW);
var RX = O("$ZodError", jW, { Parent: Error });
function S9(X, Q = ($) => $.message) {
  let $ = {}, Y = [];
  for (let W of X.issues) if (W.path.length > 0) $[W.path[0]] = $[W.path[0]] || [], $[W.path[0]].push(Q(W));
  else Y.push(Q(W));
  return { formErrors: Y, fieldErrors: $ };
}
function Z9(X, Q) {
  let $ = Q || function(J) {
    return J.message;
  }, Y = { _errors: [] }, W = (J) => {
    for (let G of J.issues) if (G.code === "invalid_union" && G.errors.length) G.errors.map((H) => W({ issues: H }));
    else if (G.code === "invalid_key") W({ issues: G.issues });
    else if (G.code === "invalid_element") W({ issues: G.issues });
    else if (G.path.length === 0) Y._errors.push($(G));
    else {
      let H = Y, B = 0;
      while (B < G.path.length) {
        let z = G.path[B];
        if (B !== G.path.length - 1) H[z] = H[z] || { _errors: [] };
        else H[z] = H[z] || { _errors: [] }, H[z]._errors.push($(G));
        H = H[z], B++;
      }
    }
  };
  return W(X), Y;
}
var C9 = (X) => (Q, $, Y, W) => {
  let J = Y ? Object.assign(Y, { async: false }) : { async: false }, G = Q._zod.run({ value: $, issues: [] }, J);
  if (G instanceof Promise) throw new x1();
  if (G.issues.length) {
    let H = new (W?.Err ?? X)(G.issues.map((B) => o0(B, J, u0())));
    throw P4(H, W?.callee), H;
  }
  return G.value;
};
var k9 = C9(RX);
var v9 = (X) => async (Q, $, Y, W) => {
  let J = Y ? Object.assign(Y, { async: true }) : { async: true }, G = Q._zod.run({ value: $, issues: [] }, J);
  if (G instanceof Promise) G = await G;
  if (G.issues.length) {
    let H = new (W?.Err ?? X)(G.issues.map((B) => o0(B, J, u0())));
    throw P4(H, W?.callee), H;
  }
  return G.value;
};
var T9 = v9(RX);
var _9 = (X) => (Q, $, Y) => {
  let W = Y ? { ...Y, async: false } : { async: false }, J = Q._zod.run({ value: $, issues: [] }, W);
  if (J instanceof Promise) throw new x1();
  return J.issues.length ? { success: false, error: new (X ?? Z4)(J.issues.map((G) => o0(G, W, u0()))) } : { success: true, data: J.value };
};
var X6 = _9(RX);
var x9 = (X) => async (Q, $, Y) => {
  let W = Y ? Object.assign(Y, { async: true }) : { async: true }, J = Q._zod.run({ value: $, issues: [] }, W);
  if (J instanceof Promise) J = await J;
  return J.issues.length ? { success: false, error: new X(J.issues.map((G) => o0(G, W, u0()))) } : { success: true, data: J.value };
};
var Q6 = x9(RX);
var RW = /^[cC][^\s-]{8,}$/;
var IW = /^[0-9a-z]+$/;
var EW = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var bW = /^[0-9a-vA-V]{20}$/;
var PW = /^[A-Za-z0-9]{27}$/;
var SW = /^[a-zA-Z0-9_-]{21}$/;
var ZW = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var CW = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var y9 = (X) => {
  if (!X) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${X}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var kW = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
function vW() {
  return new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
}
var TW = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var _W = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var xW = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var yW = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var gW = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var g9 = /^[A-Za-z0-9_-]*$/;
var fW = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var hW = /^\+(?:[0-9]){6,14}[0-9]$/;
var uW = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))";
var lW = new RegExp(`^${uW}$`);
function mW(X) {
  return typeof X.precision === "number" ? X.precision === -1 ? "(?:[01]\\d|2[0-3]):[0-5]\\d" : X.precision === 0 ? "(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d" : `(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d\\.\\d{${X.precision}}` : "(?:[01]\\d|2[0-3]):[0-5]\\d(?::[0-5]\\d(?:\\.\\d+)?)?";
}
function cW(X) {
  return new RegExp(`^${mW(X)}$`);
}
function pW(X) {
  let Q = mW({ precision: X.precision }), $ = ["Z"];
  if (X.local) $.push("");
  if (X.offset) $.push("([+-]\\d{2}:\\d{2})");
  let Y = `${Q}(?:${$.join("|")})`;
  return new RegExp(`^${uW}T(?:${Y})$`);
}
var dW = (X) => {
  let Q = X ? `[\\s\\S]{${X?.minimum ?? 0},${X?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${Q}$`);
};
var iW = /^\d+$/;
var nW = /^-?\d+(?:\.\d+)?/i;
var rW = /true|false/i;
var oW = /null/i;
var tW = /^[^A-Z]*$/;
var aW = /^[^a-z]*$/;
var w0 = O("$ZodCheck", (X, Q) => {
  var $;
  X._zod ?? (X._zod = {}), X._zod.def = Q, ($ = X._zod).onattach ?? ($.onattach = []);
});
var sW = { number: "number", bigint: "bigint", object: "date" };
var f9 = O("$ZodCheckLessThan", (X, Q) => {
  w0.init(X, Q);
  let $ = sW[typeof Q.value];
  X._zod.onattach.push((Y) => {
    let W = Y._zod.bag, J = (Q.inclusive ? W.maximum : W.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (Q.value < J) if (Q.inclusive) W.maximum = Q.value;
    else W.exclusiveMaximum = Q.value;
  }), X._zod.check = (Y) => {
    if (Q.inclusive ? Y.value <= Q.value : Y.value < Q.value) return;
    Y.issues.push({ origin: $, code: "too_big", maximum: Q.value, input: Y.value, inclusive: Q.inclusive, inst: X, continue: !Q.abort });
  };
});
var h9 = O("$ZodCheckGreaterThan", (X, Q) => {
  w0.init(X, Q);
  let $ = sW[typeof Q.value];
  X._zod.onattach.push((Y) => {
    let W = Y._zod.bag, J = (Q.inclusive ? W.minimum : W.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (Q.value > J) if (Q.inclusive) W.minimum = Q.value;
    else W.exclusiveMinimum = Q.value;
  }), X._zod.check = (Y) => {
    if (Q.inclusive ? Y.value >= Q.value : Y.value > Q.value) return;
    Y.issues.push({ origin: $, code: "too_small", minimum: Q.value, input: Y.value, inclusive: Q.inclusive, inst: X, continue: !Q.abort });
  };
});
var eW = O("$ZodCheckMultipleOf", (X, Q) => {
  w0.init(X, Q), X._zod.onattach.push(($) => {
    var Y;
    (Y = $._zod.bag).multipleOf ?? (Y.multipleOf = Q.value);
  }), X._zod.check = ($) => {
    if (typeof $.value !== typeof Q.value) throw Error("Cannot mix number and bigint in multiple_of check.");
    if (typeof $.value === "bigint" ? $.value % Q.value === BigInt(0) : M9($.value, Q.value) === 0) return;
    $.issues.push({ origin: typeof $.value, code: "not_multiple_of", divisor: Q.value, input: $.value, inst: X, continue: !Q.abort });
  };
});
var XJ = O("$ZodCheckNumberFormat", (X, Q) => {
  w0.init(X, Q), Q.format = Q.format || "float64";
  let $ = Q.format?.includes("int"), Y = $ ? "int" : "number", [W, J] = b9[Q.format];
  X._zod.onattach.push((G) => {
    let H = G._zod.bag;
    if (H.format = Q.format, H.minimum = W, H.maximum = J, $) H.pattern = iW;
  }), X._zod.check = (G) => {
    let H = G.value;
    if ($) {
      if (!Number.isInteger(H)) {
        G.issues.push({ expected: Y, format: Q.format, code: "invalid_type", input: H, inst: X });
        return;
      }
      if (!Number.isSafeInteger(H)) {
        if (H > 0) G.issues.push({ input: H, code: "too_big", maximum: Number.MAX_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: X, origin: Y, continue: !Q.abort });
        else G.issues.push({ input: H, code: "too_small", minimum: Number.MIN_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: X, origin: Y, continue: !Q.abort });
        return;
      }
    }
    if (H < W) G.issues.push({ origin: "number", input: H, code: "too_small", minimum: W, inclusive: true, inst: X, continue: !Q.abort });
    if (H > J) G.issues.push({ origin: "number", input: H, code: "too_big", maximum: J, inst: X });
  };
});
var QJ = O("$ZodCheckMaxLength", (X, Q) => {
  w0.init(X, Q), X._zod.when = ($) => {
    let Y = $.value;
    return !wX(Y) && Y.length !== void 0;
  }, X._zod.onattach.push(($) => {
    let Y = $._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (Q.maximum < Y) $._zod.bag.maximum = Q.maximum;
  }), X._zod.check = ($) => {
    let Y = $.value;
    if (Y.length <= Q.maximum) return;
    let J = jX(Y);
    $.issues.push({ origin: J, code: "too_big", maximum: Q.maximum, inclusive: true, input: Y, inst: X, continue: !Q.abort });
  };
});
var $J = O("$ZodCheckMinLength", (X, Q) => {
  w0.init(X, Q), X._zod.when = ($) => {
    let Y = $.value;
    return !wX(Y) && Y.length !== void 0;
  }, X._zod.onattach.push(($) => {
    let Y = $._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (Q.minimum > Y) $._zod.bag.minimum = Q.minimum;
  }), X._zod.check = ($) => {
    let Y = $.value;
    if (Y.length >= Q.minimum) return;
    let J = jX(Y);
    $.issues.push({ origin: J, code: "too_small", minimum: Q.minimum, inclusive: true, input: Y, inst: X, continue: !Q.abort });
  };
});
var YJ = O("$ZodCheckLengthEquals", (X, Q) => {
  w0.init(X, Q), X._zod.when = ($) => {
    let Y = $.value;
    return !wX(Y) && Y.length !== void 0;
  }, X._zod.onattach.push(($) => {
    let Y = $._zod.bag;
    Y.minimum = Q.length, Y.maximum = Q.length, Y.length = Q.length;
  }), X._zod.check = ($) => {
    let Y = $.value, W = Y.length;
    if (W === Q.length) return;
    let J = jX(Y), G = W > Q.length;
    $.issues.push({ origin: J, ...G ? { code: "too_big", maximum: Q.length } : { code: "too_small", minimum: Q.length }, inclusive: true, exact: true, input: $.value, inst: X, continue: !Q.abort });
  };
});
var IX = O("$ZodCheckStringFormat", (X, Q) => {
  var $, Y;
  if (w0.init(X, Q), X._zod.onattach.push((W) => {
    let J = W._zod.bag;
    if (J.format = Q.format, Q.pattern) J.patterns ?? (J.patterns = /* @__PURE__ */ new Set()), J.patterns.add(Q.pattern);
  }), Q.pattern) ($ = X._zod).check ?? ($.check = (W) => {
    if (Q.pattern.lastIndex = 0, Q.pattern.test(W.value)) return;
    W.issues.push({ origin: "string", code: "invalid_format", format: Q.format, input: W.value, ...Q.pattern ? { pattern: Q.pattern.toString() } : {}, inst: X, continue: !Q.abort });
  });
  else (Y = X._zod).check ?? (Y.check = () => {
  });
});
var WJ = O("$ZodCheckRegex", (X, Q) => {
  IX.init(X, Q), X._zod.check = ($) => {
    if (Q.pattern.lastIndex = 0, Q.pattern.test($.value)) return;
    $.issues.push({ origin: "string", code: "invalid_format", format: "regex", input: $.value, pattern: Q.pattern.toString(), inst: X, continue: !Q.abort });
  };
});
var JJ = O("$ZodCheckLowerCase", (X, Q) => {
  Q.pattern ?? (Q.pattern = tW), IX.init(X, Q);
});
var GJ = O("$ZodCheckUpperCase", (X, Q) => {
  Q.pattern ?? (Q.pattern = aW), IX.init(X, Q);
});
var HJ = O("$ZodCheckIncludes", (X, Q) => {
  w0.init(X, Q);
  let $ = y1(Q.includes), Y = new RegExp(typeof Q.position === "number" ? `^.{${Q.position}}${$}` : $);
  Q.pattern = Y, X._zod.onattach.push((W) => {
    let J = W._zod.bag;
    J.patterns ?? (J.patterns = /* @__PURE__ */ new Set()), J.patterns.add(Y);
  }), X._zod.check = (W) => {
    if (W.value.includes(Q.includes, Q.position)) return;
    W.issues.push({ origin: "string", code: "invalid_format", format: "includes", includes: Q.includes, input: W.value, inst: X, continue: !Q.abort });
  };
});
var BJ = O("$ZodCheckStartsWith", (X, Q) => {
  w0.init(X, Q);
  let $ = new RegExp(`^${y1(Q.prefix)}.*`);
  Q.pattern ?? (Q.pattern = $), X._zod.onattach.push((Y) => {
    let W = Y._zod.bag;
    W.patterns ?? (W.patterns = /* @__PURE__ */ new Set()), W.patterns.add($);
  }), X._zod.check = (Y) => {
    if (Y.value.startsWith(Q.prefix)) return;
    Y.issues.push({ origin: "string", code: "invalid_format", format: "starts_with", prefix: Q.prefix, input: Y.value, inst: X, continue: !Q.abort });
  };
});
var zJ = O("$ZodCheckEndsWith", (X, Q) => {
  w0.init(X, Q);
  let $ = new RegExp(`.*${y1(Q.suffix)}$`);
  Q.pattern ?? (Q.pattern = $), X._zod.onattach.push((Y) => {
    let W = Y._zod.bag;
    W.patterns ?? (W.patterns = /* @__PURE__ */ new Set()), W.patterns.add($);
  }), X._zod.check = (Y) => {
    if (Y.value.endsWith(Q.suffix)) return;
    Y.issues.push({ origin: "string", code: "invalid_format", format: "ends_with", suffix: Q.suffix, input: Y.value, inst: X, continue: !Q.abort });
  };
});
var KJ = O("$ZodCheckOverwrite", (X, Q) => {
  w0.init(X, Q), X._zod.check = ($) => {
    $.value = Q.tx($.value);
  };
});
var u9 = class {
  constructor(X = []) {
    if (this.content = [], this.indent = 0, this) this.args = X;
  }
  indented(X) {
    this.indent += 1, X(this), this.indent -= 1;
  }
  write(X) {
    if (typeof X === "function") {
      X(this, { execution: "sync" }), X(this, { execution: "async" });
      return;
    }
    let $ = X.split(`
`).filter((J) => J), Y = Math.min(...$.map((J) => J.length - J.trimStart().length)), W = $.map((J) => J.slice(Y)).map((J) => " ".repeat(this.indent * 2) + J);
    for (let J of W) this.content.push(J);
  }
  compile() {
    let X = Function, Q = this?.args, Y = [...(this?.content ?? [""]).map((W) => `  ${W}`)];
    return new X(...Q, Y.join(`
`));
  }
};
var VJ = { major: 4, minor: 0, patch: 0 };
var X0 = O("$ZodType", (X, Q) => {
  var $;
  X ?? (X = {}), X._zod.def = Q, X._zod.bag = X._zod.bag || {}, X._zod.version = VJ;
  let Y = [...X._zod.def.checks ?? []];
  if (X._zod.traits.has("$ZodCheck")) Y.unshift(X);
  for (let W of Y) for (let J of W._zod.onattach) J(X);
  if (Y.length === 0) ($ = X._zod).deferred ?? ($.deferred = []), X._zod.deferred?.push(() => {
    X._zod.run = X._zod.parse;
  });
  else {
    let W = (J, G, H) => {
      let B = e1(J), z;
      for (let K of G) {
        if (K._zod.when) {
          if (!K._zod.when(J)) continue;
        } else if (B) continue;
        let V = J.issues.length, L = K._zod.check(J);
        if (L instanceof Promise && H?.async === false) throw new x1();
        if (z || L instanceof Promise) z = (z ?? Promise.resolve()).then(async () => {
          if (await L, J.issues.length === V) return;
          if (!B) B = e1(J, V);
        });
        else {
          if (J.issues.length === V) continue;
          if (!B) B = e1(J, V);
        }
      }
      if (z) return z.then(() => {
        return J;
      });
      return J;
    };
    X._zod.run = (J, G) => {
      let H = X._zod.parse(J, G);
      if (H instanceof Promise) {
        if (G.async === false) throw new x1();
        return H.then((B) => W(B, Y, G));
      }
      return W(H, Y, G);
    };
  }
  X["~standard"] = { validate: (W) => {
    try {
      let J = X6(X, W);
      return J.success ? { value: J.data } : { issues: J.error?.issues };
    } catch (J) {
      return Q6(X, W).then((G) => G.success ? { value: G.data } : { issues: G.error?.issues });
    }
  }, vendor: "zod", version: 1 };
});
var EX = O("$ZodString", (X, Q) => {
  X0.init(X, Q), X._zod.pattern = [...X?._zod.bag?.patterns ?? []].pop() ?? dW(X._zod.bag), X._zod.parse = ($, Y) => {
    if (Q.coerce) try {
      $.value = String($.value);
    } catch (W) {
    }
    if (typeof $.value === "string") return $;
    return $.issues.push({ expected: "string", code: "invalid_type", input: $.value, inst: X }), $;
  };
});
var W0 = O("$ZodStringFormat", (X, Q) => {
  IX.init(X, Q), EX.init(X, Q);
});
var m9 = O("$ZodGUID", (X, Q) => {
  Q.pattern ?? (Q.pattern = CW), W0.init(X, Q);
});
var c9 = O("$ZodUUID", (X, Q) => {
  if (Q.version) {
    let Y = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[Q.version];
    if (Y === void 0) throw Error(`Invalid UUID version: "${Q.version}"`);
    Q.pattern ?? (Q.pattern = y9(Y));
  } else Q.pattern ?? (Q.pattern = y9());
  W0.init(X, Q);
});
var p9 = O("$ZodEmail", (X, Q) => {
  Q.pattern ?? (Q.pattern = kW), W0.init(X, Q);
});
var d9 = O("$ZodURL", (X, Q) => {
  W0.init(X, Q), X._zod.check = ($) => {
    try {
      let Y = $.value, W = new URL(Y), J = W.href;
      if (Q.hostname) {
        if (Q.hostname.lastIndex = 0, !Q.hostname.test(W.hostname)) $.issues.push({ code: "invalid_format", format: "url", note: "Invalid hostname", pattern: fW.source, input: $.value, inst: X, continue: !Q.abort });
      }
      if (Q.protocol) {
        if (Q.protocol.lastIndex = 0, !Q.protocol.test(W.protocol.endsWith(":") ? W.protocol.slice(0, -1) : W.protocol)) $.issues.push({ code: "invalid_format", format: "url", note: "Invalid protocol", pattern: Q.protocol.source, input: $.value, inst: X, continue: !Q.abort });
      }
      if (!Y.endsWith("/") && J.endsWith("/")) $.value = J.slice(0, -1);
      else $.value = J;
      return;
    } catch (Y) {
      $.issues.push({ code: "invalid_format", format: "url", input: $.value, inst: X, continue: !Q.abort });
    }
  };
});
var i9 = O("$ZodEmoji", (X, Q) => {
  Q.pattern ?? (Q.pattern = vW()), W0.init(X, Q);
});
var n9 = O("$ZodNanoID", (X, Q) => {
  Q.pattern ?? (Q.pattern = SW), W0.init(X, Q);
});
var r9 = O("$ZodCUID", (X, Q) => {
  Q.pattern ?? (Q.pattern = RW), W0.init(X, Q);
});
var o9 = O("$ZodCUID2", (X, Q) => {
  Q.pattern ?? (Q.pattern = IW), W0.init(X, Q);
});
var t9 = O("$ZodULID", (X, Q) => {
  Q.pattern ?? (Q.pattern = EW), W0.init(X, Q);
});
var a9 = O("$ZodXID", (X, Q) => {
  Q.pattern ?? (Q.pattern = bW), W0.init(X, Q);
});
var s9 = O("$ZodKSUID", (X, Q) => {
  Q.pattern ?? (Q.pattern = PW), W0.init(X, Q);
});
var jJ = O("$ZodISODateTime", (X, Q) => {
  Q.pattern ?? (Q.pattern = pW(Q)), W0.init(X, Q);
});
var RJ = O("$ZodISODate", (X, Q) => {
  Q.pattern ?? (Q.pattern = lW), W0.init(X, Q);
});
var IJ = O("$ZodISOTime", (X, Q) => {
  Q.pattern ?? (Q.pattern = cW(Q)), W0.init(X, Q);
});
var EJ = O("$ZodISODuration", (X, Q) => {
  Q.pattern ?? (Q.pattern = ZW), W0.init(X, Q);
});
var e9 = O("$ZodIPv4", (X, Q) => {
  Q.pattern ?? (Q.pattern = TW), W0.init(X, Q), X._zod.onattach.push(($) => {
    let Y = $._zod.bag;
    Y.format = "ipv4";
  });
});
var XQ = O("$ZodIPv6", (X, Q) => {
  Q.pattern ?? (Q.pattern = _W), W0.init(X, Q), X._zod.onattach.push(($) => {
    let Y = $._zod.bag;
    Y.format = "ipv6";
  }), X._zod.check = ($) => {
    try {
      new URL(`http://[${$.value}]`);
    } catch {
      $.issues.push({ code: "invalid_format", format: "ipv6", input: $.value, inst: X, continue: !Q.abort });
    }
  };
});
var QQ = O("$ZodCIDRv4", (X, Q) => {
  Q.pattern ?? (Q.pattern = xW), W0.init(X, Q);
});
var $Q = O("$ZodCIDRv6", (X, Q) => {
  Q.pattern ?? (Q.pattern = yW), W0.init(X, Q), X._zod.check = ($) => {
    let [Y, W] = $.value.split("/");
    try {
      if (!W) throw Error();
      let J = Number(W);
      if (`${J}` !== W) throw Error();
      if (J < 0 || J > 128) throw Error();
      new URL(`http://[${Y}]`);
    } catch {
      $.issues.push({ code: "invalid_format", format: "cidrv6", input: $.value, inst: X, continue: !Q.abort });
    }
  };
});
function bJ(X) {
  if (X === "") return true;
  if (X.length % 4 !== 0) return false;
  try {
    return atob(X), true;
  } catch {
    return false;
  }
}
var YQ = O("$ZodBase64", (X, Q) => {
  Q.pattern ?? (Q.pattern = gW), W0.init(X, Q), X._zod.onattach.push(($) => {
    $._zod.bag.contentEncoding = "base64";
  }), X._zod.check = ($) => {
    if (bJ($.value)) return;
    $.issues.push({ code: "invalid_format", format: "base64", input: $.value, inst: X, continue: !Q.abort });
  };
});
function nV(X) {
  if (!g9.test(X)) return false;
  let Q = X.replace(/[-_]/g, (Y) => Y === "-" ? "+" : "/"), $ = Q.padEnd(Math.ceil(Q.length / 4) * 4, "=");
  return bJ($);
}
var WQ = O("$ZodBase64URL", (X, Q) => {
  Q.pattern ?? (Q.pattern = g9), W0.init(X, Q), X._zod.onattach.push(($) => {
    $._zod.bag.contentEncoding = "base64url";
  }), X._zod.check = ($) => {
    if (nV($.value)) return;
    $.issues.push({ code: "invalid_format", format: "base64url", input: $.value, inst: X, continue: !Q.abort });
  };
});
var JQ = O("$ZodE164", (X, Q) => {
  Q.pattern ?? (Q.pattern = hW), W0.init(X, Q);
});
function rV(X, Q = null) {
  try {
    let $ = X.split(".");
    if ($.length !== 3) return false;
    let [Y] = $;
    if (!Y) return false;
    let W = JSON.parse(atob(Y));
    if ("typ" in W && W?.typ !== "JWT") return false;
    if (!W.alg) return false;
    if (Q && (!("alg" in W) || W.alg !== Q)) return false;
    return true;
  } catch {
    return false;
  }
}
var GQ = O("$ZodJWT", (X, Q) => {
  W0.init(X, Q), X._zod.check = ($) => {
    if (rV($.value, Q.alg)) return;
    $.issues.push({ code: "invalid_format", format: "jwt", input: $.value, inst: X, continue: !Q.abort });
  };
});
var v4 = O("$ZodNumber", (X, Q) => {
  X0.init(X, Q), X._zod.pattern = X._zod.bag.pattern ?? nW, X._zod.parse = ($, Y) => {
    if (Q.coerce) try {
      $.value = Number($.value);
    } catch (G) {
    }
    let W = $.value;
    if (typeof W === "number" && !Number.isNaN(W) && Number.isFinite(W)) return $;
    let J = typeof W === "number" ? Number.isNaN(W) ? "NaN" : !Number.isFinite(W) ? "Infinity" : void 0 : void 0;
    return $.issues.push({ expected: "number", code: "invalid_type", input: W, inst: X, ...J ? { received: J } : {} }), $;
  };
});
var HQ = O("$ZodNumber", (X, Q) => {
  XJ.init(X, Q), v4.init(X, Q);
});
var BQ = O("$ZodBoolean", (X, Q) => {
  X0.init(X, Q), X._zod.pattern = rW, X._zod.parse = ($, Y) => {
    if (Q.coerce) try {
      $.value = Boolean($.value);
    } catch (J) {
    }
    let W = $.value;
    if (typeof W === "boolean") return $;
    return $.issues.push({ expected: "boolean", code: "invalid_type", input: W, inst: X }), $;
  };
});
var zQ = O("$ZodNull", (X, Q) => {
  X0.init(X, Q), X._zod.pattern = oW, X._zod.values = /* @__PURE__ */ new Set([null]), X._zod.parse = ($, Y) => {
    let W = $.value;
    if (W === null) return $;
    return $.issues.push({ expected: "null", code: "invalid_type", input: W, inst: X }), $;
  };
});
var KQ = O("$ZodUnknown", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($) => $;
});
var UQ = O("$ZodNever", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($, Y) => {
    return $.issues.push({ expected: "never", code: "invalid_type", input: $.value, inst: X }), $;
  };
});
function LJ(X, Q, $) {
  if (X.issues.length) Q.issues.push(...B1($, X.issues));
  Q.value[$] = X.value;
}
var VQ = O("$ZodArray", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($, Y) => {
    let W = $.value;
    if (!Array.isArray(W)) return $.issues.push({ expected: "array", code: "invalid_type", input: W, inst: X }), $;
    $.value = Array(W.length);
    let J = [];
    for (let G = 0; G < W.length; G++) {
      let H = W[G], B = Q.element._zod.run({ value: H, issues: [] }, Y);
      if (B instanceof Promise) J.push(B.then((z) => LJ(z, $, G)));
      else LJ(B, $, G);
    }
    if (J.length) return Promise.all(J).then(() => $);
    return $;
  };
});
function k4(X, Q, $) {
  if (X.issues.length) Q.issues.push(...B1($, X.issues));
  Q.value[$] = X.value;
}
function qJ(X, Q, $, Y) {
  if (X.issues.length) if (Y[$] === void 0) if ($ in Y) Q.value[$] = void 0;
  else Q.value[$] = X.value;
  else Q.issues.push(...B1($, X.issues));
  else if (X.value === void 0) {
    if ($ in Y) Q.value[$] = void 0;
  } else Q.value[$] = X.value;
}
var T4 = O("$ZodObject", (X, Q) => {
  X0.init(X, Q);
  let $ = AX(() => {
    let V = Object.keys(Q.shape);
    for (let U of V) if (!(Q.shape[U] instanceof X0)) throw Error(`Invalid element at key "${U}": expected a Zod schema`);
    let L = E9(Q.shape);
    return { shape: Q.shape, keys: V, keySet: new Set(V), numKeys: V.length, optionalKeys: new Set(L) };
  });
  Y0(X._zod, "propValues", () => {
    let V = Q.shape, L = {};
    for (let U in V) {
      let F = V[U]._zod;
      if (F.values) {
        L[U] ?? (L[U] = /* @__PURE__ */ new Set());
        for (let q of F.values) L[U].add(q);
      }
    }
    return L;
  });
  let Y = (V) => {
    let L = new u9(["shape", "payload", "ctx"]), U = $.value, F = (M) => {
      let R = s1(M);
      return `shape[${R}]._zod.run({ value: input[${R}], issues: [] }, ctx)`;
    };
    L.write("const input = payload.value;");
    let q = /* @__PURE__ */ Object.create(null), N = 0;
    for (let M of U.keys) q[M] = `key_${N++}`;
    L.write("const newResult = {}");
    for (let M of U.keys) if (U.optionalKeys.has(M)) {
      let R = q[M];
      L.write(`const ${R} = ${F(M)};`);
      let S = s1(M);
      L.write(`
        if (${R}.issues.length) {
          if (input[${S}] === undefined) {
            if (${S} in input) {
              newResult[${S}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${R}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${S}, ...iss.path] : [${S}],
              }))
            );
          }
        } else if (${R}.value === undefined) {
          if (${S} in input) newResult[${S}] = undefined;
        } else {
          newResult[${S}] = ${R}.value;
        }
        `);
    } else {
      let R = q[M];
      L.write(`const ${R} = ${F(M)};`), L.write(`
          if (${R}.issues.length) payload.issues = payload.issues.concat(${R}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${s1(M)}, ...iss.path] : [${s1(M)}]
          })));`), L.write(`newResult[${s1(M)}] = ${R}.value`);
    }
    L.write("payload.value = newResult;"), L.write("return payload;");
    let A = L.compile();
    return (M, R) => A(V, M, R);
  }, W, J = Z6, G = !E4.jitless, B = G && R9.value, z = Q.catchall, K;
  X._zod.parse = (V, L) => {
    K ?? (K = $.value);
    let U = V.value;
    if (!J(U)) return V.issues.push({ expected: "object", code: "invalid_type", input: U, inst: X }), V;
    let F = [];
    if (G && B && L?.async === false && L.jitless !== true) {
      if (!W) W = Y(Q.shape);
      V = W(V, L);
    } else {
      V.value = {};
      let R = K.shape;
      for (let S of K.keys) {
        let C = R[S], K0 = C._zod.run({ value: U[S], issues: [] }, L), U0 = C._zod.optin === "optional" && C._zod.optout === "optional";
        if (K0 instanceof Promise) F.push(K0.then((s) => U0 ? qJ(s, V, S, U) : k4(s, V, S)));
        else if (U0) qJ(K0, V, S, U);
        else k4(K0, V, S);
      }
    }
    if (!z) return F.length ? Promise.all(F).then(() => V) : V;
    let q = [], N = K.keySet, A = z._zod, M = A.def.type;
    for (let R of Object.keys(U)) {
      if (N.has(R)) continue;
      if (M === "never") {
        q.push(R);
        continue;
      }
      let S = A.run({ value: U[R], issues: [] }, L);
      if (S instanceof Promise) F.push(S.then((C) => k4(C, V, R)));
      else k4(S, V, R);
    }
    if (q.length) V.issues.push({ code: "unrecognized_keys", keys: q, input: U, inst: X });
    if (!F.length) return V;
    return Promise.all(F).then(() => {
      return V;
    });
  };
});
function FJ(X, Q, $, Y) {
  for (let W of X) if (W.issues.length === 0) return Q.value = W.value, Q;
  return Q.issues.push({ code: "invalid_union", input: Q.value, inst: $, errors: X.map((W) => W.issues.map((J) => o0(J, Y, u0()))) }), Q;
}
var _4 = O("$ZodUnion", (X, Q) => {
  X0.init(X, Q), Y0(X._zod, "optin", () => Q.options.some(($) => $._zod.optin === "optional") ? "optional" : void 0), Y0(X._zod, "optout", () => Q.options.some(($) => $._zod.optout === "optional") ? "optional" : void 0), Y0(X._zod, "values", () => {
    if (Q.options.every(($) => $._zod.values)) return new Set(Q.options.flatMap(($) => Array.from($._zod.values)));
    return;
  }), Y0(X._zod, "pattern", () => {
    if (Q.options.every(($) => $._zod.pattern)) {
      let $ = Q.options.map((Y) => Y._zod.pattern);
      return new RegExp(`^(${$.map((Y) => MX(Y.source)).join("|")})$`);
    }
    return;
  }), X._zod.parse = ($, Y) => {
    let W = false, J = [];
    for (let G of Q.options) {
      let H = G._zod.run({ value: $.value, issues: [] }, Y);
      if (H instanceof Promise) J.push(H), W = true;
      else {
        if (H.issues.length === 0) return H;
        J.push(H);
      }
    }
    if (!W) return FJ(J, $, X, Y);
    return Promise.all(J).then((G) => {
      return FJ(G, $, X, Y);
    });
  };
});
var LQ = O("$ZodDiscriminatedUnion", (X, Q) => {
  _4.init(X, Q);
  let $ = X._zod.parse;
  Y0(X._zod, "propValues", () => {
    let W = {};
    for (let J of Q.options) {
      let G = J._zod.propValues;
      if (!G || Object.keys(G).length === 0) throw Error(`Invalid discriminated union option at index "${Q.options.indexOf(J)}"`);
      for (let [H, B] of Object.entries(G)) {
        if (!W[H]) W[H] = /* @__PURE__ */ new Set();
        for (let z of B) W[H].add(z);
      }
    }
    return W;
  });
  let Y = AX(() => {
    let W = Q.options, J = /* @__PURE__ */ new Map();
    for (let G of W) {
      let H = G._zod.propValues[Q.discriminator];
      if (!H || H.size === 0) throw Error(`Invalid discriminated union option at index "${Q.options.indexOf(G)}"`);
      for (let B of H) {
        if (J.has(B)) throw Error(`Duplicate discriminator value "${String(B)}"`);
        J.set(B, G);
      }
    }
    return J;
  });
  X._zod.parse = (W, J) => {
    let G = W.value;
    if (!Z6(G)) return W.issues.push({ code: "invalid_type", expected: "object", input: G, inst: X }), W;
    let H = Y.value.get(G?.[Q.discriminator]);
    if (H) return H._zod.run(W, J);
    if (Q.unionFallback) return $(W, J);
    return W.issues.push({ code: "invalid_union", errors: [], note: "No matching discriminator", input: G, path: [Q.discriminator], inst: X }), W;
  };
});
var qQ = O("$ZodIntersection", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($, Y) => {
    let W = $.value, J = Q.left._zod.run({ value: W, issues: [] }, Y), G = Q.right._zod.run({ value: W, issues: [] }, Y);
    if (J instanceof Promise || G instanceof Promise) return Promise.all([J, G]).then(([B, z]) => {
      return NJ($, B, z);
    });
    return NJ($, J, G);
  };
});
function l9(X, Q) {
  if (X === Q) return { valid: true, data: X };
  if (X instanceof Date && Q instanceof Date && +X === +Q) return { valid: true, data: X };
  if (C6(X) && C6(Q)) {
    let $ = Object.keys(Q), Y = Object.keys(X).filter((J) => $.indexOf(J) !== -1), W = { ...X, ...Q };
    for (let J of Y) {
      let G = l9(X[J], Q[J]);
      if (!G.valid) return { valid: false, mergeErrorPath: [J, ...G.mergeErrorPath] };
      W[J] = G.data;
    }
    return { valid: true, data: W };
  }
  if (Array.isArray(X) && Array.isArray(Q)) {
    if (X.length !== Q.length) return { valid: false, mergeErrorPath: [] };
    let $ = [];
    for (let Y = 0; Y < X.length; Y++) {
      let W = X[Y], J = Q[Y], G = l9(W, J);
      if (!G.valid) return { valid: false, mergeErrorPath: [Y, ...G.mergeErrorPath] };
      $.push(G.data);
    }
    return { valid: true, data: $ };
  }
  return { valid: false, mergeErrorPath: [] };
}
function NJ(X, Q, $) {
  if (Q.issues.length) X.issues.push(...Q.issues);
  if ($.issues.length) X.issues.push(...$.issues);
  if (e1(X)) return X;
  let Y = l9(Q.value, $.value);
  if (!Y.valid) throw Error(`Unmergable intersection. Error path: ${JSON.stringify(Y.mergeErrorPath)}`);
  return X.value = Y.data, X;
}
var FQ = O("$ZodRecord", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($, Y) => {
    let W = $.value;
    if (!C6(W)) return $.issues.push({ expected: "record", code: "invalid_type", input: W, inst: X }), $;
    let J = [];
    if (Q.keyType._zod.values) {
      let G = Q.keyType._zod.values;
      $.value = {};
      for (let B of G) if (typeof B === "string" || typeof B === "number" || typeof B === "symbol") {
        let z = Q.valueType._zod.run({ value: W[B], issues: [] }, Y);
        if (z instanceof Promise) J.push(z.then((K) => {
          if (K.issues.length) $.issues.push(...B1(B, K.issues));
          $.value[B] = K.value;
        }));
        else {
          if (z.issues.length) $.issues.push(...B1(B, z.issues));
          $.value[B] = z.value;
        }
      }
      let H;
      for (let B in W) if (!G.has(B)) H = H ?? [], H.push(B);
      if (H && H.length > 0) $.issues.push({ code: "unrecognized_keys", input: W, inst: X, keys: H });
    } else {
      $.value = {};
      for (let G of Reflect.ownKeys(W)) {
        if (G === "__proto__") continue;
        let H = Q.keyType._zod.run({ value: G, issues: [] }, Y);
        if (H instanceof Promise) throw Error("Async schemas not supported in object keys currently");
        if (H.issues.length) {
          $.issues.push({ origin: "record", code: "invalid_key", issues: H.issues.map((z) => o0(z, Y, u0())), input: G, path: [G], inst: X }), $.value[H.value] = H.value;
          continue;
        }
        let B = Q.valueType._zod.run({ value: W[G], issues: [] }, Y);
        if (B instanceof Promise) J.push(B.then((z) => {
          if (z.issues.length) $.issues.push(...B1(G, z.issues));
          $.value[H.value] = z.value;
        }));
        else {
          if (B.issues.length) $.issues.push(...B1(G, B.issues));
          $.value[H.value] = B.value;
        }
      }
    }
    if (J.length) return Promise.all(J).then(() => $);
    return $;
  };
});
var NQ = O("$ZodEnum", (X, Q) => {
  X0.init(X, Q);
  let $ = DX(Q.entries);
  X._zod.values = new Set($), X._zod.pattern = new RegExp(`^(${$.filter((Y) => I9.has(typeof Y)).map((Y) => typeof Y === "string" ? y1(Y) : Y.toString()).join("|")})$`), X._zod.parse = (Y, W) => {
    let J = Y.value;
    if (X._zod.values.has(J)) return Y;
    return Y.issues.push({ code: "invalid_value", values: $, input: J, inst: X }), Y;
  };
});
var OQ = O("$ZodLiteral", (X, Q) => {
  X0.init(X, Q), X._zod.values = new Set(Q.values), X._zod.pattern = new RegExp(`^(${Q.values.map(($) => typeof $ === "string" ? y1($) : $ ? $.toString() : String($)).join("|")})$`), X._zod.parse = ($, Y) => {
    let W = $.value;
    if (X._zod.values.has(W)) return $;
    return $.issues.push({ code: "invalid_value", values: Q.values, input: W, inst: X }), $;
  };
});
var DQ = O("$ZodTransform", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($, Y) => {
    let W = Q.transform($.value, $);
    if (Y.async) return (W instanceof Promise ? W : Promise.resolve(W)).then((G) => {
      return $.value = G, $;
    });
    if (W instanceof Promise) throw new x1();
    return $.value = W, $;
  };
});
var AQ = O("$ZodOptional", (X, Q) => {
  X0.init(X, Q), X._zod.optin = "optional", X._zod.optout = "optional", Y0(X._zod, "values", () => {
    return Q.innerType._zod.values ? /* @__PURE__ */ new Set([...Q.innerType._zod.values, void 0]) : void 0;
  }), Y0(X._zod, "pattern", () => {
    let $ = Q.innerType._zod.pattern;
    return $ ? new RegExp(`^(${MX($.source)})?$`) : void 0;
  }), X._zod.parse = ($, Y) => {
    if (Q.innerType._zod.optin === "optional") return Q.innerType._zod.run($, Y);
    if ($.value === void 0) return $;
    return Q.innerType._zod.run($, Y);
  };
});
var wQ = O("$ZodNullable", (X, Q) => {
  X0.init(X, Q), Y0(X._zod, "optin", () => Q.innerType._zod.optin), Y0(X._zod, "optout", () => Q.innerType._zod.optout), Y0(X._zod, "pattern", () => {
    let $ = Q.innerType._zod.pattern;
    return $ ? new RegExp(`^(${MX($.source)}|null)$`) : void 0;
  }), Y0(X._zod, "values", () => {
    return Q.innerType._zod.values ? /* @__PURE__ */ new Set([...Q.innerType._zod.values, null]) : void 0;
  }), X._zod.parse = ($, Y) => {
    if ($.value === null) return $;
    return Q.innerType._zod.run($, Y);
  };
});
var MQ = O("$ZodDefault", (X, Q) => {
  X0.init(X, Q), X._zod.optin = "optional", Y0(X._zod, "values", () => Q.innerType._zod.values), X._zod.parse = ($, Y) => {
    if ($.value === void 0) return $.value = Q.defaultValue, $;
    let W = Q.innerType._zod.run($, Y);
    if (W instanceof Promise) return W.then((J) => OJ(J, Q));
    return OJ(W, Q);
  };
});
function OJ(X, Q) {
  if (X.value === void 0) X.value = Q.defaultValue;
  return X;
}
var jQ = O("$ZodPrefault", (X, Q) => {
  X0.init(X, Q), X._zod.optin = "optional", Y0(X._zod, "values", () => Q.innerType._zod.values), X._zod.parse = ($, Y) => {
    if ($.value === void 0) $.value = Q.defaultValue;
    return Q.innerType._zod.run($, Y);
  };
});
var RQ = O("$ZodNonOptional", (X, Q) => {
  X0.init(X, Q), Y0(X._zod, "values", () => {
    let $ = Q.innerType._zod.values;
    return $ ? new Set([...$].filter((Y) => Y !== void 0)) : void 0;
  }), X._zod.parse = ($, Y) => {
    let W = Q.innerType._zod.run($, Y);
    if (W instanceof Promise) return W.then((J) => DJ(J, X));
    return DJ(W, X);
  };
});
function DJ(X, Q) {
  if (!X.issues.length && X.value === void 0) X.issues.push({ code: "invalid_type", expected: "nonoptional", input: X.value, inst: Q });
  return X;
}
var IQ = O("$ZodCatch", (X, Q) => {
  X0.init(X, Q), X._zod.optin = "optional", Y0(X._zod, "optout", () => Q.innerType._zod.optout), Y0(X._zod, "values", () => Q.innerType._zod.values), X._zod.parse = ($, Y) => {
    let W = Q.innerType._zod.run($, Y);
    if (W instanceof Promise) return W.then((J) => {
      if ($.value = J.value, J.issues.length) $.value = Q.catchValue({ ...$, error: { issues: J.issues.map((G) => o0(G, Y, u0())) }, input: $.value }), $.issues = [];
      return $;
    });
    if ($.value = W.value, W.issues.length) $.value = Q.catchValue({ ...$, error: { issues: W.issues.map((J) => o0(J, Y, u0())) }, input: $.value }), $.issues = [];
    return $;
  };
});
var EQ = O("$ZodPipe", (X, Q) => {
  X0.init(X, Q), Y0(X._zod, "values", () => Q.in._zod.values), Y0(X._zod, "optin", () => Q.in._zod.optin), Y0(X._zod, "optout", () => Q.out._zod.optout), X._zod.parse = ($, Y) => {
    let W = Q.in._zod.run($, Y);
    if (W instanceof Promise) return W.then((J) => AJ(J, Q, Y));
    return AJ(W, Q, Y);
  };
});
function AJ(X, Q, $) {
  if (e1(X)) return X;
  return Q.out._zod.run({ value: X.value, issues: X.issues }, $);
}
var bQ = O("$ZodReadonly", (X, Q) => {
  X0.init(X, Q), Y0(X._zod, "propValues", () => Q.innerType._zod.propValues), Y0(X._zod, "values", () => Q.innerType._zod.values), Y0(X._zod, "optin", () => Q.innerType._zod.optin), Y0(X._zod, "optout", () => Q.innerType._zod.optout), X._zod.parse = ($, Y) => {
    let W = Q.innerType._zod.run($, Y);
    if (W instanceof Promise) return W.then(wJ);
    return wJ(W);
  };
});
function wJ(X) {
  return X.value = Object.freeze(X.value), X;
}
var PQ = O("$ZodCustom", (X, Q) => {
  w0.init(X, Q), X0.init(X, Q), X._zod.parse = ($, Y) => {
    return $;
  }, X._zod.check = ($) => {
    let Y = $.value, W = Q.fn(Y);
    if (W instanceof Promise) return W.then((J) => MJ(J, $, Y, X));
    MJ(W, $, Y, X);
    return;
  };
});
function MJ(X, Q, $, Y) {
  if (!X) {
    let W = { code: "custom", input: $, inst: Y, path: [...Y._zod.def.path ?? []], continue: !Y._zod.def.abort };
    if (Y._zod.def.params) W.params = Y._zod.def.params;
    Q.issues.push(P9(W));
  }
}
var oV = (X) => {
  let Q = typeof X;
  switch (Q) {
    case "number":
      return Number.isNaN(X) ? "NaN" : "number";
    case "object": {
      if (Array.isArray(X)) return "array";
      if (X === null) return "null";
      if (Object.getPrototypeOf(X) !== Object.prototype && X.constructor) return X.constructor.name;
    }
  }
  return Q;
};
var tV = () => {
  let X = { string: { unit: "characters", verb: "to have" }, file: { unit: "bytes", verb: "to have" }, array: { unit: "items", verb: "to have" }, set: { unit: "items", verb: "to have" } };
  function Q(Y) {
    return X[Y] ?? null;
  }
  let $ = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" };
  return (Y) => {
    switch (Y.code) {
      case "invalid_type":
        return `Invalid input: expected ${Y.expected}, received ${oV(Y.input)}`;
      case "invalid_value":
        if (Y.values.length === 1) return `Invalid input: expected ${S4(Y.values[0])}`;
        return `Invalid option: expected one of ${b4(Y.values, "|")}`;
      case "too_big": {
        let W = Y.inclusive ? "<=" : "<", J = Q(Y.origin);
        if (J) return `Too big: expected ${Y.origin ?? "value"} to have ${W}${Y.maximum.toString()} ${J.unit ?? "elements"}`;
        return `Too big: expected ${Y.origin ?? "value"} to be ${W}${Y.maximum.toString()}`;
      }
      case "too_small": {
        let W = Y.inclusive ? ">=" : ">", J = Q(Y.origin);
        if (J) return `Too small: expected ${Y.origin} to have ${W}${Y.minimum.toString()} ${J.unit}`;
        return `Too small: expected ${Y.origin} to be ${W}${Y.minimum.toString()}`;
      }
      case "invalid_format": {
        let W = Y;
        if (W.format === "starts_with") return `Invalid string: must start with "${W.prefix}"`;
        if (W.format === "ends_with") return `Invalid string: must end with "${W.suffix}"`;
        if (W.format === "includes") return `Invalid string: must include "${W.includes}"`;
        if (W.format === "regex") return `Invalid string: must match pattern ${W.pattern}`;
        return `Invalid ${$[W.format] ?? Y.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${Y.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${Y.keys.length > 1 ? "s" : ""}: ${b4(Y.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${Y.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${Y.origin}`;
      default:
        return "Invalid input";
    }
  };
};
function SQ() {
  return { localeError: tV() };
}
var aV = Symbol("ZodOutput");
var sV = Symbol("ZodInput");
var x4 = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(X, ...Q) {
    let $ = Q[0];
    if (this._map.set(X, $), $ && typeof $ === "object" && "id" in $) {
      if (this._idmap.has($.id)) throw Error(`ID ${$.id} already exists in the registry`);
      this._idmap.set($.id, X);
    }
    return this;
  }
  remove(X) {
    return this._map.delete(X), this;
  }
  get(X) {
    let Q = X._zod.parent;
    if (Q) {
      let $ = { ...this.get(Q) ?? {} };
      return delete $.id, { ...$, ...this._map.get(X) };
    }
    return this._map.get(X);
  }
  has(X) {
    return this._map.has(X);
  }
};
function PJ() {
  return new x4();
}
var g1 = PJ();
function ZQ(X, Q) {
  return new X({ type: "string", ...y(Q) });
}
function CQ(X, Q) {
  return new X({ type: "string", format: "email", check: "string_format", abort: false, ...y(Q) });
}
function y4(X, Q) {
  return new X({ type: "string", format: "guid", check: "string_format", abort: false, ...y(Q) });
}
function kQ(X, Q) {
  return new X({ type: "string", format: "uuid", check: "string_format", abort: false, ...y(Q) });
}
function vQ(X, Q) {
  return new X({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v4", ...y(Q) });
}
function TQ(X, Q) {
  return new X({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v6", ...y(Q) });
}
function _Q(X, Q) {
  return new X({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v7", ...y(Q) });
}
function xQ(X, Q) {
  return new X({ type: "string", format: "url", check: "string_format", abort: false, ...y(Q) });
}
function yQ(X, Q) {
  return new X({ type: "string", format: "emoji", check: "string_format", abort: false, ...y(Q) });
}
function gQ(X, Q) {
  return new X({ type: "string", format: "nanoid", check: "string_format", abort: false, ...y(Q) });
}
function fQ(X, Q) {
  return new X({ type: "string", format: "cuid", check: "string_format", abort: false, ...y(Q) });
}
function hQ(X, Q) {
  return new X({ type: "string", format: "cuid2", check: "string_format", abort: false, ...y(Q) });
}
function uQ(X, Q) {
  return new X({ type: "string", format: "ulid", check: "string_format", abort: false, ...y(Q) });
}
function lQ(X, Q) {
  return new X({ type: "string", format: "xid", check: "string_format", abort: false, ...y(Q) });
}
function mQ(X, Q) {
  return new X({ type: "string", format: "ksuid", check: "string_format", abort: false, ...y(Q) });
}
function cQ(X, Q) {
  return new X({ type: "string", format: "ipv4", check: "string_format", abort: false, ...y(Q) });
}
function pQ(X, Q) {
  return new X({ type: "string", format: "ipv6", check: "string_format", abort: false, ...y(Q) });
}
function dQ(X, Q) {
  return new X({ type: "string", format: "cidrv4", check: "string_format", abort: false, ...y(Q) });
}
function iQ(X, Q) {
  return new X({ type: "string", format: "cidrv6", check: "string_format", abort: false, ...y(Q) });
}
function nQ(X, Q) {
  return new X({ type: "string", format: "base64", check: "string_format", abort: false, ...y(Q) });
}
function rQ(X, Q) {
  return new X({ type: "string", format: "base64url", check: "string_format", abort: false, ...y(Q) });
}
function oQ(X, Q) {
  return new X({ type: "string", format: "e164", check: "string_format", abort: false, ...y(Q) });
}
function tQ(X, Q) {
  return new X({ type: "string", format: "jwt", check: "string_format", abort: false, ...y(Q) });
}
function SJ(X, Q) {
  return new X({ type: "string", format: "datetime", check: "string_format", offset: false, local: false, precision: null, ...y(Q) });
}
function ZJ(X, Q) {
  return new X({ type: "string", format: "date", check: "string_format", ...y(Q) });
}
function CJ(X, Q) {
  return new X({ type: "string", format: "time", check: "string_format", precision: null, ...y(Q) });
}
function kJ(X, Q) {
  return new X({ type: "string", format: "duration", check: "string_format", ...y(Q) });
}
function aQ(X, Q) {
  return new X({ type: "number", checks: [], ...y(Q) });
}
function sQ(X, Q) {
  return new X({ type: "number", check: "number_format", abort: false, format: "safeint", ...y(Q) });
}
function eQ(X, Q) {
  return new X({ type: "boolean", ...y(Q) });
}
function X$(X, Q) {
  return new X({ type: "null", ...y(Q) });
}
function Q$(X) {
  return new X({ type: "unknown" });
}
function $$(X, Q) {
  return new X({ type: "never", ...y(Q) });
}
function g4(X, Q) {
  return new f9({ check: "less_than", ...y(Q), value: X, inclusive: false });
}
function bX(X, Q) {
  return new f9({ check: "less_than", ...y(Q), value: X, inclusive: true });
}
function f4(X, Q) {
  return new h9({ check: "greater_than", ...y(Q), value: X, inclusive: false });
}
function PX(X, Q) {
  return new h9({ check: "greater_than", ...y(Q), value: X, inclusive: true });
}
function h4(X, Q) {
  return new eW({ check: "multiple_of", ...y(Q), value: X });
}
function u4(X, Q) {
  return new QJ({ check: "max_length", ...y(Q), maximum: X });
}
function k6(X, Q) {
  return new $J({ check: "min_length", ...y(Q), minimum: X });
}
function l4(X, Q) {
  return new YJ({ check: "length_equals", ...y(Q), length: X });
}
function Y$(X, Q) {
  return new WJ({ check: "string_format", format: "regex", ...y(Q), pattern: X });
}
function W$(X) {
  return new JJ({ check: "string_format", format: "lowercase", ...y(X) });
}
function J$(X) {
  return new GJ({ check: "string_format", format: "uppercase", ...y(X) });
}
function G$(X, Q) {
  return new HJ({ check: "string_format", format: "includes", ...y(Q), includes: X });
}
function H$(X, Q) {
  return new BJ({ check: "string_format", format: "starts_with", ...y(Q), prefix: X });
}
function B$(X, Q) {
  return new zJ({ check: "string_format", format: "ends_with", ...y(Q), suffix: X });
}
function $6(X) {
  return new KJ({ check: "overwrite", tx: X });
}
function z$(X) {
  return $6((Q) => Q.normalize(X));
}
function K$() {
  return $6((X) => X.trim());
}
function U$() {
  return $6((X) => X.toLowerCase());
}
function V$() {
  return $6((X) => X.toUpperCase());
}
function vJ(X, Q, $) {
  return new X({ type: "array", element: Q, ...y($) });
}
function L$(X, Q, $) {
  let Y = y($);
  return Y.abort ?? (Y.abort = true), new X({ type: "custom", check: "custom", fn: Q, ...Y });
}
function q$(X, Q, $) {
  return new X({ type: "custom", check: "custom", fn: Q, ...y($) });
}
var TL = O("ZodMiniType", (X, Q) => {
  if (!X._zod) throw Error("Uninitialized schema in ZodMiniType.");
  X0.init(X, Q), X.def = Q, X.parse = ($, Y) => k9(X, $, Y, { callee: X.parse }), X.safeParse = ($, Y) => X6(X, $, Y), X.parseAsync = async ($, Y) => T9(X, $, Y, { callee: X.parseAsync }), X.safeParseAsync = async ($, Y) => Q6(X, $, Y), X.check = (...$) => {
    return X.clone({ ...Q, checks: [...Q.checks ?? [], ...$.map((Y) => typeof Y === "function" ? { _zod: { check: Y, def: { check: "custom" }, onattach: [] } } : Y)] });
  }, X.clone = ($, Y) => l0(X, $, Y), X.brand = () => X, X.register = ($, Y) => {
    return $.add(X, Y), X;
  };
});
var _L = O("ZodMiniObject", (X, Q) => {
  T4.init(X, Q), TL.init(X, Q), i.defineLazy(X, "shape", () => Q.shape);
});
var SX = {};
U7(SX, { time: () => w$, duration: () => M$, datetime: () => D$, date: () => A$, ZodISOTime: () => fJ, ZodISODuration: () => hJ, ZodISODateTime: () => yJ, ZodISODate: () => gJ });
var yJ = O("ZodISODateTime", (X, Q) => {
  jJ.init(X, Q), H0.init(X, Q);
});
function D$(X) {
  return SJ(yJ, X);
}
var gJ = O("ZodISODate", (X, Q) => {
  RJ.init(X, Q), H0.init(X, Q);
});
function A$(X) {
  return ZJ(gJ, X);
}
var fJ = O("ZodISOTime", (X, Q) => {
  IJ.init(X, Q), H0.init(X, Q);
});
function w$(X) {
  return CJ(fJ, X);
}
var hJ = O("ZodISODuration", (X, Q) => {
  EJ.init(X, Q), H0.init(X, Q);
});
function M$(X) {
  return kJ(hJ, X);
}
var uJ = (X, Q) => {
  Z4.init(X, Q), X.name = "ZodError", Object.defineProperties(X, { format: { value: ($) => Z9(X, $) }, flatten: { value: ($) => S9(X, $) }, addIssue: { value: ($) => X.issues.push($) }, addIssues: { value: ($) => X.issues.push(...$) }, isEmpty: { get() {
    return X.issues.length === 0;
  } } });
};
var WZ = O("ZodError", uJ);
var ZX = O("ZodError", uJ, { Parent: Error });
var lJ = C9(ZX);
var mJ = v9(ZX);
var cJ = _9(ZX);
var pJ = x9(ZX);
var z0 = O("ZodType", (X, Q) => {
  return X0.init(X, Q), X.def = Q, Object.defineProperty(X, "_def", { value: Q }), X.check = (...$) => {
    return X.clone({ ...Q, checks: [...Q.checks ?? [], ...$.map((Y) => typeof Y === "function" ? { _zod: { check: Y, def: { check: "custom" }, onattach: [] } } : Y)] });
  }, X.clone = ($, Y) => l0(X, $, Y), X.brand = () => X, X.register = ($, Y) => {
    return $.add(X, Y), X;
  }, X.parse = ($, Y) => lJ(X, $, Y, { callee: X.parse }), X.safeParse = ($, Y) => cJ(X, $, Y), X.parseAsync = async ($, Y) => mJ(X, $, Y, { callee: X.parseAsync }), X.safeParseAsync = async ($, Y) => pJ(X, $, Y), X.spa = X.safeParseAsync, X.refine = ($, Y) => X.check(kq($, Y)), X.superRefine = ($) => X.check(vq($)), X.overwrite = ($) => X.check($6($)), X.optional = () => v(X), X.nullable = () => nJ(X), X.nullish = () => v(nJ(X)), X.nonoptional = ($) => Iq(X, $), X.array = () => r(X), X.or = ($) => J0([X, $]), X.and = ($) => i4(X, $), X.transform = ($) => R$(X, sJ($)), X.default = ($) => Mq(X, $), X.prefault = ($) => Rq(X, $), X.catch = ($) => bq(X, $), X.pipe = ($) => R$(X, $), X.readonly = () => Zq(X), X.describe = ($) => {
    let Y = X.clone();
    return g1.add(Y, { description: $ }), Y;
  }, Object.defineProperty(X, "description", { get() {
    return g1.get(X)?.description;
  }, configurable: true }), X.meta = (...$) => {
    if ($.length === 0) return g1.get(X);
    let Y = X.clone();
    return g1.add(Y, $[0]), Y;
  }, X.isOptional = () => X.safeParse(void 0).success, X.isNullable = () => X.safeParse(null).success, X;
});
var rJ = O("_ZodString", (X, Q) => {
  EX.init(X, Q), z0.init(X, Q);
  let $ = X._zod.bag;
  X.format = $.format ?? null, X.minLength = $.minimum ?? null, X.maxLength = $.maximum ?? null, X.regex = (...Y) => X.check(Y$(...Y)), X.includes = (...Y) => X.check(G$(...Y)), X.startsWith = (...Y) => X.check(H$(...Y)), X.endsWith = (...Y) => X.check(B$(...Y)), X.min = (...Y) => X.check(k6(...Y)), X.max = (...Y) => X.check(u4(...Y)), X.length = (...Y) => X.check(l4(...Y)), X.nonempty = (...Y) => X.check(k6(1, ...Y)), X.lowercase = (Y) => X.check(W$(Y)), X.uppercase = (Y) => X.check(J$(Y)), X.trim = () => X.check(K$()), X.normalize = (...Y) => X.check(z$(...Y)), X.toLowerCase = () => X.check(U$()), X.toUpperCase = () => X.check(V$());
});
var cL = O("ZodString", (X, Q) => {
  EX.init(X, Q), rJ.init(X, Q), X.email = ($) => X.check(CQ(pL, $)), X.url = ($) => X.check(xQ(dL, $)), X.jwt = ($) => X.check(tQ(Gq, $)), X.emoji = ($) => X.check(yQ(iL, $)), X.guid = ($) => X.check(y4(dJ, $)), X.uuid = ($) => X.check(kQ(d4, $)), X.uuidv4 = ($) => X.check(vQ(d4, $)), X.uuidv6 = ($) => X.check(TQ(d4, $)), X.uuidv7 = ($) => X.check(_Q(d4, $)), X.nanoid = ($) => X.check(gQ(nL, $)), X.guid = ($) => X.check(y4(dJ, $)), X.cuid = ($) => X.check(fQ(rL, $)), X.cuid2 = ($) => X.check(hQ(oL, $)), X.ulid = ($) => X.check(uQ(tL, $)), X.base64 = ($) => X.check(nQ(Yq, $)), X.base64url = ($) => X.check(rQ(Wq, $)), X.xid = ($) => X.check(lQ(aL, $)), X.ksuid = ($) => X.check(mQ(sL, $)), X.ipv4 = ($) => X.check(cQ(eL, $)), X.ipv6 = ($) => X.check(pQ(Xq, $)), X.cidrv4 = ($) => X.check(dQ(Qq, $)), X.cidrv6 = ($) => X.check(iQ($q, $)), X.e164 = ($) => X.check(oQ(Jq, $)), X.datetime = ($) => X.check(D$($)), X.date = ($) => X.check(A$($)), X.time = ($) => X.check(w$($)), X.duration = ($) => X.check(M$($));
});
function D(X) {
  return ZQ(cL, X);
}
var H0 = O("ZodStringFormat", (X, Q) => {
  W0.init(X, Q), rJ.init(X, Q);
});
var pL = O("ZodEmail", (X, Q) => {
  p9.init(X, Q), H0.init(X, Q);
});
var dJ = O("ZodGUID", (X, Q) => {
  m9.init(X, Q), H0.init(X, Q);
});
var d4 = O("ZodUUID", (X, Q) => {
  c9.init(X, Q), H0.init(X, Q);
});
var dL = O("ZodURL", (X, Q) => {
  d9.init(X, Q), H0.init(X, Q);
});
var iL = O("ZodEmoji", (X, Q) => {
  i9.init(X, Q), H0.init(X, Q);
});
var nL = O("ZodNanoID", (X, Q) => {
  n9.init(X, Q), H0.init(X, Q);
});
var rL = O("ZodCUID", (X, Q) => {
  r9.init(X, Q), H0.init(X, Q);
});
var oL = O("ZodCUID2", (X, Q) => {
  o9.init(X, Q), H0.init(X, Q);
});
var tL = O("ZodULID", (X, Q) => {
  t9.init(X, Q), H0.init(X, Q);
});
var aL = O("ZodXID", (X, Q) => {
  a9.init(X, Q), H0.init(X, Q);
});
var sL = O("ZodKSUID", (X, Q) => {
  s9.init(X, Q), H0.init(X, Q);
});
var eL = O("ZodIPv4", (X, Q) => {
  e9.init(X, Q), H0.init(X, Q);
});
var Xq = O("ZodIPv6", (X, Q) => {
  XQ.init(X, Q), H0.init(X, Q);
});
var Qq = O("ZodCIDRv4", (X, Q) => {
  QQ.init(X, Q), H0.init(X, Q);
});
var $q = O("ZodCIDRv6", (X, Q) => {
  $Q.init(X, Q), H0.init(X, Q);
});
var Yq = O("ZodBase64", (X, Q) => {
  YQ.init(X, Q), H0.init(X, Q);
});
var Wq = O("ZodBase64URL", (X, Q) => {
  WQ.init(X, Q), H0.init(X, Q);
});
var Jq = O("ZodE164", (X, Q) => {
  JQ.init(X, Q), H0.init(X, Q);
});
var Gq = O("ZodJWT", (X, Q) => {
  GQ.init(X, Q), H0.init(X, Q);
});
var oJ = O("ZodNumber", (X, Q) => {
  v4.init(X, Q), z0.init(X, Q), X.gt = (Y, W) => X.check(f4(Y, W)), X.gte = (Y, W) => X.check(PX(Y, W)), X.min = (Y, W) => X.check(PX(Y, W)), X.lt = (Y, W) => X.check(g4(Y, W)), X.lte = (Y, W) => X.check(bX(Y, W)), X.max = (Y, W) => X.check(bX(Y, W)), X.int = (Y) => X.check(iJ(Y)), X.safe = (Y) => X.check(iJ(Y)), X.positive = (Y) => X.check(f4(0, Y)), X.nonnegative = (Y) => X.check(PX(0, Y)), X.negative = (Y) => X.check(g4(0, Y)), X.nonpositive = (Y) => X.check(bX(0, Y)), X.multipleOf = (Y, W) => X.check(h4(Y, W)), X.step = (Y, W) => X.check(h4(Y, W)), X.finite = () => X;
  let $ = X._zod.bag;
  X.minValue = Math.max($.minimum ?? Number.NEGATIVE_INFINITY, $.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, X.maxValue = Math.min($.maximum ?? Number.POSITIVE_INFINITY, $.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, X.isInt = ($.format ?? "").includes("int") || Number.isSafeInteger($.multipleOf ?? 0.5), X.isFinite = true, X.format = $.format ?? null;
});
function Q0(X) {
  return aQ(oJ, X);
}
var Hq = O("ZodNumberFormat", (X, Q) => {
  HQ.init(X, Q), oJ.init(X, Q);
});
function iJ(X) {
  return sQ(Hq, X);
}
var Bq = O("ZodBoolean", (X, Q) => {
  BQ.init(X, Q), z0.init(X, Q);
});
function M0(X) {
  return eQ(Bq, X);
}
var zq = O("ZodNull", (X, Q) => {
  zQ.init(X, Q), z0.init(X, Q);
});
function I$(X) {
  return X$(zq, X);
}
var Kq = O("ZodUnknown", (X, Q) => {
  KQ.init(X, Q), z0.init(X, Q);
});
function N0() {
  return Q$(Kq);
}
var Uq = O("ZodNever", (X, Q) => {
  UQ.init(X, Q), z0.init(X, Q);
});
function Vq(X) {
  return $$(Uq, X);
}
var Lq = O("ZodArray", (X, Q) => {
  VQ.init(X, Q), z0.init(X, Q), X.element = Q.element, X.min = ($, Y) => X.check(k6($, Y)), X.nonempty = ($) => X.check(k6(1, $)), X.max = ($, Y) => X.check(u4($, Y)), X.length = ($, Y) => X.check(l4($, Y)), X.unwrap = () => X.element;
});
function r(X, Q) {
  return vJ(Lq, X, Q);
}
var tJ = O("ZodObject", (X, Q) => {
  T4.init(X, Q), z0.init(X, Q), i.defineLazy(X, "shape", () => Q.shape), X.keyof = () => j0(Object.keys(X._zod.def.shape)), X.catchall = ($) => X.clone({ ...X._zod.def, catchall: $ }), X.passthrough = () => X.clone({ ...X._zod.def, catchall: N0() }), X.loose = () => X.clone({ ...X._zod.def, catchall: N0() }), X.strict = () => X.clone({ ...X._zod.def, catchall: Vq() }), X.strip = () => X.clone({ ...X._zod.def, catchall: void 0 }), X.extend = ($) => {
    return i.extend(X, $);
  }, X.merge = ($) => i.merge(X, $), X.pick = ($) => i.pick(X, $), X.omit = ($) => i.omit(X, $), X.partial = (...$) => i.partial(eJ, X, $[0]), X.required = (...$) => i.required(X5, X, $[0]);
});
function E(X, Q) {
  let $ = { type: "object", get shape() {
    return i.assignProp(this, "shape", { ...X }), this.shape;
  }, ...i.normalizeParams(Q) };
  return new tJ($);
}
function c0(X, Q) {
  return new tJ({ type: "object", get shape() {
    return i.assignProp(this, "shape", { ...X }), this.shape;
  }, catchall: N0(), ...i.normalizeParams(Q) });
}
var aJ = O("ZodUnion", (X, Q) => {
  _4.init(X, Q), z0.init(X, Q), X.options = Q.options;
});
function J0(X, Q) {
  return new aJ({ type: "union", options: X, ...i.normalizeParams(Q) });
}
var qq = O("ZodDiscriminatedUnion", (X, Q) => {
  aJ.init(X, Q), LQ.init(X, Q);
});
function E$(X, Q, $) {
  return new qq({ type: "union", options: Q, discriminator: X, ...i.normalizeParams($) });
}
var Fq = O("ZodIntersection", (X, Q) => {
  qQ.init(X, Q), z0.init(X, Q);
});
function i4(X, Q) {
  return new Fq({ type: "intersection", left: X, right: Q });
}
var Nq = O("ZodRecord", (X, Q) => {
  FQ.init(X, Q), z0.init(X, Q), X.keyType = Q.keyType, X.valueType = Q.valueType;
});
function O0(X, Q, $) {
  return new Nq({ type: "record", keyType: X, valueType: Q, ...i.normalizeParams($) });
}
var j$ = O("ZodEnum", (X, Q) => {
  NQ.init(X, Q), z0.init(X, Q), X.enum = Q.entries, X.options = Object.values(Q.entries);
  let $ = new Set(Object.keys(Q.entries));
  X.extract = (Y, W) => {
    let J = {};
    for (let G of Y) if ($.has(G)) J[G] = Q.entries[G];
    else throw Error(`Key ${G} not found in enum`);
    return new j$({ ...Q, checks: [], ...i.normalizeParams(W), entries: J });
  }, X.exclude = (Y, W) => {
    let J = { ...Q.entries };
    for (let G of Y) if ($.has(G)) delete J[G];
    else throw Error(`Key ${G} not found in enum`);
    return new j$({ ...Q, checks: [], ...i.normalizeParams(W), entries: J });
  };
});
function j0(X, Q) {
  let $ = Array.isArray(X) ? Object.fromEntries(X.map((Y) => [Y, Y])) : X;
  return new j$({ type: "enum", entries: $, ...i.normalizeParams(Q) });
}
var Oq = O("ZodLiteral", (X, Q) => {
  OQ.init(X, Q), z0.init(X, Q), X.values = new Set(Q.values), Object.defineProperty(X, "value", { get() {
    if (Q.values.length > 1) throw Error("This schema contains multiple valid literal values. Use `.values` instead.");
    return Q.values[0];
  } });
});
function T(X, Q) {
  return new Oq({ type: "literal", values: Array.isArray(X) ? X : [X], ...i.normalizeParams(Q) });
}
var Dq = O("ZodTransform", (X, Q) => {
  DQ.init(X, Q), z0.init(X, Q), X._zod.parse = ($, Y) => {
    $.addIssue = (J) => {
      if (typeof J === "string") $.issues.push(i.issue(J, $.value, Q));
      else {
        let G = J;
        if (G.fatal) G.continue = false;
        G.code ?? (G.code = "custom"), G.input ?? (G.input = $.value), G.inst ?? (G.inst = X), G.continue ?? (G.continue = true), $.issues.push(i.issue(G));
      }
    };
    let W = Q.transform($.value, $);
    if (W instanceof Promise) return W.then((J) => {
      return $.value = J, $;
    });
    return $.value = W, $;
  };
});
function sJ(X) {
  return new Dq({ type: "transform", transform: X });
}
var eJ = O("ZodOptional", (X, Q) => {
  AQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType;
});
function v(X) {
  return new eJ({ type: "optional", innerType: X });
}
var Aq = O("ZodNullable", (X, Q) => {
  wQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType;
});
function nJ(X) {
  return new Aq({ type: "nullable", innerType: X });
}
var wq = O("ZodDefault", (X, Q) => {
  MQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType, X.removeDefault = X.unwrap;
});
function Mq(X, Q) {
  return new wq({ type: "default", innerType: X, get defaultValue() {
    return typeof Q === "function" ? Q() : Q;
  } });
}
var jq = O("ZodPrefault", (X, Q) => {
  jQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType;
});
function Rq(X, Q) {
  return new jq({ type: "prefault", innerType: X, get defaultValue() {
    return typeof Q === "function" ? Q() : Q;
  } });
}
var X5 = O("ZodNonOptional", (X, Q) => {
  RQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType;
});
function Iq(X, Q) {
  return new X5({ type: "nonoptional", innerType: X, ...i.normalizeParams(Q) });
}
var Eq = O("ZodCatch", (X, Q) => {
  IQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType, X.removeCatch = X.unwrap;
});
function bq(X, Q) {
  return new Eq({ type: "catch", innerType: X, catchValue: typeof Q === "function" ? Q : () => Q });
}
var Pq = O("ZodPipe", (X, Q) => {
  EQ.init(X, Q), z0.init(X, Q), X.in = Q.in, X.out = Q.out;
});
function R$(X, Q) {
  return new Pq({ type: "pipe", in: X, out: Q });
}
var Sq = O("ZodReadonly", (X, Q) => {
  bQ.init(X, Q), z0.init(X, Q);
});
function Zq(X) {
  return new Sq({ type: "readonly", innerType: X });
}
var Q5 = O("ZodCustom", (X, Q) => {
  PQ.init(X, Q), z0.init(X, Q);
});
function Cq(X, Q) {
  let $ = new w0({ check: "custom", ...i.normalizeParams(Q) });
  return $._zod.check = X, $;
}
function $5(X, Q) {
  return L$(Q5, X ?? (() => true), Q);
}
function kq(X, Q = {}) {
  return q$(Q5, X, Q);
}
function vq(X, Q) {
  let $ = Cq((Y) => {
    return Y.addIssue = (W) => {
      if (typeof W === "string") Y.issues.push(i.issue(W, Y.value, $._zod.def));
      else {
        let J = W;
        if (J.fatal) J.continue = false;
        J.code ?? (J.code = "custom"), J.input ?? (J.input = Y.value), J.inst ?? (J.inst = $), J.continue ?? (J.continue = !$._zod.def.abort), Y.issues.push(i.issue(J));
      }
    }, X(Y.value, Y);
  }, Q);
  return $;
}
function b$(X, Q) {
  return R$(sJ(X), Q);
}
u0(SQ());
var K1 = "io.modelcontextprotocol/related-task";
var r4 = "2.0";
var z1 = $5((X) => X !== null && (typeof X === "object" || typeof X === "function"));
var W5 = J0([D(), Q0().int()]);
var J5 = D();
var Tq = c0({ ttl: J0([Q0(), I$()]).optional(), pollInterval: Q0().optional() });
var S$ = c0({ taskId: D() });
var _q = c0({ progressToken: W5.optional(), [K1]: S$.optional() });
var _0 = c0({ task: Tq.optional(), _meta: _q.optional() });
var R0 = E({ method: D(), params: _0.optional() });
var W6 = c0({ _meta: E({ [K1]: v(S$) }).passthrough().optional() });
var p0 = E({ method: D(), params: W6.optional() });
var b0 = c0({ _meta: c0({ [K1]: S$.optional() }).optional() });
var o4 = J0([D(), Q0().int()]);
var G5 = E({ jsonrpc: T(r4), id: o4, ...R0.shape }).strict();
var H5 = E({ jsonrpc: T(r4), ...p0.shape }).strict();
var z5 = E({ jsonrpc: T(r4), id: o4, result: b0 }).strict();
var x;
(function(X) {
  X[X.ConnectionClosed = -32e3] = "ConnectionClosed", X[X.RequestTimeout = -32001] = "RequestTimeout", X[X.ParseError = -32700] = "ParseError", X[X.InvalidRequest = -32600] = "InvalidRequest", X[X.MethodNotFound = -32601] = "MethodNotFound", X[X.InvalidParams = -32602] = "InvalidParams", X[X.InternalError = -32603] = "InternalError", X[X.UrlElicitationRequired = -32042] = "UrlElicitationRequired";
})(x || (x = {}));
var K5 = E({ jsonrpc: T(r4), id: o4, error: E({ code: Q0().int(), message: D(), data: v(N0()) }) }).strict();
var DZ = J0([G5, H5, z5, K5]);
var t4 = b0.strict();
var xq = W6.extend({ requestId: o4, reason: D().optional() });
var a4 = p0.extend({ method: T("notifications/cancelled"), params: xq });
var yq = E({ src: D(), mimeType: D().optional(), sizes: r(D()).optional() });
var kX = E({ icons: r(yq).optional() });
var _6 = E({ name: D(), title: D().optional() });
var V5 = _6.extend({ ..._6.shape, ...kX.shape, version: D(), websiteUrl: D().optional() });
var gq = i4(E({ applyDefaults: M0().optional() }), O0(D(), N0()));
var fq = b$((X) => {
  if (X && typeof X === "object" && !Array.isArray(X)) {
    if (Object.keys(X).length === 0) return { form: {} };
  }
  return X;
}, i4(E({ form: gq.optional(), url: z1.optional() }), O0(D(), N0()).optional()));
var hq = E({ list: v(E({}).passthrough()), cancel: v(E({}).passthrough()), requests: v(E({ sampling: v(E({ createMessage: v(E({}).passthrough()) }).passthrough()), elicitation: v(E({ create: v(E({}).passthrough()) }).passthrough()) }).passthrough()) }).passthrough();
var uq = E({ list: v(E({}).passthrough()), cancel: v(E({}).passthrough()), requests: v(E({ tools: v(E({ call: v(E({}).passthrough()) }).passthrough()) }).passthrough()) }).passthrough();
var lq = E({ experimental: O0(D(), z1).optional(), sampling: E({ context: z1.optional(), tools: z1.optional() }).optional(), elicitation: fq.optional(), roots: E({ listChanged: M0().optional() }).optional(), tasks: v(hq) });
var mq = _0.extend({ protocolVersion: D(), capabilities: lq, clientInfo: V5 });
var C$ = R0.extend({ method: T("initialize"), params: mq });
var cq = E({ experimental: O0(D(), z1).optional(), logging: z1.optional(), completions: z1.optional(), prompts: v(E({ listChanged: v(M0()) })), resources: E({ subscribe: M0().optional(), listChanged: M0().optional() }).optional(), tools: E({ listChanged: M0().optional() }).optional(), tasks: v(uq) }).passthrough();
var pq = b0.extend({ protocolVersion: D(), capabilities: cq, serverInfo: V5, instructions: D().optional() });
var k$ = p0.extend({ method: T("notifications/initialized") });
var s4 = R0.extend({ method: T("ping") });
var dq = E({ progress: Q0(), total: v(Q0()), message: v(D()) });
var iq = E({ ...W6.shape, ...dq.shape, progressToken: W5 });
var e4 = p0.extend({ method: T("notifications/progress"), params: iq });
var nq = _0.extend({ cursor: J5.optional() });
var vX = R0.extend({ params: nq.optional() });
var TX = b0.extend({ nextCursor: v(J5) });
var _X = E({ taskId: D(), status: j0(["working", "input_required", "completed", "failed", "cancelled"]), ttl: J0([Q0(), I$()]), createdAt: D(), lastUpdatedAt: D(), pollInterval: v(Q0()), statusMessage: v(D()) });
var x6 = b0.extend({ task: _X });
var rq = W6.merge(_X);
var xX = p0.extend({ method: T("notifications/tasks/status"), params: rq });
var X8 = R0.extend({ method: T("tasks/get"), params: _0.extend({ taskId: D() }) });
var Q8 = b0.merge(_X);
var $8 = R0.extend({ method: T("tasks/result"), params: _0.extend({ taskId: D() }) });
var Y8 = vX.extend({ method: T("tasks/list") });
var W8 = TX.extend({ tasks: r(_X) });
var L5 = R0.extend({ method: T("tasks/cancel"), params: _0.extend({ taskId: D() }) });
var q5 = b0.merge(_X);
var F5 = E({ uri: D(), mimeType: v(D()), _meta: O0(D(), N0()).optional() });
var N5 = F5.extend({ text: D() });
var v$ = D().refine((X) => {
  try {
    return atob(X), true;
  } catch (Q) {
    return false;
  }
}, { message: "Invalid Base64 string" });
var O5 = F5.extend({ blob: v$ });
var y6 = E({ audience: r(j0(["user", "assistant"])).optional(), priority: Q0().min(0).max(1).optional(), lastModified: SX.datetime({ offset: true }).optional() });
var D5 = E({ ..._6.shape, ...kX.shape, uri: D(), description: v(D()), mimeType: v(D()), annotations: y6.optional(), _meta: v(c0({})) });
var oq = E({ ..._6.shape, ...kX.shape, uriTemplate: D(), description: v(D()), mimeType: v(D()), annotations: y6.optional(), _meta: v(c0({})) });
var J8 = vX.extend({ method: T("resources/list") });
var tq = TX.extend({ resources: r(D5) });
var G8 = vX.extend({ method: T("resources/templates/list") });
var aq = TX.extend({ resourceTemplates: r(oq) });
var T$ = _0.extend({ uri: D() });
var sq = T$;
var H8 = R0.extend({ method: T("resources/read"), params: sq });
var eq = b0.extend({ contents: r(J0([N5, O5])) });
var XF = p0.extend({ method: T("notifications/resources/list_changed") });
var QF = T$;
var $F = R0.extend({ method: T("resources/subscribe"), params: QF });
var YF = T$;
var WF = R0.extend({ method: T("resources/unsubscribe"), params: YF });
var JF = W6.extend({ uri: D() });
var GF = p0.extend({ method: T("notifications/resources/updated"), params: JF });
var HF = E({ name: D(), description: v(D()), required: v(M0()) });
var BF = E({ ..._6.shape, ...kX.shape, description: v(D()), arguments: v(r(HF)), _meta: v(c0({})) });
var B8 = vX.extend({ method: T("prompts/list") });
var zF = TX.extend({ prompts: r(BF) });
var KF = _0.extend({ name: D(), arguments: O0(D(), D()).optional() });
var z8 = R0.extend({ method: T("prompts/get"), params: KF });
var _$ = E({ type: T("text"), text: D(), annotations: y6.optional(), _meta: O0(D(), N0()).optional() });
var x$ = E({ type: T("image"), data: v$, mimeType: D(), annotations: y6.optional(), _meta: O0(D(), N0()).optional() });
var y$ = E({ type: T("audio"), data: v$, mimeType: D(), annotations: y6.optional(), _meta: O0(D(), N0()).optional() });
var UF = E({ type: T("tool_use"), name: D(), id: D(), input: E({}).passthrough(), _meta: v(E({}).passthrough()) }).passthrough();
var VF = E({ type: T("resource"), resource: J0([N5, O5]), annotations: y6.optional(), _meta: O0(D(), N0()).optional() });
var LF = D5.extend({ type: T("resource_link") });
var g$ = J0([_$, x$, y$, LF, VF]);
var qF = E({ role: j0(["user", "assistant"]), content: g$ });
var FF = b0.extend({ description: v(D()), messages: r(qF) });
var NF = p0.extend({ method: T("notifications/prompts/list_changed") });
var OF = E({ title: D().optional(), readOnlyHint: M0().optional(), destructiveHint: M0().optional(), idempotentHint: M0().optional(), openWorldHint: M0().optional() });
var DF = E({ taskSupport: j0(["required", "optional", "forbidden"]).optional() });
var A5 = E({ ..._6.shape, ...kX.shape, description: D().optional(), inputSchema: E({ type: T("object"), properties: O0(D(), z1).optional(), required: r(D()).optional() }).catchall(N0()), outputSchema: E({ type: T("object"), properties: O0(D(), z1).optional(), required: r(D()).optional() }).catchall(N0()).optional(), annotations: v(OF), execution: v(DF), _meta: O0(D(), N0()).optional() });
var K8 = vX.extend({ method: T("tools/list") });
var AF = TX.extend({ tools: r(A5) });
var U8 = b0.extend({ content: r(g$).default([]), structuredContent: O0(D(), N0()).optional(), isError: v(M0()) });
var AZ = U8.or(b0.extend({ toolResult: N0() }));
var wF = _0.extend({ name: D(), arguments: v(O0(D(), N0())) });
var g6 = R0.extend({ method: T("tools/call"), params: wF });
var MF = p0.extend({ method: T("notifications/tools/list_changed") });
var yX = j0(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]);
var jF = _0.extend({ level: yX });
var f$ = R0.extend({ method: T("logging/setLevel"), params: jF });
var RF = W6.extend({ level: yX, logger: D().optional(), data: N0() });
var IF = p0.extend({ method: T("notifications/message"), params: RF });
var EF = E({ name: D().optional() });
var bF = E({ hints: v(r(EF)), costPriority: v(Q0().min(0).max(1)), speedPriority: v(Q0().min(0).max(1)), intelligencePriority: v(Q0().min(0).max(1)) });
var PF = E({ mode: v(j0(["auto", "required", "none"])) });
var SF = E({ type: T("tool_result"), toolUseId: D().describe("The unique identifier for the corresponding tool call."), content: r(g$).default([]), structuredContent: E({}).passthrough().optional(), isError: v(M0()), _meta: v(E({}).passthrough()) }).passthrough();
var ZF = E$("type", [_$, x$, y$]);
var n4 = E$("type", [_$, x$, y$, UF, SF]);
var CF = E({ role: j0(["user", "assistant"]), content: J0([n4, r(n4)]), _meta: v(E({}).passthrough()) }).passthrough();
var kF = _0.extend({ messages: r(CF), modelPreferences: bF.optional(), systemPrompt: D().optional(), includeContext: j0(["none", "thisServer", "allServers"]).optional(), temperature: Q0().optional(), maxTokens: Q0().int(), stopSequences: r(D()).optional(), metadata: z1.optional(), tools: v(r(A5)), toolChoice: v(PF) });
var vF = R0.extend({ method: T("sampling/createMessage"), params: kF });
var h$ = b0.extend({ model: D(), stopReason: v(j0(["endTurn", "stopSequence", "maxTokens"]).or(D())), role: j0(["user", "assistant"]), content: ZF });
var u$ = b0.extend({ model: D(), stopReason: v(j0(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(D())), role: j0(["user", "assistant"]), content: J0([n4, r(n4)]) });
var TF = E({ type: T("boolean"), title: D().optional(), description: D().optional(), default: M0().optional() });
var _F = E({ type: T("string"), title: D().optional(), description: D().optional(), minLength: Q0().optional(), maxLength: Q0().optional(), format: j0(["email", "uri", "date", "date-time"]).optional(), default: D().optional() });
var xF = E({ type: j0(["number", "integer"]), title: D().optional(), description: D().optional(), minimum: Q0().optional(), maximum: Q0().optional(), default: Q0().optional() });
var yF = E({ type: T("string"), title: D().optional(), description: D().optional(), enum: r(D()), default: D().optional() });
var gF = E({ type: T("string"), title: D().optional(), description: D().optional(), oneOf: r(E({ const: D(), title: D() })), default: D().optional() });
var fF = E({ type: T("string"), title: D().optional(), description: D().optional(), enum: r(D()), enumNames: r(D()).optional(), default: D().optional() });
var hF = J0([yF, gF]);
var uF = E({ type: T("array"), title: D().optional(), description: D().optional(), minItems: Q0().optional(), maxItems: Q0().optional(), items: E({ type: T("string"), enum: r(D()) }), default: r(D()).optional() });
var lF = E({ type: T("array"), title: D().optional(), description: D().optional(), minItems: Q0().optional(), maxItems: Q0().optional(), items: E({ anyOf: r(E({ const: D(), title: D() })) }), default: r(D()).optional() });
var mF = J0([uF, lF]);
var cF = J0([fF, hF, mF]);
var pF = J0([cF, TF, _F, xF]);
var dF = _0.extend({ mode: T("form").optional(), message: D(), requestedSchema: E({ type: T("object"), properties: O0(D(), pF), required: r(D()).optional() }) });
var iF = _0.extend({ mode: T("url"), message: D(), elicitationId: D(), url: D().url() });
var nF = J0([dF, iF]);
var rF = R0.extend({ method: T("elicitation/create"), params: nF });
var oF = W6.extend({ elicitationId: D() });
var tF = p0.extend({ method: T("notifications/elicitation/complete"), params: oF });
var V8 = b0.extend({ action: j0(["accept", "decline", "cancel"]), content: b$((X) => X === null ? void 0 : X, O0(D(), J0([D(), Q0(), M0(), r(D())])).optional()) });
var aF = E({ type: T("ref/resource"), uri: D() });
var sF = E({ type: T("ref/prompt"), name: D() });
var eF = _0.extend({ ref: J0([sF, aF]), argument: E({ name: D(), value: D() }), context: E({ arguments: O0(D(), D()).optional() }).optional() });
var L8 = R0.extend({ method: T("completion/complete"), params: eF });
var XN = b0.extend({ completion: c0({ values: r(D()).max(100), total: v(Q0().int()), hasMore: v(M0()) }) });
var QN = E({ uri: D().startsWith("file://"), name: D().optional(), _meta: O0(D(), N0()).optional() });
var $N = R0.extend({ method: T("roots/list") });
var l$ = b0.extend({ roots: r(QN) });
var YN = p0.extend({ method: T("notifications/roots/list_changed") });
var wZ = J0([s4, C$, L8, f$, z8, B8, J8, G8, H8, $F, WF, g6, K8, X8, $8, Y8]);
var MZ = J0([a4, e4, k$, YN, xX]);
var jZ = J0([t4, h$, u$, V8, l$, Q8, W8, x6]);
var RZ = J0([s4, vF, rF, $N, X8, $8, Y8]);
var IZ = J0([a4, e4, IF, GF, XF, MF, NF, xX, tF]);
var EZ = J0([t4, pq, XN, FF, zF, tq, aq, eq, U8, AF, Q8, W8, x6]);
var I5 = Symbol("Let zodToJsonSchema decide on which parser to use");
var GN = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
var hz = K7(cY(), 1);
var uz = K7(fz(), 1);
var pz = Symbol.for("mcp.completable");
var cz;
(function(X) {
  X.Completable = "McpCompletable";
})(cz || (cz = {}));
function o_({ prompt: X, options: Q }) {
  let { systemPrompt: $, settingSources: Y, sandbox: W, ...J } = Q ?? {}, G, H;
  if ($ === void 0) G = "";
  else if (typeof $ === "string") G = $;
  else if ($.type === "preset") H = $.append;
  let B = J.pathToClaudeCodeExecutable;
  if (!B) {
    let q6 = (0, import_url.fileURLToPath)(import_meta.url), F6 = (0, import_path.join)(q6, "..");
    B = (0, import_path.join)(F6, "cli.js");
  }
  process.env.CLAUDE_AGENT_SDK_VERSION = "0.2.29";
  let { abortController: z = N6(), additionalDirectories: K = [], agent: V, agents: L, allowedTools: U = [], betas: F, canUseTool: q, continue: N, cwd: A, disallowedTools: M = [], tools: R, env: S, executable: C = j6() ? "bun" : "node", executableArgs: K0 = [], extraArgs: U0 = {}, fallbackModel: s, enableFileCheckpointing: D0, forkSession: q0, hooks: W1, includePartialMessages: P1, persistSession: U6, maxThinkingTokens: d, maxTurns: Q9, maxBudgetUsd: o6, mcpServers: V6, model: t6, outputFormat: a6, permissionMode: B4 = "default", allowDangerouslySkipPermissions: S0 = false, permissionPromptToolName: S1, plugins: s6, resume: az, resumeSessionAt: sz, stderr: ez, strictMcpConfig: XK } = J, G7 = a6?.type === "json_schema" ? a6.schema : void 0, L6 = S;
  if (!L6) L6 = { ...process.env };
  if (!L6.CLAUDE_CODE_ENTRYPOINT) L6.CLAUDE_CODE_ENTRYPOINT = "sdk-ts";
  if (D0) L6.CLAUDE_CODE_ENABLE_SDK_FILE_CHECKPOINTING = "true";
  if (!B) throw Error("pathToClaudeCodeExecutable is required");
  let $9 = {}, H7 = /* @__PURE__ */ new Map();
  if (V6) for (let [q6, F6] of Object.entries(V6)) if (F6.type === "sdk" && "instance" in F6) H7.set(q6, F6.instance), $9[q6] = { type: "sdk", name: q6 };
  else $9[q6] = F6;
  let QK = typeof X === "string", B7 = new XX({ abortController: z, additionalDirectories: K, agent: V, betas: F, cwd: A, executable: C, executableArgs: K0, extraArgs: U0, pathToClaudeCodeExecutable: B, env: L6, forkSession: q0, stderr: ez, maxThinkingTokens: d, maxTurns: Q9, maxBudgetUsd: o6, model: t6, fallbackModel: s, jsonSchema: G7, permissionMode: B4, allowDangerouslySkipPermissions: S0, permissionPromptToolName: S1, continueConversation: N, resume: az, resumeSessionAt: sz, settingSources: Y ?? [], allowedTools: U, disallowedTools: M, tools: R, mcpServers: $9, strictMcpConfig: XK, canUseTool: !!q, hooks: !!W1, includePartialMessages: P1, persistSession: U6, plugins: s6, sandbox: W, spawnClaudeCodeProcess: J.spawnClaudeCodeProcess }), z7 = new $X(B7, QK, q, W1, z, H7, G7, { systemPrompt: G, appendSystemPrompt: H, agents: L });
  if (typeof X === "string") B7.write(Z0({ type: "user", session_id: "", message: { role: "user", content: [{ type: "text", text: X }] }, parent_tool_use_id: null }) + `
`);
  else z7.streamInput(X);
  return z7;
}

// claude/src/executor.ts
function extractTextFromMessage(msg) {
  if (msg.type !== "assistant") return "";
  return msg.message.content.filter(
    (block) => block.type === "text"
  ).map((block) => block.text).join("");
}
async function executeClaudeSDK(options) {
  const {
    prompt,
    cwd = process.cwd(),
    claudePath = process.env.CLAUDE_CODE_PATH || `${process.env.HOME}/.local/bin/claude`,
    allowedTools,
    outputSchema,
    permissionMode = "acceptEdits"
  } = options;
  core.info(`Running Claude SDK`);
  core.info(`Working directory: ${cwd}`);
  core.info(`Claude Code path: ${claudePath}`);
  core.debug(`Prompt: ${prompt.slice(0, 200)}...`);
  const sdkOptions = {
    cwd,
    pathToClaudeCodeExecutable: claudePath,
    permissionMode,
    // Load CLAUDE.md and project settings
    settingSources: ["project"],
    // Use Claude Code's system prompt
    systemPrompt: { type: "preset", preset: "claude_code" }
  };
  if (allowedTools && allowedTools.length > 0) {
    sdkOptions.allowedTools = allowedTools;
  }
  if (outputSchema) {
    sdkOptions.outputFormat = {
      type: "json_schema",
      schema: outputSchema
    };
    core.info("Using structured output mode with JSON schema");
  }
  let output = "";
  let structuredOutput;
  let numTurns;
  let costUsd;
  try {
    const q = o_({ prompt, options: sdkOptions });
    for await (const msg of q) {
      if (msg.type === "system" && msg.subtype === "init") {
        core.info(`[SDK] Session: ${msg.session_id}`);
        core.info(`[SDK] Model: ${msg.model}`);
        core.info(`[SDK] Permission mode: ${msg.permissionMode}`);
      }
      if (msg.type === "assistant") {
        const text = extractTextFromMessage(msg);
        if (text) {
          process.stdout.write(text);
          output += text;
        }
        for (const block of msg.message.content) {
          if (block.type === "tool_use") {
            core.info(`
[Tool: ${block.name}]`);
          }
        }
      }
      if (msg.type === "result") {
        if (msg.subtype === "success") {
          structuredOutput = msg.structured_output;
          numTurns = msg.num_turns;
          costUsd = msg.total_cost_usd;
          if (structuredOutput) {
            core.startGroup("Structured Output");
            core.info(JSON.stringify(structuredOutput, null, 2));
            core.endGroup();
          }
          core.info(
            `
[SDK] Completed successfully (${numTurns} turns, $${costUsd.toFixed(4)})`
          );
        } else {
          const errorSubtype = msg.subtype;
          const errors = "errors" in msg ? msg.errors?.join("\n") : errorSubtype;
          core.error(`[SDK] Failed: ${errors}`);
          return {
            success: false,
            exitCode: 1,
            output,
            error: errors
          };
        }
      }
    }
    return {
      success: true,
      exitCode: 0,
      output,
      structuredOutput,
      numTurns,
      costUsd
    };
  } catch (error2) {
    const errorMessage = error2 instanceof Error ? error2.message : String(error2);
    core.error(`Failed to run Claude: ${errorMessage}`);
    return {
      success: false,
      exitCode: 1,
      output,
      error: errorMessage
    };
  }
}
async function isClaudeAvailable() {
  try {
    const exitCode = await exec.exec("which", ["claude"], {
      ignoreReturnCode: true,
      silent: true
    });
    return exitCode === 0;
  } catch {
    return false;
  }
}
async function getClaudeVersion() {
  let stdout = "";
  try {
    const exitCode = await exec.exec("claude", ["--version"], {
      ignoreReturnCode: true,
      silent: true,
      listeners: {
        stdout: (data) => {
          stdout += data.toString();
        }
      }
    });
    if (exitCode !== 0) {
      return null;
    }
    return stdout.trim();
  } catch {
    return null;
  }
}

// claude/src/prompts.ts
var fs = __toESM(require("fs"), 1);
var path = __toESM(require("path"), 1);
function substituteVars(template, vars) {
  return template.replace(/\{\{([^}]+)\}\}/g, (match, varName) => {
    const trimmedName = varName.trim();
    return vars[trimmedName] ?? match;
  });
}
function resolvePromptDir(promptDir, basePath = process.cwd()) {
  const dirPath = path.resolve(basePath, ".github/prompts", promptDir);
  const promptPath = path.join(dirPath, "prompt.txt");
  const schemaPath = path.join(dirPath, "outputs.json");
  return {
    promptPath,
    schemaPath: fs.existsSync(schemaPath) ? schemaPath : void 0
  };
}
function resolvePrompt(options, basePath = process.cwd()) {
  const { prompt, promptFile, promptDir, promptVars } = options;
  if (prompt) {
    let resolvedPrompt = prompt;
    if (promptVars) {
      resolvedPrompt = substituteVars(resolvedPrompt, promptVars);
    }
    return { prompt: resolvedPrompt };
  }
  if (promptDir) {
    const { promptPath, schemaPath } = resolvePromptDir(promptDir, basePath);
    if (!fs.existsSync(promptPath)) {
      throw new Error(
        `Prompt file not found: ${promptPath} (from promptDir: ${promptDir})`
      );
    }
    let resolvedPrompt = fs.readFileSync(promptPath, "utf-8");
    if (promptVars) {
      resolvedPrompt = substituteVars(resolvedPrompt, promptVars);
    }
    let outputSchema;
    if (schemaPath) {
      const schemaContent = fs.readFileSync(schemaPath, "utf-8");
      outputSchema = JSON.parse(schemaContent);
    }
    return { prompt: resolvedPrompt, outputSchema };
  }
  if (promptFile) {
    const promptPath = path.resolve(basePath, promptFile);
    if (!fs.existsSync(promptPath)) {
      throw new Error(`Prompt file not found: ${promptFile}`);
    }
    let resolvedPrompt = fs.readFileSync(promptPath, "utf-8");
    if (promptVars) {
      resolvedPrompt = substituteVars(resolvedPrompt, promptVars);
    }
    return { prompt: resolvedPrompt };
  }
  throw new Error("Either prompt, promptFile, or promptDir must be provided");
}
function buildImplementationPrompt(issueNumber, issueTitle, issueBody, branch) {
  return `You are implementing GitHub issue #${issueNumber}: ${issueTitle}

## Issue Description

${issueBody}

## Instructions

1. Work on branch: ${branch}
2. Implement the requirements described in the issue
3. Ensure all tests pass
4. Commit your changes with clear commit messages
5. Push when ready

Focus on completing all the TODO items in the issue description.
If you encounter any blockers, document them clearly.`;
}
function buildCIFixPrompt(issueNumber, ciRunUrl, commitSha) {
  return `You are fixing CI failures for issue #${issueNumber}.

## CI Information

- CI Run: ${ciRunUrl || "N/A"}
- Commit: ${commitSha || "N/A"}

## Instructions

1. Check the CI logs at the URL above
2. Identify the failing tests or build errors
3. Fix the issues in your code
4. Ensure all tests pass locally before pushing
5. Push your fixes

Common issues to check:
- Type errors
- Lint violations
- Failing tests
- Build errors`;
}
function buildReviewResponsePrompt(issueNumber, reviewDecision, reviewer) {
  return `You are addressing review feedback for issue #${issueNumber}.

## Review Information

- Decision: ${reviewDecision || "N/A"}
- Reviewer: ${reviewer || "N/A"}

## Instructions

1. Review the feedback provided in the PR comments
2. Address each piece of feedback
3. Make the necessary code changes
4. Ensure all tests still pass
5. Push your updates

If you disagree with any feedback, document your reasoning in a comment.`;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  buildCIFixPrompt,
  buildImplementationPrompt,
  buildReviewResponsePrompt,
  executeClaudeSDK,
  getClaudeVersion,
  isClaudeAvailable,
  resolvePrompt,
  resolvePromptDir,
  substituteVars
});
/*! Bundled license information:

undici/lib/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)

undici/lib/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)
*/
//# sourceMappingURL=index.cjs.map
